<!DOCTYPE html>
<html  lang="zh">
<head>
    <meta charset="utf-8" />

<meta name="generator" content="Hexo 3.9.0" />

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<title>AFL漏洞挖掘技术漫谈：Fuzz结果分析和代码覆盖率 - Jon Tsang&#39;Blog</title>


    <meta name="description" content="前言上一篇文章中向大家介绍了使用AFL开始模糊测试前要做的一些准备工作，以及AFL的几种工作方式，但是并没有提到何时结束测试过程，以及测试完成后又需要做些什么。本文中就继续介绍这些内容，并开始逐步介绍一些AFL相关原理。以下就是本文中主要讨论的问题：  何时结束Fuzzing工作 afl-fuzz生成了哪些文件 如何对产生的crash进行验证和分类 用什么来评估Fuzzing的结果 代码覆盖率及相">
<meta name="keywords" content="漏洞,Binary,fuzzing">
<meta property="og:type" content="article">
<meta property="og:title" content="AFL漏洞挖掘技术漫谈：Fuzz结果分析和代码覆盖率">
<meta property="og:url" content="https://jontsang.github.io/post/16717156.html">
<meta property="og:site_name" content="Jon Tsang&#39;Blog">
<meta property="og:description" content="前言上一篇文章中向大家介绍了使用AFL开始模糊测试前要做的一些准备工作，以及AFL的几种工作方式，但是并没有提到何时结束测试过程，以及测试完成后又需要做些什么。本文中就继续介绍这些内容，并开始逐步介绍一些AFL相关原理。以下就是本文中主要讨论的问题：  何时结束Fuzzing工作 afl-fuzz生成了哪些文件 如何对产生的crash进行验证和分类 用什么来评估Fuzzing的结果 代码覆盖率及相">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://jontsang.github.io/images/og_image.png">
<meta property="og:updated_time" content="2019-08-30T08:44:16.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AFL漏洞挖掘技术漫谈：Fuzz结果分析和代码覆盖率">
<meta name="twitter:description" content="前言上一篇文章中向大家介绍了使用AFL开始模糊测试前要做的一些准备工作，以及AFL的几种工作方式，但是并没有提到何时结束测试过程，以及测试完成后又需要做些什么。本文中就继续介绍这些内容，并开始逐步介绍一些AFL相关原理。以下就是本文中主要讨论的问题：  何时结束Fuzzing工作 afl-fuzz生成了哪些文件 如何对产生的crash进行验证和分类 用什么来评估Fuzzing的结果 代码覆盖率及相">
<meta name="twitter:image" content="https://jontsang.github.io/images/og_image.png">







<link rel="icon" href="/images/favicon.svg">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.4.1/css/all.min.css">
<link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css">


    
    
    
    <style>body>.footer,body>.navbar,body>.section{opacity:0}</style>
    

    
    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">
    

    
    

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">


    
    
    
    

<link rel="stylesheet" href="/css/back-to-top.css">


    
    

    
    
    
    

    
    
<link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

    
    
    
        <script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    

    


<link rel="stylesheet" href="/css/style.css">
</head>
<!-- <body class="is-2-column"> -->
<body class="is-3-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.svg" alt="AFL漏洞挖掘技术漫谈：Fuzz结果分析和代码覆盖率" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">主页</a>
                
                <a class="navbar-item"
                href="/archives">归档</a>
                
                <a class="navbar-item"
                href="/categories">分类</a>
                
                <a class="navbar-item"
                href="/tags">标签</a>
                
                <a class="navbar-item"
                href="/about">关于</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    
                    <a class="navbar-item" target="_blank" title="Download on GitHub" href="https://github.com/JonTsang">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                <a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;">
                    <i class="fas fa-list-ul"></i>
                </a>
                
                
                <a class="navbar-item search" title="搜索" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-9-widescreen has-order-2 column-main"><div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-01-11T11:59:17.000Z">2019-01-11</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Fuzzing/">Fuzzing</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    31 分钟 读完 (大约 4593 个字)
                </span>
                
                
                <span class="level-item has-text-grey" id="busuanzi_container_page_pv">
                    <i class="far fa-eye"></i>
                    <span id="busuanzi_value_page_pv">0</span>次访问
                </span>
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                AFL漏洞挖掘技术漫谈：Fuzz结果分析和代码覆盖率
            
        </h1>
        <div class="content">
            <p>前言<br>上一篇<a href="https://www.freebuf.com/system/191543.html" target="_blank" rel="noopener">文章</a>中向大家介绍了使用AFL开始模糊测试前要做的一些准备工作，以及AFL的几种工作方式，但是并没有提到何时结束测试过程，以及测试完成后又需要做些什么。本文中就继续介绍这些内容，并开始逐步介绍一些AFL相关原理。以下就是本文中主要讨论的问题：</p>
<ul>
<li>何时结束Fuzzing工作</li>
<li>afl-fuzz生成了哪些文件</li>
<li>如何对产生的crash进行验证和分类</li>
<li>用什么来评估Fuzzing的结果</li>
<li>代码覆盖率及相关概念</li>
<li>AFL是如何记录代码覆盖率的</li>
</ul>
<a id="more"></a>
<h2 id="Fuzzer工作状态"><a href="#Fuzzer工作状态" class="headerlink" title="Fuzzer工作状态"></a>Fuzzer工作状态</h2><p>因为<em>afl-fuzz</em>永远不会停止，所以何时停止测试很多时候就是依靠<em>afl-fuzz</em>提供的状态来决定的。除了前面提到过的通过状态窗口、<em>afl-whatsup</em>查看<em>afl-fuzz</em>状态外，这里再补充几种方法。</p>
<h3 id="1-afl-stat"><a href="#1-afl-stat" class="headerlink" title="1. afl-stat"></a>1. afl-stat</h3><p><em>afl-stat</em>是<a href="https://gitlab.com/rc0r/afl-utils" target="_blank" rel="noopener">afl-utils</a>这套工具AFL辅助工具中的一个（这套工具中还有其他更好用的程序，后面用到时会做介绍），该工具类似于<em>afl-whatsup</em>的输出结果。</p>
<p>使用前需要一个配置文件，设置每个afl-fuzz实例的输出目录：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;fuzz_dirs&quot;: [</span><br><span class="line">        &quot;/root/syncdir/SESSION000&quot;,</span><br><span class="line">        &quot;/root/syncdir/SESSION001&quot;,</span><br><span class="line">   		...</span><br><span class="line">   		&quot;/root/syncdir/SESSION00x&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后指定配置文件运行即可：<br><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">$</span> afl-stats -c afl-stats.conf</span><br><span class="line">[SESSION000 on fuzzer1]</span><br><span class="line"> Alive:   1/1</span><br><span class="line"> Execs:   64 m</span><br><span class="line"> Speed:   0.3 x/s</span><br><span class="line"> Pend:    6588/249</span><br><span class="line"> Crashes: 101</span><br><span class="line">[SESSION001 on fuzzer1]</span><br><span class="line"> Alive:   1/1</span><br><span class="line"> Execs:   105 m</span><br><span class="line"> Speed:   576.6 x/s</span><br><span class="line"> Pend:    417/0</span><br><span class="line"> Crashes: 291</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h3 id="2-定制afl-whatsup"><a href="#2-定制afl-whatsup" class="headerlink" title="2. 定制afl-whatsup"></a>2. 定制afl-whatsup</h3><p><em>afl-whatsup</em>是依靠读afl-fuzz输出目录中的<em>fuzzer_stats</em>文件来显示状态的，每次查看都要需要手动执行，十分麻烦。因此可以对其进行修改，让其实时显示fuzzer的状态。方法也很简答，基本思路就是在所有代码外面加个循环就好，还可以根据自己的喜好做些调整：<br><img src="https://raw.githubusercontent.com/JonTsang/Figurebed/master/img/20190825163701.jpg" alt></p>
<h3 id="3-afl-plot"><a href="#3-afl-plot" class="headerlink" title="3. afl-plot"></a>3. afl-plot</h3><p>前面提到的都是基于命令行的工具，如果还想要更直观的结果，可以用<em>afl-plot</em>绘制各种状态指标的直观变化趋势。<br><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#</span>安装依赖工具gnuplot</span><br><span class="line"><span class="hljs-meta">$</span> apt-get install gnuplot</span><br><span class="line"><span class="hljs-meta">$</span> afl-plot afl_state_dir graph_output_dir</span><br></pre></td></tr></table></figure></p>
<p>以测试libtiff的情况为例，进入afl-plot输出目录，打开<em>index.html</em>，会看到下面三张图：</p>
<p>首先是路径覆盖的变化，当<strong>pending fav</strong>的数量变为零并且<strong>total paths</strong>数量基本上没有再增长时，说明fuzzer有新发现的可能性就很小了。</p>
<p><img src="https://raw.githubusercontent.com/JonTsang/Figurebed/master/img/20190825163657.jpg" alt="high_freq"></p>
<p>接着是崩溃和超时的变化</p>
<p><img src="https://raw.githubusercontent.com/JonTsang/Figurebed/master/img/20190825164622.jpg" alt="low_freq"></p>
<p>最后是执行速度的变化，这里要注意的是，如果随着时间的推移，执行速度越来越慢，有一种可能是因为fuzzer耗尽一些共享资源。</p>
<p><img src="https://raw.githubusercontent.com/JonTsang/Figurebed/master/img/20190825163658.jpg" alt="exec_speed"></p>
<h3 id="4-pythia"><a href="#4-pythia" class="headerlink" title="4. pythia"></a>4. pythia</h3><p>笔者在查阅资料的过程中，还发现了<a href="https://github.com/mboehme/pythia" target="_blank" rel="noopener">pythia</a>这个AFL的扩展项目，虽然不知道效果如何，但这里还是顺便提一提。其特色在于可以估算发现新crash和path概率，其运行界面相比原版的AFL多出了下面几个字段：</p>
<p><img src="https://raw.githubusercontent.com/JonTsang/Figurebed/master/img/20190825163700.jpg" alt></p>
<p>correctness: 在没有发现crash时，发现一个导致crash输入的概率。<br>fuzzability: 表示在该程序中发现新路径的难度，该数值越高代表程序越容易Fuzz。<br>current paths: 显示当前发现的路径数。<br>path coverag: 路径覆盖率。</p>
<h2 id="三、结束测试"><a href="#三、结束测试" class="headerlink" title="三、结束测试"></a>三、结束测试</h2><h3 id="1-何时结束"><a href="#1-何时结束" class="headerlink" title="1.何时结束"></a>1.何时结束</h3><p>检查<em>afl-fuzz</em>工作状态的目的是为何时停止测试提供依据，通常来说符合下面几种情况时就可以停掉了。</p>
<ol>
<li><p>状态窗口中”cycles done”字段颜色变为绿色该字段的颜色可以作为何时停止测试的参考，随着周期数不断增大，其颜色也会由洋红色，逐步变为黄色、蓝色、绿色。当其变为绿色时，继续Fuzzing下去也很难有新的发现了，这时便可以通过Ctrl-C停止afl-fuzz。<br><img src="https://raw.githubusercontent.com/JonTsang/Figurebed/master/img/20190825164614.jpg" alt></p>
</li>
<li><p>距上一次发现新路径（或者崩溃）已经过去很长时间了，至于具体多少时间还是需要自己把握，比如长达一个星期或者更久估计大家也都没啥耐心了吧。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/JonTsang/Figurebed/master/img/20190825163654.jpg" alt></p>
<ol start="3">
<li>目标程序的代码几乎被测试用例完全覆盖，这种情况好像很少见，但是对于某些小型程序应该还是可能的，至于如何计算覆盖率将在下面介绍。</li>
<li>上面提到的pythia提供的各种数据中，一旦<strong>path covera</strong>达到99％（通常来说不太可能），如果不期望再跑出更多crash的话就可以中止fuzz了，因为很多crash可能是因为相同的原因导致的；还有一点就是<strong>correctness</strong>的值达到<strong>1e-08</strong>，根据pythia开发者的说法，这时从上次发现path/uniq crash到下一次发现之间大约需要1亿次执行，这一点也可以作为衡量依据。</li>
</ol>
<h3 id="2-输出结果"><a href="#2-输出结果" class="headerlink" title="2. 输出结果"></a>2. 输出结果</h3><p><em>afl-fuzz</em>的输出目录中存在很多文件，有时想要写一个辅助工具可能就要用到其中的文件。下面以多个fuzz实例并行测试时的同步目录为例：</p>
<figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">$</span> tree -L 3</span><br><span class="line">.</span><br><span class="line">├── fuzzer1</span><br><span class="line">│   ├── crashes</span><br><span class="line">│   │   ├── id:000000,sig:06,src:000019+000074,op:splice,rep:2</span><br><span class="line">│   │   ├── ...</span><br><span class="line">│   │   ├── id:000002,sig:06,src:000038+000125,op:splice,rep:4</span><br><span class="line">│   │   └── README.txt</span><br><span class="line">│   ├── fuzz_bitmap</span><br><span class="line">│   ├── fuzzer_stats</span><br><span class="line">│   ├── hangs</span><br><span class="line">│   │   └── id:000000,src:000007,op:flip1,pos:55595</span><br><span class="line">│   ├── plot_data</span><br><span class="line">│   └── queue</span><br><span class="line">│       ├── id:000000,orig:1.png</span><br><span class="line">│ 		├── ....	</span><br><span class="line">│       └── id:000101,sync:fuzzer10,src:000102</span><br><span class="line">└── fuzzer2</span><br><span class="line">    ├── crashes</span><br><span class="line">    ├── ...</span><br></pre></td></tr></table></figure>
<p>queue：存放所有具有独特执行路径的测试用例。<br>crashes：导致目标接收致命signal而崩溃的独特测试用例。<br>crashes/README.txt：保存了目标执行这些crash文件的命令行参数。<br>hangs：导致目标超时的独特测试用例。<br>fuzzer_stats：afl-fuzz的运行状态。<br>plot_data：用于afl-plot绘图。</p>
<h2 id="四、处理测试结果"><a href="#四、处理测试结果" class="headerlink" title="四、处理测试结果"></a>四、处理测试结果</h2><p>到了这里，我们可能已经跑出了一大堆的crashes，那么接下来的步骤，自然是确定造成这些crashes的bug是否可以利用，怎么利用？这是另一个重要方面。当然，个人觉得这比前面提到的内容都要困难得多，这需要对常见的二进制漏洞类型、操作系统的安全机制、代码审计和调试等内容都有一定深度的了解。但如果只是对crash做简单的分析和分类，那么下面介绍的几种方法都可以给我们提供一些帮助。</p>
<h3 id="1-crash-exploration-mode"><a href="#1-crash-exploration-mode" class="headerlink" title="1. crash exploration mode"></a>1. crash exploration mode</h3><p>这是afl-fuzz的一种运行模式，也称为<strong>peruvian rabbit mode</strong>，用于确定bug的可利用性，具体细节可以参考<a href="https://lcamtuf.blogspot.com/2014/11/afl-fuzz-crash-exploration-mode.html" target="_blank" rel="noopener">lcamtuf</a>的博客。<br><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">$</span> afl-fuzz -m none -C -i poc -o peruvian-were-rabbit_out -- ~/src/LuPng/a.out @@ out.png</span><br></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/JonTsang/Figurebed/master/img/20190825163704.jpg" alt></p>
<p>举个例子，当你发现目标程序尝试写入\跳转到一个明显来自输入文件的内存地址，那么就可以猜测这个bug应该是可以利用的；然而遇到例如NULL pointer dereferences这样的漏洞就没那么容易判断了。</p>
<p>将一个导致crash测试用例作为<em>afl-fuzz</em>的输入，使用<em>-C</em>选项开启crash exploration模式后，可以快速地产生很多和输入crash相关、但稍有些不同的crashes，从而判断能够控制某块内存地址的长度。这里笔者在实践中没有找到适合的例子，但在一篇<a href="https://countuponsecurity.com/tag/peruvian-were-rabbit/" target="_blank" rel="noopener">文章</a>中发现了一个很不错的例子——tcpdump栈溢出漏洞，crash exploration模式从一个crash产生了42个新的crash，并读取不同大小的相邻内存。</p>
<p><img src="https://raw.githubusercontent.com/JonTsang/Figurebed/master/img/20190825163656.jpg" alt></p>
<h3 id="2-triage-crashes"><a href="#2-triage-crashes" class="headerlink" title="2. triage_crashes"></a>2. triage_crashes</h3><p>AFL源码的experimental目录中有一个名为<em>triage_crashes.sh</em>的脚本，可以帮助我们触发收集到的crashes。例如下面的例子中，11代表了SIGSEGV信号，有可能是因为缓冲区溢出导致进程引用了无效的内存；06代表了SIGABRT信号，可能是执行了abort\assert函数或double free导致，这些结果可以作为简单的参考。</p>
<figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">$</span> ~/afl-2.52b/experimental/crash_triage/triage_crashes.sh fuzz_out ~/src/LuPng/a.out @@ out.png 2&gt;&amp;1 | grep SIGNAL</span><br><span class="line">   +++ ID 000000, SIGNAL 11 +++</span><br><span class="line">   +++ ID 000001, SIGNAL 06 +++</span><br><span class="line">   +++ ID 000002, SIGNAL 06 +++</span><br><span class="line">   +++ ID 000003, SIGNAL 06 +++</span><br><span class="line">   +++ ID 000004, SIGNAL 11 +++</span><br><span class="line">   +++ ID 000005, SIGNAL 11 +++</span><br><span class="line">   +++ ID 000006, SIGNAL 11 +++</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<h3 id="3-crashwalk"><a href="#3-crashwalk" class="headerlink" title="3. crashwalk"></a>3. crashwalk</h3><p>当然上面的两种方式都过于鸡肋了，如果你想得到更细致的crashes分类结果，以及导致crashes的具体原因，那么<a href="https://github.com/bnagy/crashwalk" target="_blank" rel="noopener">crashwalk</a>就是不错的选择之一。这个工具基于gdb的exploitable插件，安装也相对简单，在ubuntu上，只需要如下几步即可：</p>
<figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">$</span> apt-get install gdb golang</span><br><span class="line"><span class="hljs-meta">$</span> mkdir tools</span><br><span class="line"><span class="hljs-meta">$</span> cd tools</span><br><span class="line"><span class="hljs-meta">$</span> git clone https://github.com/jfoote/exploitable.git</span><br><span class="line"><span class="hljs-meta">$</span> mkdir go</span><br><span class="line"><span class="hljs-meta">$</span> export GOPATH=~/tools/go</span><br><span class="line"><span class="hljs-meta">$</span> export CW_EXPLOITABLE=~/tools/exploitable/exploitable/exploitable.py</span><br><span class="line"><span class="hljs-meta">$</span> go get -u github.com/bnagy/crashwalk/cmd/...</span><br></pre></td></tr></table></figure>
<p>crashwalk支持AFL/Manual两种模式。前者通过读取<strong>crashes/README.txt</strong>文件获得目标的执行命令（前面第三节中提到的），后者则可以手动指定一些参数。两种使用方式如下：</p>
<figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#</span>Manual Mode</span><br><span class="line"><span class="hljs-meta">$</span> ~/tools/go/bin/cwtriage -root syncdir/fuzzer1/crashes/ -match id -- ~/parse @@</span><br><span class="line"><span class="hljs-meta">#</span>AFL Mode</span><br><span class="line"><span class="hljs-meta">$</span> ~/tools/go/bin/cwtriage -root syncdir -afl</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/JonTsang/Figurebed/master/img/20190825163707.jpg" alt></p>
<p>两种模式的输出结果都一样，如上图所示。这个工具比前面几种方法要详细多了，但当有大量crashes时结果显得还是十分混乱。</p>
<h3 id="4-afl-collect"><a href="#4-afl-collect" class="headerlink" title="4. afl-collect"></a>4. afl-collect</h3><p>最后重磅推荐的工具便是<em>afl-collect</em>，它也是<em>afl-utils</em>套件中的一个工具，同样也是基于exploitable来检查crashes的可利用性。它可以自动删除无效的crash样本、删除重复样本以及自动化样本分类。使用起来命令稍微长一点，如下所示：</p>
<figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">$</span> afl-collect -j 8 -d crashes.db -e gdb_script ./afl_sync_dir ./collection_dir --  /path/to/target --target-opts</span><br></pre></td></tr></table></figure>
<p>但是结果就像下面这样非常直观：</p>
<p><img src="https://raw.githubusercontent.com/JonTsang/Figurebed/master/img/20190825163709.jpg" alt></p>
<h2 id="五、代码覆盖率及其相关概念"><a href="#五、代码覆盖率及其相关概念" class="headerlink" title="五、代码覆盖率及其相关概念"></a>五、代码覆盖率及其相关概念</h2><p>代码覆盖率是模糊测试中一个极其重要的概念，<strong>使用代码覆盖率可以评估和改进测试过程，执行到的代码越多，找到bug的可能性就越大</strong>，毕竟，在覆盖的代码中并不能100%发现bug，在未覆盖的代码中却是100%找不到任何bug的，所以本节中就将详细介绍代码覆盖率的相关概念。</p>
<h3 id="1-代码覆盖率（Code-Coverage）"><a href="#1-代码覆盖率（Code-Coverage）" class="headerlink" title="1. 代码覆盖率（Code Coverage）"></a>1. 代码覆盖率（Code Coverage）</h3><p>代码覆盖率是一种度量代码的覆盖程度的方式，也就是指源代码中的某行代码是否已执行；对二进制程序，还可将此概念理解为汇编代码中的某条指令是否已执行。其计量方式很多，但无论是GCC的GCOV还是LLVM的SanitizerCoverage，都提供函数（function）、基本块（basic-block）、边界（edge）三种级别的覆盖率检测，更具体的细节可以参考LLVM的<a href="https://clang.llvm.org/docs/SanitizerCoverage.html" target="_blank" rel="noopener">官方文档</a>。</p>
<h3 id="2-基本块（Basic-Block）"><a href="#2-基本块（Basic-Block）" class="headerlink" title="2. 基本块（Basic Block）"></a>2. 基本块（Basic Block）</h3><p>缩写为BB，指一组顺序执行的指令，BB中第一条指令被执行后，后续的指令也会被全部执行，每个BB中所有指令的执行次数是相同的，也就是说一个BB必须满足以下特征：</p>
<ul>
<li>只有一个入口点，BB中的指令不是任何<strong>跳转指令</strong>的目标。</li>
<li>只有一个退出点，只有最后一条指令使执行流程转移到另一个BB</li>
</ul>
<p>例如下图中的代码就可以被切割为4个基本块，平时我们在IDA图形模式中看到的就是一个一个的基本块</p>
<p><img src="https://raw.githubusercontent.com/JonTsang/Figurebed/master/img/20190825163659.jpg" alt></p>
<p>将上面的程序拖进IDA，可以看到同样被划分出了4个基本块：</p>
<p><img src="https://raw.githubusercontent.com/JonTsang/Figurebed/master/img/20190825163702.jpg" alt></p>
<h3 id="3-边（edge）"><a href="#3-边（edge）" class="headerlink" title="3. 边（edge）"></a>3. 边（edge）</h3><p>AFL的<a href="http://lcamtuf.coredump.cx/afl/technical_details.txt" target="_blank" rel="noopener">技术白皮书</a>中提到fuzzer通过插桩代码捕获边（edge）覆盖率。那么什么是edge呢？我们可以将程序看成一个控制流图（CFG），图的每个节点表示一个基本块，而edge就被用来表示在基本块之间的转跳。知道了每个基本块和跳转的执行次数，就可以知道程序中的每个语句和分支的执行次数，从而获得比记录BB更细粒度的覆盖率信息。</p>
<p><img src="https://raw.githubusercontent.com/JonTsang/Figurebed/master/img/20190825163703.jpg" alt></p>
<h3 id="4-元组（tuple）"><a href="#4-元组（tuple）" class="headerlink" title="4. 元组（tuple）"></a>4. 元组（tuple）</h3><p>具体到AFL的实现中，使用二元组(branch_src, branch_dst)来记录<strong>当前基本块</strong> + <strong>前一基本块</strong> 的信息，从而获取目标的执行流程和代码覆盖情况，伪代码如下：</p>
<figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;			<span class="hljs-comment">//用一个随机数标记当前基本块</span></span><br><span class="line">shared_mem[cur_location ^ prev_location]++;		<span class="hljs-comment">//将当前块和前一块异或保存到shared_mem[]</span></span><br><span class="line">prev_location = cur_location &gt;&gt; <span class="hljs-number">1</span>;				<span class="hljs-comment">//cur_location右移1位区分从当前块到当前块的转跳</span></span><br></pre></td></tr></table></figure>
<p>实际插入的汇编代码，如下图所示，首先保存各种寄存器的值并设置ecx/rcx，然后调用<code>__afl_maybe_log</code>，这个方法的内容相当复杂，这里就不展开讲了，但其主要功能就和上面的伪代码相似，用于记录覆盖率，放入一块共享内存中。</p>
<p><img src="https://raw.githubusercontent.com/JonTsang/Figurebed/master/img/20190825163705.jpg" alt></p>
<h2 id="六、计算代码覆盖率"><a href="#六、计算代码覆盖率" class="headerlink" title="六、计算代码覆盖率"></a>六、计算代码覆盖率</h2><p>了解了代码覆盖率相关的概念后，接下来看看如何计算我们的测试用例对前面测试目标的代码覆盖率。</p>
<p>这里需要用到的工具之一是<strong>GCOV</strong>，它随gcc一起发布，所以不需要再单独安装，和afl-gcc插桩编译的原理一样，gcc编译时生成插桩的程序，用于在执行时生成代码覆盖率信息。</p>
<p>另外一个工具是<strong>LCOV</strong>，它是GCOV的图形前端，可以收集多个源文件的gcov数据，并创建包含使用覆盖率信息注释的源代码HTML页面。</p>
<p>最后一个工具是<a href="https://github.com/mrash/afl-cov" target="_blank" rel="noopener">afl-cov</a>，可以快速帮助我们调用前面两个工具处理来自afl-fuzz测试用例的代码覆盖率结果。在ubuntu中可以使用<code>apt-get install afl-cov</code>安装afl-cov，但这个版本似乎不支持分支覆盖率统计，所以还是从Github下载最新版本为好，下载完无需安装直接运行目录中的Python脚本即可使用：</p>
<figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">$</span> apt-get install lcov</span><br><span class="line"><span class="hljs-meta">$</span> git clone https://github.com/mrash/afl-cov.git</span><br><span class="line"><span class="hljs-meta">$</span> ./afl-cov/afl-cov -V</span><br><span class="line">afl-cov-0.6.2</span><br></pre></td></tr></table></figure>
<p>还是以Fuzz libtiff为例，计算Fuzzing过程的代码覆盖率流程如下：</p>
<p>第一步，使用gcov重新编译源码，在CFLAGS中添加<code>&quot;-fprofile-arcs&quot;</code>和<code>&quot;-ftest-coverage&quot;</code>选项，可以在<code>--prefix</code>中重新指定一个新的目录以免覆盖之前alf插桩的二进制文件。</p>
<figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">$</span> make clean</span><br><span class="line"><span class="hljs-meta">$</span> ./configure --prefix=/root/tiff-4.0.10/build-cov CC="gcc" CXX="g++" CFLAGS="-fprofile-arcs -ftest-coverage" --disable-shared</span><br><span class="line"><span class="hljs-meta">$</span> make</span><br><span class="line"><span class="hljs-meta">$</span> make install</span><br></pre></td></tr></table></figure>
<p>第二步，执行afl-cov。其中<em>-d</em>选项指定afl-fuzz输出目录；<em>—live</em>用于处理一个还在实时更新的AFL目录，当afl-fuzz停止时，afl-cov将退出；<em>–enable-branch-coverage</em>用于开启边缘覆盖率（分支覆盖率）统计；<em>-c</em>用于指定源码目录；最后一个<em>-e</em>选项用来设置要执行的程序和参数，其中的<em>AFL_FILE</em>和afl中的”@@”类似，会被替换为测试用例，<em>LD_LIBRARY_PATH</em>则用来指定程序的库文件。</p>
<figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">$</span> cd ~/tiff-4.0.10</span><br><span class="line"><span class="hljs-meta">$</span> afl-cov -d ~/syncdir --live --enable-branch-coverage -c . -e "cat AFL_FILE | LD_LIBRARY_PATH=./build-cov/lib ./build-cov/bin/tiff2pdf AFL_FILE"</span><br></pre></td></tr></table></figure>
<p>成功执行的结果如下所示：</p>
<p><img src="https://raw.githubusercontent.com/JonTsang/Figurebed/master/img/20190825164805.jpg" alt></p>
<p>我们可以通过<em>—live</em>选择，在fuzzer运行的同时计算覆盖率，也可以在测试结束以后再进行计算，最后会得到一个像下面这样的html文件。它既提供了概述页面，显示各个目录的覆盖率；也可以在点击进入某个目录查看某个具体文件的覆盖率。</p>
<p><img src="https://raw.githubusercontent.com/JonTsang/Figurebed/master/img/20190825163708.jpg" alt></p>
<p>点击进入每个文件，还有更详细的数据。每行代码前的数字代表这行代码被执行的次数，没有执行过的代码会被红色标注出来。</p>
<p><img src="https://raw.githubusercontent.com/JonTsang/Figurebed/master/img/20190825163706.jpg" alt></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://countuponsecurity.com/2018/04/24/intro-to-american-fuzzy-lop-fuzzing-with-asan-and-beyond/" target="_blank" rel="noopener">INTRO TO AMERICAN FUZZY LOP – FUZZING WITH ASAN AND BEYOND</a></p>
<p><a href="https://media.defcon.org/DEF%20CON%2026/DEF%20CON%2026%20workshops/DEFCON-26-Workshop-Jakub-Botwicz-and-Wojciech-Rauner-Fuzzing-with-AFL-(American-Fuzzy-Lop" target="_blank" rel="noopener">Fuzzing with AFL</a>.pdf)</p>
<p><a href="https://clang.llvm.org/docs/SanitizerCoverage.html" target="_blank" rel="noopener">Clang 9 documentation - SanitizerCoverage</a></p>
<p><a href="http://riusksk.me/2018/07/29/honggfuzz%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF1/" target="_blank" rel="noopener">honggfuzz漏洞挖掘技术深究系列</a></p>
<p><a href="https://www.seguetech.com/how-much-test-coverage-enough-testing-strategy/" target="_blank" rel="noopener">How Much Test Coverage Is Enough For Your Testing Strategy?</a></p>

        </div>
        <!-- 文章结尾添加版权声明 从这里开始 -->
        
        <ul class="post-copyright">
        <li><strong>本文标题：</strong><a href="https://jontsang.github.io/post/16717156.html">AFL漏洞挖掘技术漫谈：Fuzz结果分析和代码覆盖率</a></li>
        <li><strong>本文作者：</strong><a href="https://jontsang.github.io">Jon Tsang</a></li>
        <!-- <li><strong>本文链接：</strong><a href="https://jontsang.github.io/post/16717156.html">https://jontsang.github.io/post/16717156.html</a></li> -->
        <li><strong>发布时间：</strong>2019-01-11</li>
        <li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li>
        </ul>
        
        <!-- 文章结尾添加版权声明 到这里结束 -->
        
        <div class="level is-size-7 is-uppercase">
            <div class="level-start">
                <div class="level-item">
                    <span class="is-size-6 has-text-grey has-mr-7">#</span>
                    <a class="has-link-grey -link" href="/tags/Binary/">Binary</a>, <a class="has-link-grey -link" href="/tags/fuzzing/">fuzzing</a>, <a class="has-link-grey -link" href="/tags/漏洞/">漏洞</a>
                </div>
            </div>
        </div>
        
        
        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3>
        <div class="buttons is-centered">
            
                
<a class="button is-info donate">
    <span class="icon is-small">
        <i class="fab fa-alipay"></i>
    </span>
    <span>支付宝</span>
    <div class="qrcode"><img src="https://raw.githubusercontent.com/JonTsang/Figurebed/master/img/20190822175230.jpg" alt="支付宝"></div>
</a>

                
                
<a class="button is-success donate">
    <span class="icon is-small">
        <i class="fab fa-weixin"></i>
    </span>
    <span>微信</span>
    <div class="qrcode"><img src="https://raw.githubusercontent.com/JonTsang/Figurebed/master/img/20190822175230.jpg" alt="微信"></div>
</a>

                
        </div>
    </div>
</div>



<div class="card card-transparent">
    <div class="level post-navigation is-flex-wrap is-mobile">
        
        <div class="level-start">
            <a class="level level-item has-link-grey  article-nav-prev" href="/post/aab8343b.html">
                <i class="level-item fas fa-chevron-left"></i>
                <span class="level-item">CVE-2019-0211——Apache HTTP组件提权漏洞利</span>
            </a>
        </div>
        
        
        <div class="level-end">
            <a class="level level-item has-link-grey  article-nav-next" href="/post/6c314f.html">
                <span class="level-item">AFL漏洞挖掘技术漫谈：使用AFL开始第一Fuzzing</span>
                <i class="level-item fas fa-chevron-right"></i>
            </a>
        </div>
        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="title is-5 has-text-weight-normal">评论</h3>
        
<div id="valine-thread" class="content"></div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#valine-thread' ,
        notify: true,
        verify: false,
        app_id: '2oTcdkk2ubE6P9DwKwwTTlDK-gzGzoHsz',
        app_key: 'z1TMyiu5W0zvLI3qKElhM6uU',
        placeholder: '不用注册也可以评论哟~支持Markdown~'
    });
</script>

    </div>
</div>
</div>
                




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left is-sticky">
    
        
<div class="card widget" id="toc">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                目录
            </h3>
            <ul class="menu-list"><li>
        <a class="is-flex" href="#Fuzzer工作状态">
        <span class="has-mr-6">1</span>
        <span>Fuzzer工作状态</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#1-afl-stat">
        <span class="has-mr-6">1.1</span>
        <span>1. afl-stat</span>
        </a></li><li>
        <a class="is-flex" href="#2-定制afl-whatsup">
        <span class="has-mr-6">1.2</span>
        <span>2. 定制afl-whatsup</span>
        </a></li><li>
        <a class="is-flex" href="#3-afl-plot">
        <span class="has-mr-6">1.3</span>
        <span>3. afl-plot</span>
        </a></li><li>
        <a class="is-flex" href="#4-pythia">
        <span class="has-mr-6">1.4</span>
        <span>4. pythia</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#三、结束测试">
        <span class="has-mr-6">2</span>
        <span>三、结束测试</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#1-何时结束">
        <span class="has-mr-6">2.1</span>
        <span>1.何时结束</span>
        </a></li><li>
        <a class="is-flex" href="#2-输出结果">
        <span class="has-mr-6">2.2</span>
        <span>2. 输出结果</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#四、处理测试结果">
        <span class="has-mr-6">3</span>
        <span>四、处理测试结果</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#1-crash-exploration-mode">
        <span class="has-mr-6">3.1</span>
        <span>1. crash exploration mode</span>
        </a></li><li>
        <a class="is-flex" href="#2-triage-crashes">
        <span class="has-mr-6">3.2</span>
        <span>2. triage_crashes</span>
        </a></li><li>
        <a class="is-flex" href="#3-crashwalk">
        <span class="has-mr-6">3.3</span>
        <span>3. crashwalk</span>
        </a></li><li>
        <a class="is-flex" href="#4-afl-collect">
        <span class="has-mr-6">3.4</span>
        <span>4. afl-collect</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#五、代码覆盖率及其相关概念">
        <span class="has-mr-6">4</span>
        <span>五、代码覆盖率及其相关概念</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#1-代码覆盖率（Code-Coverage）">
        <span class="has-mr-6">4.1</span>
        <span>1. 代码覆盖率（Code Coverage）</span>
        </a></li><li>
        <a class="is-flex" href="#2-基本块（Basic-Block）">
        <span class="has-mr-6">4.2</span>
        <span>2. 基本块（Basic Block）</span>
        </a></li><li>
        <a class="is-flex" href="#3-边（edge）">
        <span class="has-mr-6">4.3</span>
        <span>3. 边（edge）</span>
        </a></li><li>
        <a class="is-flex" href="#4-元组（tuple）">
        <span class="has-mr-6">4.4</span>
        <span>4. 元组（tuple）</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#六、计算代码覆盖率">
        <span class="has-mr-6">5</span>
        <span>六、计算代码覆盖率</span>
        </a></li><li>
        <a class="is-flex" href="#参考资料">
        <span class="has-mr-6">6</span>
        <span>参考资料</span>
        </a></li></ul>
        </div>
    </div>
</div>

    
    
        <div class="column-right-shadow is-hidden-widescreen is-sticky">
        
        </div>
    
</div>

                
            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo.svg" alt="AFL漏洞挖掘技术漫谈：Fuzz结果分析和代码覆盖率" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2019 Jon Tsang&nbsp;
                <!--Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a
                        href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>-->
                
                <br>
                <span id="busuanzi_container_site_uv">
                共<span id="busuanzi_value_site_uv">0</span>个访客
                </span>
                
                </p>
            </div>
            <div class="level-end">
            
                <div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle">
                
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Creative Commons" href="https://creativecommons.org/">
                        
                        <i class="fab fa-creative-commons"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/">
                        
                        <i class="fab fa-creative-commons-by"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                </p>
                
                </div>
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-CN");</script>

<script>
var IcarusThemeSettings = {
    article: {
        highlight: {
            clipboard: true,
            fold: 'unfolded'
        }
    }
};
</script>


    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>



    
    
    
    <script src="/js/animation.js"></script>
    

    
    
    
    <script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
    <script src="/js/gallery.js" defer></script>
    

    
    

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


    
    
<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>

    
    

<a id="back-to-top" title="回到顶端" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>


    
    

    
    
    
    

    
    
    
    
    

    


<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>